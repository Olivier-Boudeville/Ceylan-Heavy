<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/REC-html40/loose.dtd">
<!--    This document is a part of the Ceylan project. 
        For any comment, please mail to olivier.boudeville@online.fr
-->
<!--    
        Creation date: Saturday, July 7, 2007.
        Author: Olivier Boudeville (olivier.boudeville@online.fr)
        Update made by:  the author
        Version number: 0.1
-->

<html lang="EN">
<head>
  <title>Ceylan - WOOPER documentation</title>
  <meta http-equiv="Content-Type" content=
  "text/html; charset=iso-8859-1">
  <meta name="description" content="Ceylan">
  <meta name="keywords" content="Ceylan, generic, GPL">
  <link href="../../../images/Ceylan-icon.png" rel="Ceylan icon">
  <link rel="STYLESHEET" type="text/css" href="../../../common/css/Ceylan.css">
</head>

<body>
  <div class="banner">
    <p><em>General</em> <a href="../../../common/black.html" onclick= 
    "parent.toolbar.location='../../MainMenu.html'">home page</a>
    <a href="../../Map.html">site map</a> <a href=
    "mailto:olivier.boudeville@online.fr?subject=[Ceylan]%20WOOPER">
    mail us</a></p>
  </div><a name="_top_"></a></span> 



<h1>WOOPER: <em>Wrapper for OOP in Erlang</em></h1>

<p>
WOOPER is an <a href="#license">open source</a> lightweight layer on top of the <a href="http://erlang.org" target="_blank">Erlang</a> language offering constructs dedicated to <a href="http://en.wikipedia.org/wiki/Object-oriented_programming" target="_blank">Object-Oriented Programing</a>. WOOPER is a part of the <a href="http://ceylan.sourceforge.net" target="_blank">Ceylan</a> project.
</p>

<p>
Some problems may almost only be tackled efficiently thanks to an objet-oriented modeling. The set of code and conventions proposed here allow to have all the main OOP features (including polymorphism, life cycle management, state management and multiple inheritance) available from Erlang, so that object-oriented approach at the implementation level can be easily achieved, for the cases where it makes sense.
</p>



<p>
Here is a simple example of how WOOPER instances can be managed. This shows new/delete operators, method calling (both request and oneway), and inheritance (a cat is here a viviparous mammal, as defined <a href="#example">below</a>):
<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
Eshell V5.5.2  (abort with ^G)
1&gt; Age=2,Gender=male,FurColor=sand,WhiskerColor=white.
white
2&gt; MyCat=class_Cat:new(Age,Gender,FurColor,WhiskerColor).
<0.33.0&gt;
3&gt; MyCat ! {canEat,tangerine,self()}, receive {wooper_result,R1} -&gt; R1 end.
false
4&gt; MyCat ! {canEat,meat,self()}, receive {wooper_result,R2} -&gt; R2 end.
true
5&gt; MyCat ! {getWhiskerColor,[],self()}, receive {wooper_result,R3} -&gt; R3 end.
white
6&gt; MyCat ! {getAge,[],self()}, receive {wooper_result,R4} -&gt; R4 end.
2
7&gt; MyCat ! {setAge,5}.
{setAge,5}
8&gt; MyCat ! {getAge,[],self()}, receive {wooper_result,R5} -&gt; R5 end.
5
9&gt; MyCat ! delete.
Destructing a Mammal (overriden destructor).
delete

</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
</p>

<p>
This class "Cat" is itself defined this way:
<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
-module(class_Cat).


% Determines what are the mother classes of this class (if any):
-define(wooper_superclasses,[class_Mammal,class_ViviparousBeing]).


% Parameters taken by the constructor ('construct'). 
% They are here the ones of the Mammal mother class (the viviparous being 
% constructor does not need any parameter) plus whisker color.
% These are class-specific data needing to be set in the constructor:
-define(wooper_construct_attributes,Age,Gender,FurColor,WhiskerColor).

% Construction-related exported operators:
-define(wooper_construct_export,new/4,construct/5).

% Method declarations.
-define(wooper_method_export,getTeatCount/1,canEat/2,getWhiskerColor/1).

% Allows to define WOOPER base variables and methods for that class:
-include("wooper.hrl").


% Constructs a new Cat.
construct(State,?wooper_construct_attributes) -&gt;

	% First the direct mother classes:
	MammalState = class_Mammal:construct( State, Age, Gender, FurColor ),
	ViviparousMammalState = class_ViviparousBeing:construct( MammalState ),
	
	% Then the class-specific attributes:
	?setAttribute( ViviparousMammalState, whisker_color, WhiskerColor ).
	

% No guarantee on biological fidelity:	
getTeatCount(State) -&gt;
	?wooper_return_state_result( State, 6 ).

	
% Cats are supposed carnivorous though:
canEat(State,soup) -&gt;	
	?wooper_return_state_result( State, true );
	
canEat(State,chocolate) -&gt;	
	?wooper_return_state_result( State, true );
	
canEat(State,croquette) -&gt;	
	?wooper_return_state_result( State, true );

canEat(State,meat) -&gt;	
	?wooper_return_state_result( State, true );

canEat(State,_) -&gt;
	?wooper_return_state_result( State, false ).


getWhiskerColor(State)-&gt;
	?wooper_return_state_result( State, ?getAttr(whisker_color) ).
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
Straightforward, isn't it ? We will discuss it in-depth though.
</p>



<p>

<a name="maintoc"></a>
<center>
        <table summary="Table of contents" style="border: none">
        <tr>
          <td>
<!--
                       <a href="#"></a><br>
-->

                   <div class="box">
                       <a href="#usage">Usage</a><br>
                       <a href="#example">Example</a><br>
                       <a href="#inner">Inner workings</a><br>
                       <a href="#next">Issues &amp; planned enhancements</a><br>
                       <a href="#license">License</a><br>
                       <a href="#sources">Sources</a><br>
                       <a href="#support">Support</a>
          </div>

          </td>
        </tr>
      </table>
</center>

</p>

<!--
<br><p><center>[<a href="#maintoc">Back to the table of contents</a>]</center></p><br>
-->


<a name="usage"></a>
<h2>WOOPER usage</h2>


<h3>Why adding Object-oriented elements to Erlang ?</h3>

<p>
Although applying blindly OOP with languages based on other paragdims (Erlang ones are functional and concurrent, it is not specifically targeting OOP) is a common mistake, there are some problems that may be deemed inherently "object-oriented", i.e. that cannot be effectively modelled without encapsulated abstractions sharing behaviours. 
</p>

<p>
Examples of this kind of systems are multi-agent simulations. If they often need massive concurrency, robustness, distribution, etc. (Erlang is particularly suited for that), the various actor types have also often to share numerous states and behaviours, while being able to specialize them on a per-type basis.
</p>

<p>
The <a href="#example">example</a> chosen here is a simulation of the interacting lives of numerous animals from various species. Obviously, they have to share behaviours (ex: all ovoviviparous beings may lay eggs, all creatures can live and die, all have an age, etc.), which cannot be mapped easily (read: automatically) to Erlang concepts without some generic constructs being added.
</p>

<p>
WOOPER, which stands for <em>Wrapper for OOP in Erlang</em>, is a lightweight yet effective (performance-wise, but also regarding developing efforts) means of making these constructs available, notably with regard to state management and multiple inheritance. The same simulations could be achieved without such OOP constructs, but at the expense of way too much manually-crafted specific (per-class) code. This process would be tedious, error-prone, and the result most often could be hardly maintained. 
</p>



<h3>How to use it ? Detailed description &amp; concept mappings</h3>



<h4>Classes</h4>


<h5>Class &amp; names</h5>
<p>
A class is a common scheme describing the behaviour and the internal data of its instances. With WOOPER each class must have a unique name.
</p>

<p>
To allow for <b>encapsulation</b>, here a class is mapped to an Erlang module, whose name is made from the <code>class_</code> prefix followed by the class name, all in lowercase but the first letter. For example, a class modeling a cat should translate into an Erlang module named <code>class_Cat</code>, thus in a file named <code>class_Cat.erl</code>. At the top of this file, the corresponding module would be therefore declared with: <code>-module(class_Cat).</code>.
</p>

<p>
The class name can be obtained through its <code>get_class_name</code> WOOPER-defined method:

<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
&gt; class_Cat:get_class_name().
class_Cat
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
</p>


<h5>Inheritance &amp; superclasses</h5>
<p>
A WOOPER class can inherit from other classes, in this case the behaviour and the internal data of the mother classes are available by default to this child class. 
</p>

<p>
Being in a <b>multiple inheritance</b> context, a given class can have any number ([0..n]) of direct mother classes (which themselves may have mother classes, and so on). This is declared in WOOPER thanks to the <code>wooper_superclasses</code> define. For example, a class with no mother class should have, once its module is declared, <code>-define(wooper_superclasses,[]).</code>.
</p>

<p>
As for our cat, this animal could be modelled both as a mammal (itself a specialized creature) and a viviparous being (neither of them is a subset of the other, these are mostly unrelated concepts; at least for that example !). Hence its mother classes could be described as: <code>-define(wooper_superclasses,[class_Mammal, class_ViviparousBeing]).</code>
</p>


<p>
The superclasses (direct mother classes) of a given class can be retrieved thanks to its <code>get_superclasses</code> method:

<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
&gt; class_Cat:get_superclasses().
[class_Mammal,class_ViviparousBeing]
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
</p>



<h4>Instances</h4>


<h5>Instance mapping</h5>
<p>
With WOOPER, which focuses on multi-agent systems, all <b>instances</b> of a class are mapped to Erlang processes. They are therefore, in UML language, <em>active objects</em> (each has its own thread of execution, they apparently "live" simultaneously).
</p>


<h5>Instance state</h5>
<p>
Another part of encapsulation is <b>state management</b>: each instance should be stateful, and able to inherit the data members defined by its mother classes. In WOOPER, this is obtained thanks to a per-instance associative table, where keys are the name of attributes and values are their value.
</p>


<h4>Methods</h4>
<p>
Instances may offer <b>methods</b> that can be publicly called, including remotely (RMI: <em>Remote Method Invocation</em>). Methods (either inherited or defined directly in the class) are mapped to specific Erlang functions, triggered by messages. For example, our cat may define following methods:
<ul>

<!--
	<li></li>
-->
	<li><code>canEat</code>, taking one parameter describing the type of food, and returning whether the cat can eat that kind of food or not. This should be cat-specific</li>
	<li><code>getWhiskersColor</code>, taking no parameter, returning the color of its whiskers. This is indeed cat-specific</li>
	<li>
		<p><code>declareBirthday</code>, incrementing the age of our cat, not taking any parameter nor returning anything. This will be therefore be implemented as a one-way call (i.e. not returning any result to the caller), only interesting for its effect on the cat state: making it one year older.
		</p>	
		<p>Declaring a birthday is not cat-specific, nor mammal-specific: we can consider it being creature-specific. Cat instances should then inherit this method, preferably indirectly from the <code>class_Creature</code> class, in all cases without having to specify anything since the <code>wooper_superclasses</code> define should already imply that information</p>
	</li>

</ul>
</p>

<p>
 We will discuss the definition of these methods later, but for the moment let's determine their signatures and declarations, and how we are expected to call them.
</p>


<h5>Method declaration</h5>

<p>
The cat-specific methods are to be declared, in the <code>class_Cat</code>, thanks to the <code>wooper_method_export</code> clause. Their arity should be equal to the number of parameters they should be called with, plus one. The additional parameter is an implicit one (automatically managed by WOOPER), corresponding to the state of the instance. This <code>State</code>
 variable defined by WOOPER can be somehow compared to the <code>self</code> parameter of Python, or to the <code>this</code> pointer of C++.
</p>

<p>
In our example, it would result in: <code>-define(wooper_method_export,canEat/2,getWhiskersColor/1).</code> (as <code>declareBirthday</code> will be inherited, no need to declare it).
</p>


<h5>Method invocation</h5>
<p> 
If MyCat is an instance of <code>class_Cat</code>, these methods (either defined locally or inherited) should be called this way:
<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
MyCat ! {canEat,soup,self()},
receive

	{wooper_result,true} ->
		io:format( "This cat likes soup !!!" );

	{wooper_result,false} ->
		io:format( "This cat does not seem omnivorous." )
		
end,

MyCat ! {getWhiskersColor,[],self()},
receive
		
	{wooper_result,white} ->
		io:format( "This cat has normal whiskers." );
		
	{wooper_result,blue} ->
		io:format( "What a weird cat..." )

end,

MyCat ! declareBirthday,	
end.	
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
</p>

<p>
Some information must be given here: methods are designated by their atom name (as declared in the <code>wooper_method_export</code> clause of the class in the inheritance tree that define them), which is always the first information given in the method tuple. There are requests (that return a result) and one-way calls (that change only the state of the instance, no reply sent back). Both can take any number of parameters, including none. They are to be specified in a (possibly empty) list. If only one parameter is needed, the list can be omitted, and the parameter can be directly specified: <code>Me ! {setAge,30}.</code>
 works as well as <code>Me ! {setAge,[30]}.</code>.
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>

</p>

<p>
<b>Requests</b> have to specify an additional information, the PID to which the answer should be sent, almost always the caller (hence the <code>self()</code>). Finally these three potential information (method name, parameters, sender, i.e. an atom, usually a list and a PID) are gathered in a tuple sent as a message: <code>{method_name,[Arg1,Arg2,..],self()}</code>. For example: <code>MyCat ! {getAge,[],self()}</code> or <code>MyCalculator ! {sum,[1,2,4],self()}</code>.
</p>

<p>
<b>One-way methods</b> do not have to specify a sender (if ever they send one nevertheless, a warning will be sent to them, the atom <code>wooper_method_returns_void</code> instead of <code>{wooper_result,Result}</code>). Hence oneway methods may be 2-element tuples (<code>{method_name,[Arg1,Arg2,..]}</code>, for example: <code>MyCat ! {setAge,5}</code> or <code>MyPoint ! {setCoordinates,[14,6]}</code>
) or, if they do not take parameters, just the atom <code>method_name</code>, for example: <code>MyCat ! declareBirthday</code>. Due to their nature, if an error occurs with a oneway call, the sender (the client) will never be notified.
</p>

<p>
As for the result, if the method execution succeeded, <code>{wooper_result,ActualResult}</code> will be sent back, otherwise one of the following error messages will be emitted:
<ul>

<!--
	<li><code></code>: </li>
-->

	<li><b>wooper_method_not_found</b>, i.e. <code>{wooper_method_not_found, Module, MethodName, MethodArity}</code>: for example <code>{wooper_method_not_found, class_Cat, layEggs, 2}</code>. <code>MethodArity</code> counts the implied state parameter. This error occurs whenever a called method could not be found in the whole inheritance graph (not implemented)</li>

	<li><b>wooper_method_failed</b>, i.e. <code>{wooper_method_failed, InstancePID, Module, MethodName, MethodArity, Parameters, ErrorTerm}</code>: for example, <code>{wooper_method_failed, &lt;0.30.0&gt;, class_Cat, myCrashingMethod, 1, [], {{badmatch,create_bug}, [..]]}</code>. If the exit message sent by the method specifies a PID, it is prepended to ErrorTerm</li>

	<li><b>wooper_method_faulty_return</b>, i.e. <code>{wooper_method_faulty_return, InstancePID, Module, MethodName, MethodArity, ParameterList, ActualReturn}</code>: for example <code>{wooper_method_faulty_return, &lt;0.30.0&gt;, class_Cat, myFaultyMethod, 1, [], [{{state_holder,..]}</code>. This error can only occur in debug mode, and indicates that the method implementation did not respect the expected method return convention (neither <code>wooper_return_state_result</code> nor
<code>wooper_return_state_only</code> used)</li>
	
</ul>
</p>


<h3>Method definition</h3>
<p>
A method signature has always for first parameter the state of the instance, for example : <code>getAge(State) -&gt; [..]</code>, or <code>getCoordinate(State,Number) -&gt; [..]</code>.
</p>

<p>
A method must always return at least the new instance state, even if the state did not change. In this case the parameter is directly returned :
<center>
    <table summary="Code" style="border : none">
        <tr>
          <td>
            <div class="box">
<code><pre>
getWhiskerColor(State)->
	?wooper_return_state_result( State, ?getAttr(whisker_color) ).
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
State is unchanged here.
</p>

<p>
Depending on its returning a specific result, the method signature will correspond either to:
<ul>
	<li>a <b>request</b>, and <code>?wooper_return_state_result(NewState,Result)</code> wil be used: the new state will be kept by the instance and the result will be sent to the client. For example,
<center>
    <table summary="Code" style="border : none">
        <tr>
          <td>
            <div class="box">
<code><pre>
getAge(State) ->
	?wooper_return_state_result(State,?getAttr(age)).
	</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
 </li>
 
	<li>a <b>oneway</b>, and <code>?wooper_return_state_only(NewState)</code> will be used: the instance state will be updated, nothing returned. For example,
<center>
    <table summary="Code" style="border : none">
        <tr>
          <td>
            <div class="box">
<code><pre>
setAge(State,NewAge) ->
	?wooper_return_state_only(?setAttribute(State,age,NewAge)).
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
Oneways may leave the state unchanged, only being called for side-effects, for example:
<center>
    <table summary="Code" style="border : none">
        <tr>
          <td>
            <div class="box">
<code><pre>
displayAge(State) ->
	io:format("My age is ~B~n.",[getAttr(age)]),
	?wooper_return_state_only(State).
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>

</li>

</ul>
</p>

<p>
The two <code>wooper_return_state_*</code> macros are actually quite simple, they are just here to structure the method implementations and to help ensuring, in debug mode, they are well-formed. 
</p>


<h3>Attributes management</h3>
<p>
As seen in various examples, most methods will access (read/write) to attributes stored in the instance state, whose original version is always specified as their first parameter. 
</p>

<p>
Setting an attribute (creating and/or modifying it) should be done with the <code>setAttribute</code> macro : <code>?setAttribute(AState,AttributeName,NewAttributeValue)</code>. For example, <code>?setAttribute(State,age,3)</code> will set, in the state <code>State</code>, the <code>age</code> attribute to 3. 
</p>

<p>
Getting the value of an attribute should be done with the <code>getAttribute</code> macro : <code>?getAttribute(AState,AttributeName)</code>. For example, <code>?getAttribute(State,whisker_color)</code>
 returns the value of the attribute <code>whisker_color</code> from state <code>State</code>.
</p>

<p>
The requested attribute may not exist in the specified state. In this case, <code>getAttribute</code> returns <code>{ attribute_not_found, AttributeName, ClassName }</code>, for example <code>{ attribute_not_found, nozzle_color, class_Cat}</code>.
</p>

<p>
Quite often, when retrieving an attribute, the state variable will be named <code>State</code> (when using directly the original state specified in the method declaration). In this case, the <code>getAttr</code> macro can be used: <code>?getAttr(whisker_color)</code> expands as <code>?getAttribute(State,whisker_color)</code> (but is shorter).
</p>


<h3>Method look-up &amp; calls</h3>
<p>
When a method M/n is called, WOOPER tries to find <code>M(State,arg1,..,argn-1)</code>. Name and arity must match, the method may not be found. In this case, the <code>wooper_method_not_found</code> atom is returned, and the object state did not change.
</p>

<p>
Oneway methods should be called like this: <code>MyPoint ! {setXY,[1,2]}</code>, and no result is to be managed. 
</p>

<p>
As for requests, <code>receive</code> should be used to retrieved the result, like in:

<center>
    <table summary="Code" style="border : none">
        <tr>
          <td>
            <div class="box">
<code><pre>
MyPoint ! {getCoordinates,[],self()},
receive

	{wooper_result,[X,Y]} ->
		[...];
	
	% Can be left out (let it crash):
	Error ->
		[...]
		
end,
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
</p>

<p>
Errors can be better discriminated if needed (but defensive development is not really favored in Erlang):
<center>
    <table summary="Code" style="border : none">
        <tr>
          <td>
            <div class="box">
<code><pre>
MyPoint ! {getCoordinates,[],self()},
receive

	{wooper_result, [X,Y] } ->
		[...];
	
	{wooper_method_not_found, Module, Method, Arity} ->
		[...];

	{wooper_method_failed, Pid, Module, Method, Arity, Parameters, ErrorTerm} ->
		[...];

	{wooper_method_faulty_return, Pid, Module, Method, Arity, Parameters, ErrorTerm} ->
		[...];

	wooper_method_returns_void ->

	OtherError ->
		% Should never happen:
		[...]
		
end,

</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
</p>



<p>
<b>Marshalling</b> of parameters and return values is made automatically by Erlang.  
</p>


<p>
<b>Multiple inheritance</b> and <b>polymorphism</b> are managed by WOOPER: even if our cat class does not define a <code>getAge</code> method, it can be readily be used as it is inherited from its mother classes (here from Creature, an indirect mother class). All Creature instances can be handled the same:

<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
% Inherited methods work exactly the same as methods defined directly 
% in the class:
MyCat ! {getAge,[],self()},
receive
		
	{wooper_result,Age} ->
		io:format( "This is a ~B year old cat.", [Age] ) ;

end,

% Polymorphism is immediate:
% (class_Platypus inheriting too from class_Mammal)
MyPetList = [ MyCat, MyPlatypus ],
foreach( 
	fun(AnyCreature) ->
		AnyCreature ! {getAge,[],self()},
		receive
		
			{wooper_result,Age} ->
				io:format( "This is a ~B year old creature.", [Age] )

		end,
	MyPetList).
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
</p>


<p>
<b>Life-cycle</b> is managed thanks to the <code>new</code> and the
<code>delete</code> operators (both are WOOPER-reserved function names, for all arities):
<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
MyCat = class_Cat:new(Age,Gender,FurColor,WhiskerColor),
MyCat ! delete
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
</p>

<p>
Only one <code>new/construct</code> pair can be defined, but this unique constructor may branch to as many subconstructors as needed:
<code>MyCat = Class_Cat:new(ConstructorType,ConstructorParameters).</code>. For example: <code>MyCat = Class_Cat:new(constructor_one,[1,2]).</code>.
</p>

<p>
The <code>delete</code> operator can be omitted, in this case a default destructor is used, and the instance is stopped and garbage-collected. 
If a specific action must be performed on deletion, potentially-chained destructors can be defined:
<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
% Overriding default destructor:	
% State should be returned, and destructors should be called in leaf-to-root
% order in inheritance tree.
delete(State) ->
	% Perform here class-specific action (ex: socket or file explicit closing).
	LocalDelState = my_action( State ),
	% Then if needed call the mother class counterparts:
	OneDelState = class_MotherOne:delete( LocalDelState ),
	TwoDelState = class_MotherTwo:delete( OneDelState ),
	% Finally return the state to allow child classes to chain:
	TwoDelState.
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>

</p>


<p>
Based on the <code>wooper_construct_attributes</code> define (let us suppose n attributes are listed in it), <code>new</code> and <code>construct</code> must be declared thanks to: <code>-define( wooper_construct_export, new/n, construct/n+1).</code>.
</p>

<p>
For example, <code>-define( wooper_construct_attributes, Age, Gender ).</code> results in <code>-define( wooper_construct_export, new/2, construct/3 ).</code>.
</p>

<p>
The <code>new</code> operator is automatically defined by WOOPER, only the <code>construct</code> special method must be implemented by the user. 
</p>

<p>
The <code>construct</code> functions are expected to be chained: they must be designed to be called by the ones of child classes, and they must call themselves the constructors of their mother classes, if any. Hence they always take the current state of the instance being created as a starting base, and returns it once updated, first from the direct mother classes, then by this class itself.
</p>

<p>
For example, <code>class_Cat</code> inherits directly from <code>Mammal</code>
and <code>ViviparousBeing</code>, and as only one attribute (<code>whisker_color)</code> on its own:
<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
% Constructs a new Cat.
construct(State,?wooper_construct_attributes) ->

	% First the direct mother classes:
	MammalState = class_Mammal:construct( State, Age, Gender, FurColor ),
	ViviparousMammalState = class_ViviparousBeing:construct( MammalState ),
	
	% Then the class-specific attributes:
	?setAttribute( ViviparousMammalState, whisker_color, WhiskerColor ).

</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>

</p>

<p>
The fact that the <code>Mammal</code> class itself inherits from the <code>Creature</code> class must not appear here: it is to be managed directly by <code>class_Mammal:construct</code>.
</p>

<p>
One should ensure that, in constructors, the successive states are always built from the last updated one:

<center>
    <table summary="Code" style="border : none">
        <tr>
          <td>
            <div class="box">
<code><pre>
% WRONG, the age update is lost:
construct(State,Age,Sex) ->
	AgeState = setAttribute(State,age,Age),
	setAttribute(State,sex,Sex),
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>


<center>
    <table summary="Code" style="border : none">
        <tr>
          <td>
            <div class="box">
<code><pre>
% RIGHT:
construct(State,Age,Sex) ->
	AgeState = setAttribute(State,age,Age),
	setAttribute(AgeState,sex,Sex),
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>

</p>

<p>
WOOPER is in some ways adding features very similar to the ones of Python (simple multiple inheritance, implied <code>self/State</code> parameter, attribute dictionaries, etc.; with less syntatic sugar available though) while still offering the major strengths of Erlang (concurrency, distribution, functional paradigm) and not hurting too much overall performances (mainly thanks to the prebuilt attribute and method hashtables).
</p>

<p>
All WOOPER classes must include <a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/src/wooper.hrl?view=markup" target="_blank">wooper.hrl</a>. To help declaring the right defines in the right order, using a WOOPER <a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_Template.erl?view=markup" target="_blank">template</a> is recommended.
</p>

<p>
One should have <code>utils.beam</code>, <code>hashtable.beam</code> and <code>wooper_class_manager.beam</code> available to the interpreter before using WOOPER-based classes. Using some kind of makefiles is recommended.
</p>

<p>
These modules must be compiled before using WOOPER, for example: 
<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
1> c(hashtable).
{ok,hashtable}
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
</p>



<br><p><center>[<a href="#maintoc">Back to the table of contents</a>]</center></p><br>




<a name="example"></a>
<h2>WOOPER example</h2>

<p>
We created a small set of classes allowing to show multiple inheritance:

<center>
    <a href="wooper-example.png" target="_blank"><img src="wooper-example.png" alt="WOOPER example" width="95%"></img></a><br>
(click to enlarge)
</center>
</p>


<h3>Class implementations</h3>
<ul>

    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_Creature.erl?view=markup" target="_blank">class_Creature.erl</a></li>
    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_ViviparousBeing.erl?view=markup" target="_blank">class_ViviparousBeing.erl</a></li>
    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_OvoviviparousBeing.erl?view=markup" target="_blank">class_OvoviviparousBeing.erl</a></li>
    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_Mammal.erl?view=markup" target="_blank">class_Mammal.erl</a></li>
    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_Reptile.erl?view=markup" target="_blank">class_Reptile.erl</a></li>
    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_Cat.erl?view=markup" target="_blank">class_Cat.erl</a></li>
    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_Platypus.erl?view=markup" target="_blank">class_Platypus.erl</a></li>
	
</ul>


<h3>Tests</h3>
<ul>

    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_Creature_test.erl?view=markup" target="_blank">class_Creature_test.erl</a></li>
    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_ViviparousBeing_test.erl?view=markup" target="_blank">class_ViviparousBeing_test.erl</a></li>
    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_OvoviviparousBeing_test.erl?view=markup" target="_blank">class_OvoviviparousBeing_test.erl</a></li>
    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_Mammal_test.erl?view=markup" target="_blank">class_Mammal_test.erl</a></li>
    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_Reptile_test.erl?view=markup" target="_blank">class_Reptile_test.erl</a></li>
    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_Cat_test.erl?view=markup" target="_blank">class_Cat_test.erl</a></li>
    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_Platypus_test.erl?view=markup" target="_blank">class_Platypus_test.erl</a></li>
	
</ul>


<br><p><center>[<a href="#maintoc">Back to the table of contents</a>]</center></p><br>




<a name="inner"></a>
<h2>WOOPER inner workings</h2>

<p>
Each instance runs a main loop (<code>wooper_main_loop</code>, defined in <code>wooper.hrl</code>) that keeps its internal state and through a <code>receive</code> serves the methods specified by incoming messages.
</p>

<p>
The kept state is twofold:
<ul>
	<li><p>a <b>method virtual table</b>: this per-class hashtable is built at runtime, on the first creation of an instance of this class, and stored by the unique (singleton) Wooper class manager that shares it to all the class instances. This manager is itself spawned the first time it is needed, and stays ready for all instances of various classes being created (it uses a hashtable to associate virtual tables to classes).</p>
	
	<p>This per-class method table has for keys the known method names (atoms) for this class, associated to the values being the most specialized module, in inheritance tree, that defines that method. Hence each instance has a reference to a shared hashtable that allows for a direct method look-up. As the table is built only once and is shared by all instances, it adds very little overhead, space-wise and time-wise. Thanks to the hashtable, method look-up is efficient too
	</p>
	</li>
	
	<li>an <b>attribute table</b>: another hashtable, this time per-instance. Keys are attribute names, values are attributes values. It allows a seamless yet not too slow access to all data member, including inherited ones</li>
</ul>
</p>


<p>
WOOPER relies only on these specific files:
<ul>

<!--
    <li><a href="" target="_blank"></a></li>
-->

    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/src/wooper.hrl?view=markup" target="_blank">wooper.hrl</a>: the WOOPER core, which gives modules using it all the OOP constructs discussed</li>
    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/src/wooper_class_manager.hrl?view=markup" target="_blank">wooper_class_manager.hrl</a>: the (very short) class manager header</li>
    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/src/wooper_class_manager.hrl?view=markup" target="_blank">wooper_class_manager.erl</a>: the class manager itself, the unique process that is automatically spawned to share virtual tables among instances</li>
    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/common/hashtable.erl?view=markup" target="_blank">hashtable.erl</a>: efficient associative table used by WOOPER for virtual tables, methods, attributes</li>
    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/common/utils.erl?view=markup" target="_blank">utils.erl</a>: a small module used by the hashtable and other modules</li>
</ul>
</p>


<p>
As Burkhard Neppert suggested, an alternative way of implementing OOP here could be to use Erlang behaviours. This is the way OTP handles generic functionalities that can be specialized (e.g. <code>gen_server</code>). One approach could be to map each objet-oriented base class to an Erlang behaviour. 
</p>

<p>
See some guidelines about <a href="http://wiki.trapexit.org/index.php/Defining_Your_Own_Behaviour" target="_blank">defining</a> your own behaviours and making them <a href="http://wiki.trapexit.org/index.php/Cascading_Behaviours" target="_blank">cascade</a>.
</p>





<h2>Conventions</h2>




<h3>Instances, a.k.a. Objects</h3>
<p>
An object (which is an instance of a class, with its own execution thread, active object in UML language) is able to expose a public interface (a kind of API for a server) that can be used by clients to trigger RMI-like calls.
</p>

<p>
An object must be created through a special function defined by its class, the operator <code>new</code>, that will call a constructor. Example: <code>My_car = class_car:new("Dodge","Viper").</code>. 
</p>

<p>
Example: <code>-module(my_class)...</code> in my_class.erl defines a class <code>my_class</code>.
</p>


<p>
An interface is a set of public methods. Interfaces are inherited between classes.
</p>



<h3>Methods</h3>
<p>
There are two kinds of possible methods to an object: requests and oneways.
Requests are supposed to send back an answer to the caller (the client), whereas oneways are just handled by the server, with no answer to expect from the client side. Both can be either with or without arguments.
</p>


<h3>Requests</h3>
<p>
To send an answer to the client, the server needs to know its PID, hence requests have to specify it.
</p>

<p>
Moreover the client needs to be able to sort out multiple asynchronous answers to requests it may have sent to different (server) objects, so the answer to requests have to send back the PID of the server as well.
</p>



<h3>Oneways</h3>
<p>

</p>





<!-- #####################################################################" -->


<a name="current"></a>
<h2>Current stable version</h2>
<p>
WOOPER 0.1 is ready to be used and can be downloaded <a href="" target="_blank">here</a>.
</p>

<p>
A SVN check-out of WOOPER code can be obtained thanks to, for example:
<center>
    <table summary="a box" style="border: none">
        <tr>
          <td>
            <div class="box">
svn co https://ceylan.svn.sourceforge.net/svnroot/ceylan/Ceylan/trunk/src/code/scripts/erlang Wooper-code-checkout 
            </div>
          </td>
        </tr>
    </table>
</center>
</p>

<p>
Check-out of WOOPER documentation can be performed thanks to:
<center>
    <table summary="a box" style="border: none">
        <tr>
          <td>
            <div class="box">
svn co https://ceylan.svn.sourceforge.net/svnroot/ceylan/Ceylan/trunk/src/doc/web/main/documentation/wooper Wooper-doc-checkout
            </div>
          </td>
        </tr>
    </table>
</center>

</p>

<br><p><center>[<a href="#maintoc">Back to the table of contents</a>]</center></p><br>



<a name="next"></a>
<h2>Issues &amp; planned enhancements</h2>
 
<p>
<ul>

<!--
	<li><b></b>: </li>
-->

	<li>Is <b>wooper_main_loop</b> (in <code>wooper.hrl</code>) really tail-recursive ?</li>
	<li>Integrate <b>persistant storage</b> of instance states into a Mnesia database</li>
	<li>Would there be a <b>more efficient</b> implementation of hashtables ? (ex: ets-based)</li>
	
</ul>

</p>

<!-- #####################################################################" -->


<a name="license"></a>
<h2>License</h2>
<p>
WOOPER is licensed under a disjunctive tri-license giving you the choice of one of the three following sets of free software/open source licensing terms:
<ul>

<!--
    <li><a href="" target="_blank"></a></li>
-->

    <li><a href="http://www.mozilla.org/MPL/MPL-1.1.html" target="_blank">Mozilla Public License</a> (MPL), version 1.1 or later (very close to the <a href="http://www.erlang.org/EPLICENSE" target="_blank">Erlang Public License</a>, except aspects regarding Ericsson and/or the Swedish law)</li>
    <li><a href="http://www.gnu.org/licenses/gpl-2.0.html" target="_blank">GNU General Public License</a> (GPL), version 2.0 or later</li>
    <li><a href="" target="_blank">GNU Lesser General Public License</a> (LGPL), version 2.1 or later</li>
</ul>
</p>

<p>
This allows the use of the WOOPER code in as wide a variety of software projects as possible, while still maintaining copyleft on this code. Being triple-licensed means that someone (the licensee) who modifies and/or distributes it can choose which of the available sets of license terms he is operating under.
</p>

<br><p><center>[<a href="#maintoc">Back to the table of contents</a>]</center></p><br>


<!-- #####################################################################" -->

<a name="sources"></a>
<h2>Sources</h2>

<p>
<!--
    <li><a href="" target="_blank"></a></li>
-->
	
    <li><b>Concurrent Programming in Erlang</b>, Joe Armstrong, Robert Virding, Claes Wikström et Mike Williams. Chapter 18, page 299: Object-oriented Programming</li>

    <li>Chris Rathman 's <a href="http://www.angelfire.com/tx4/cus/shapes/erlang.html" target="_blank">approach</a> to polymorphism</li> 
	
</ul>

</p>

<br><p><center>[<a href="#maintoc">Back to the table of contents</a>]</center></p><br>


<!-- #####################################################################" -->


<a name="support"></a>
<h2>Support</h2>
<p>
Bugs, questions, remarks, patches, requests for enhancements, etc. are to be sent to the <a href="mailto:ceylan-wooperNOSPAM@lists.sourceforge.net" target="_blank">ceylan-wooper at lists dot sourceforge dot net</a>. One must <a href="https://lists.sourceforge.net/lists/listinfo/ceylan-wooper" target="_blank">register</a> first.
</p>

<br><p><center>[<a href="#maintoc">Back to the table of contents</a>]</center></p><br>

<!-- #####################################################################" -->

  <br>
  <br>
  <br>

  <h3>Please react !</h3>

  <p>If you have information more detailed or more recent than those
  presented in this document, if you noticed errors, neglects or points
  insufficiently discussed, <a href=
  "mailto:olivier.boudeville@online.fr?subject=[Ceylan]%20WOOPER">
  drop us a line</a> !</p><br>
  <br>
  <hr>

  <center>
    [<a href="#_top_">Top</a>]<br>
    <br>
    <em>Last update: Saturday, July 21, 2007</em>
  </center>
</body>
</html>
