<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/REC-html40/loose.dtd">
<!--    This document is a part of the Ceylan project. 
        For any comment, please mail to olivier.boudeville@online.fr
-->
<!--    
        Creation date: Saturday, July 7, 2007.
        Author: Olivier Boudeville (olivier.boudeville@online.fr)
        Update made by:  the author
        Version number: 0.1
-->

<html lang="EN">
<head>
  <title>Ceylan - WOOPER documentation</title>
  <meta http-equiv="Content-Type" content=
  "text/html; charset=iso-8859-1">
  <meta name="description" content="Ceylan">
  <meta name="keywords" content="Ceylan, generic, GPL">
  <link href="../../../images/Ceylan-icon.png" rel="Ceylan icon">
  <link rel="STYLESHEET" type="text/css" href="../../../common/css/Ceylan.css">
</head>

<body>
  <div class="banner">
    <p><em>General</em> <a href="../../../common/black.html" onclick= 
    "parent.toolbar.location='../../MainMenu.html'">home page</a>
    <a href="../../Map.html">site map</a> <a href=
    "mailto:olivier.boudeville@online.fr?subject=[Ceylan]%20WOOPER">
    mail us</a></p>
  </div><a name="_top_"></a></span> 



<h1>WOOPER: <em>Wrapper for OOP in Erlang</em></h1>

<p>
WOOPER is an <a href="#license">open source</a> lightweight layer on top of the <a href="http://erlang.org" target="_blank">Erlang</a> language offering constructs dedicated to <a href="http://en.wikipedia.org/wiki/Object-oriented_programming" target="_blank">Object-Oriented Programming</a>. WOOPER is a part of the <a href="http://ceylan.sourceforge.net" target="_blank">Ceylan</a> project.
</p>


<p>
<a name="maintoc"></a>
<center><br>
        <table summary="Table of contents" style="border: none">
        <tr>
          <td>
<!--
                       <a href="#"></a><br>
-->

					<div class="box">
                       <a href="#overview">Overview</a><br>
                       <a href="#why">Why adding OOP to Erlang ?</a><br>
                       <a href="#how">How to use WOOPER ?</a><br>
                       <a href="#example">WOOPER example</a><br>
                       <a href="#current">Current stable version &amp; download</a><br>
                       <a href="#versions">Version history &amp; changes</a><br>
                       <a href="#inner">Inner workings</a><br>
                       <a href="#next">Issues &amp; planned enhancements</a><br>
                       <a href="#license">License</a><br>
                       <a href="#sources">Sources, inpirations &amp; alternate solutions</a><br>
                       <a href="#support">Support</a><br>
                       <a href="#developers">For WOOPER developers</a>
					</div>

          </td>
        </tr>
      </table>
</center>
</p>

<!--
<br><p><center>[<a href="#maintoc">Back to the table of contents</a>]</center></p><br>
-->

<!-- #####################################################################" -->



<a name="overview"></a>
<h2>Overview</h2>

<p>
Some problems may almost only be tackled efficiently thanks to an objet-oriented modeling. The set of code and conventions proposed here allow to have all the main OOP features (including polymorphism, life cycle management, state management and multiple inheritance) available from Erlang, so that an object-oriented approach at the implementation level can be easily achieved, for the cases where it makes sense.
</p>

<p>
Here is a simple example of how WOOPER instances can be managed. This shows new/delete operators, method calling (both request and oneway), and inheritance (a cat is here a viviparous mammal, as defined <a href="#example">below</a>):
<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
Eshell V5.5.2  (abort with ^G)
1&gt; Age=2,Gender=male,FurColor=sand,WhiskerColor=white.
white
2&gt; MyCat=class_Cat:new(Age,Gender,FurColor,WhiskerColor).
<0.33.0&gt;
3&gt; MyCat ! {canEat,tangerine,self()}, receive {wooper_result,R1} -&gt; R1 end.
false
4&gt; MyCat ! {canEat,meat,self()}, receive {wooper_result,R2} -&gt; R2 end.
true
5&gt; MyCat ! {getWhiskerColor,[],self()}, receive {wooper_result,R3} -&gt; R3 end.
white
6&gt; MyCat ! {getAge,[],self()}, receive {wooper_result,R4} -&gt; R4 end.
2
7&gt; MyCat ! {setAge,5}.
{setAge,5}
8&gt; MyCat ! {getAge,[],self()}, receive {wooper_result,R5} -&gt; R5 end.
5
9&gt; MyCat ! delete.
Destructing a Mammal (overriden destructor).
deleted

</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
</p>

<p>
This class <code>class_Cat</code> is itself defined this way:
<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
-module(class_Cat).


% Determines what are the mother classes of this class (if any):
-define(wooper_superclasses,[class_Mammal,class_ViviparousBeing]).


% Parameters taken by the constructor ('construct'). 
% They are here the ones of the Mammal mother class (the viviparous being 
% constructor does not need any parameter) plus whisker color.
% These are class-specific data needing to be set in the constructor:
-define(wooper_construct_parameters,Age,Gender,FurColor,WhiskerColor).

% Construction-related exported operators:
-define(wooper_construct_export,new/4,construct/5).

% Method declarations.
-define(wooper_method_export,getTeatCount/1,canEat/2,getWhiskerColor/1).

% Allows to define WOOPER base variables and methods for that class:
-include("wooper.hrl").


% Constructs a new Cat.
construct(State,?wooper_construct_parameters) -&gt;

	% First the direct mother classes:
	MammalState = class_Mammal:construct( State, Age, Gender, FurColor ),
	ViviparousMammalState = class_ViviparousBeing:construct( MammalState ),
	
	% Then the class-specific attributes:
	?setAttribute( ViviparousMammalState, whisker_color, WhiskerColor ).
	

% No guarantee on biological fidelity:	
getTeatCount(State) -&gt;
	?wooper_return_state_result( State, 6 ).

	
% Cats are supposed carnivorous though:
canEat(State,soup) -&gt;	
	?wooper_return_state_result( State, true );
	
canEat(State,chocolate) -&gt;	
	?wooper_return_state_result( State, true );
	
canEat(State,croquette) -&gt;	
	?wooper_return_state_result( State, true );

canEat(State,meat) -&gt;	
	?wooper_return_state_result( State, true );

canEat(State,_) -&gt;
	?wooper_return_state_result( State, false ).


getWhiskerColor(State)-&gt;
	?wooper_return_state_result( State, ?getAttr(whisker_color) ).
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
Straightforward, isn't it ? We will discuss it in-depth though.
</p>

<br><p><center>[<a href="#maintoc">Back to the table of contents</a>]</center></p><br>

<!-- #####################################################################" -->




<a name="why"></a>
<h2>Why adding Object-oriented elements to Erlang ?</h2>

<p>
Although applying blindly OOP with languages based on other paragdims (Erlang ones are functional and concurrent, it is not specifically targeting OOP) is a common mistake, there are some problems that may be deemed inherently "object-oriented", i.e. that cannot be effectively modelled without encapsulated abstractions sharing behaviours. 
</p>

<p>
Examples of this kind of systems are multi-agent simulations. If they often need massive concurrency, robustness, distribution, etc. (Erlang is particularly suited for that), the various actor types have also often to share numerous states and behaviours, while being able to specialize them on a per-type basis.
</p>

<p>
The <a href="#example">example</a> chosen here is a simulation of the interacting lives of numerous animals from various species. Obviously, they have to share behaviours (ex: all ovoviviparous beings may lay eggs, all creatures can live and die, all have an age, etc.), which cannot be mapped easily (read: automatically) to Erlang concepts without some generic constructs being added.
</p>

<p>
WOOPER, which stands for <em>Wrapper for OOP in Erlang</em>, is a lightweight yet effective (performance-wise, but also regarding developing efforts) means of making these constructs available, notably with regard to state management and multiple inheritance. The same simulations could be achieved without such OOP constructs, but at the expense of way too much manually-crafted specific (per-class) code. This process would be tedious, error-prone, and the result most often could be hardly maintained. 
</p>

<p><center>[<a href="#maintoc">Back to the main table of contents</a>]</center></p>


<!-- #####################################################################" -->


<br>

<a name="how"></a>
<h2>How to use WOOPER ?<br>Detailed description &amp; concept mappings</h2>


<a name="usagetoc"></a>
<center>
	<table summary="Usage table of contents" style="border: none">
        <tr>
          <td>
<!--
		       <a href="#"></a><br>
-->

			<div class="box">
		       <a href="#classes">Classes</a><br>
		       <a href="#instances">Instances</a><br>
		       <a href="#methods">Methods</a><br>
		       <a href="#statemanagement">State management</a><br>
		       <a href="#inheritpolymorph">Multiple inheritance &amp; polymorphism</a><br>
		       <a href="#lifecycle">Life cycle</a><br>
		       <a href="#misc">Misceallenous technical points</a>
			</div>

          </td>
        </tr>
      </table>
	  (<a href="#maintoc">Up to the main table of contents</a>)
</center>


<!--
<br><p><center>[<a href="#usagetoc">Back to the usage table of contents</a>]</center></p><br>
-->

<a name="classes"></a>
<h3>Classes</h3>


<h4>Class &amp; names</h4>
<p>
A class is a common scheme describing the behaviour and the internal data of its instances. With WOOPER each class must have a unique name.
</p>

<p>
To allow for <b>encapsulation</b>, here a class is mapped to an Erlang module, whose name is made from the <code>class_</code> prefix followed by the class name, all in lowercase but the first letter. For example, a class modeling a cat should translate into an Erlang module named <code>class_Cat</code>, thus in a file named <code>class_Cat.erl</code>. At the top of this file, the corresponding module would be therefore declared with: <code>-module(class_Cat).</code>.
</p>

<p>
The class name can be obtained through its <code>get_class_name</code> WOOPER-defined static method:

<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
&gt; class_Cat:get_class_name().
class_Cat
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
</p>


<h4>Inheritance &amp; superclasses</h4>
<p>
A WOOPER class can inherit from other classes, in this case the behaviour and the internal data of the mother classes are available by default to this child class. 
</p>

<p>
Being in a <b>multiple inheritance</b> context, a given class can have any number ([0..n]) of direct mother classes (which themselves may have mother classes, and so on). This is declared in WOOPER thanks to the <code>wooper_superclasses</code> define. For example, a class with no mother class should have, once its module is declared, <code>-define(wooper_superclasses,[]).</code>.
</p>

<p>
As for our cat, this animal could be modelled both as a mammal (itself a specialized creature) and a viviparous being (neither of them is a subset of the other, these are mostly unrelated concepts; at least for that example !). Hence its mother classes could be described as: <code>-define(wooper_superclasses,[class_Mammal, class_ViviparousBeing]).</code>
</p>


<p>
The superclasses (direct mother classes) of a given class can be retrieved thanks to its <code>get_superclasses</code> static method:

<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
&gt; class_Cat:get_superclasses().
[class_Mammal,class_ViviparousBeing]
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
</p>

<br><p><center>[<a href="#usagetoc">Back to the usage table of contents</a>]</center></p><br>



<a name="instances"></a>
<h3>Instances</h3>


<h4>Instance mapping</h4>
<p>
With WOOPER, which focuses on multi-agent systems, all <b>instances</b> of a class are mapped to Erlang processes (one instance, one process). They are therefore, in UML language, <em>active objects</em> (each has its own thread of execution, they apparently "live" simultaneously).
</p>


<h4>Instance state</h4>
<p>
Another part of encapsulation is <b>state management</b>: each instance should be stateful, and able to inherit the data members defined by its mother classes. In WOOPER, this is obtained thanks to a per-instance associative table, where keys are the name of attributes and values are their value. This will be detailed in the <a href="#statemanagement">state management</a> section.
</p>

<br><p><center>[<a href="#usagetoc">Back to the usage table of contents</a>]</center></p><br>



<a name="methods"></a>
<h3>Methods</h3>
<p>
Instances may offer <b>methods</b> that can be publicly called, including remotely (RMI: <em>Remote Method Invocation</em>). Methods (either inherited or defined directly in the class) are mapped to specific Erlang functions, triggered by messages. For example, our cat may define following methods:
<ul>

<!--
	<li></li>
-->
	<li><code>canEat</code>, taking one parameter describing the type of food, and returning whether the cat can eat that kind of food or not. This should be cat-specific</li>
	<li><code>getWhiskersColor</code>, taking no parameter, returning the color of its whiskers. This is indeed cat-specific</li>
	<li>
		<p><code>declareBirthday</code>, incrementing the age of our cat, not taking any parameter nor returning anything. This will be therefore be implemented as a one-way call (i.e. not returning any result to the caller, hence not needing to know it), only interesting for its effect on the cat state: making it one year older.
		</p>	
		<p>Declaring a birthday is not cat-specific, nor mammal-specific: we can consider it being creature-specific. Cat instances should then inherit this method, preferably indirectly from the <code>class_Creature</code> class, in all cases without having to specify anything, since the <code>wooper_superclasses</code> define already implies that relationship</p>
	</li>

</ul>
</p>

<p>
 We will discuss the definition of these methods later, but for the moment let's determine their signatures and declarations, and how we are expected to call them.
</p>


<h4>Method declaration</h4>

<p>
The cat-specific methods are to be declared, in the <code>class_Cat</code>, thanks to the <code>wooper_method_export</code> clause. Their arity should be equal to the number of parameters they should be called with, plus one. The additional parameter is an implicit one (automatically managed by WOOPER), corresponding to the state of the instance. This <code>State</code>
 variable defined by WOOPER can be somehow compared to the <code>self</code> parameter of Python, or to the <code>this</code> pointer of C++. That state is automatically kept by WOOPER classes in their main loop, and automatically prepended to the parameters of incoming method calls.
</p>

<p>
In our example, it would result in: <code>-define(wooper_method_export,canEat/2,getWhiskersColor/1).</code> (as <code>declareBirthday</code> will be inherited, no need to declare it).
</p>


<h4>Method invocation</h4>
<p> 
If MyCat is an instance of <code>class_Cat</code>, these methods (either defined locally or inherited) should be called thanks to a dedicated tuple:
<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
MyCat ! {canEat,soup,self()},
receive

	{wooper_result,true} -&gt;
		io:format( "This cat likes soup !!!" );

	{wooper_result,false} -&gt;
		io:format( "This cat does not seem omnivorous." )
		
end,

MyCat ! {getWhiskersColor,[],self()},
receive
		
	{wooper_result,white} -&gt;
		io:format( "This cat has normal whiskers." );
		
	{wooper_result,blue} -&gt;
		io:format( "What a weird cat..." )

end,

MyCat ! declareBirthday,	
end.	
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
</p>


<h5>Method name</h5>

<p>
Some information must be given here: methods are designated by their atom name (as declared in the <code>wooper_method_export</code> clause of the class in the inheritance tree that define them), which is always the first information given in the method call tuple.
</p>



<h5>Method parameters</h5>
<p>
As detailed below, there are requests (that return a result) and one-way calls (that change only the state of the instance, no reply sent back). Both can take any number of parameters, including none. <b>Marshalling</b> of parameters (and return values) is performed automatically by Erlang.  
</p>

<p>
Parameters are to be specified in a (possibly empty) list, as second element of the call tuple. If only one parameter is needed, the list can be omitted, and the parameter can be directly specified: <code>Me ! {setAge,30}.</code>
 works as well as <code>Me ! {setAge,[30]}.</code>.
</p>


<h5>Two kinds of methods</h5>

<h6>Request Methods</h6>

<p>To send an answer to a request from a caller, the instance needs to know the caller PID.
</p>

<p>Therefore <b>requests</b> have to specify, as the third element of the call tuple, an additional information: the PID to which the answer should be sent, almost always the caller (hence the <code>self()</code>). Finally these three potential information (method name, parameters, sender, i.e. an atom, usually a list and a PID) are gathered in a tuple sent as a message: <code>{method_name,[Arg1,Arg2,..],self()}</code>. For example: <code>MyCat ! {getAge,[],self()}</code> or <code>MyCalculator ! {sum,[1,2,4],self()}</code>.
</p>

<p>
<code>receive</code> should be used to retrieve the result, like in:

<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
MyPoint ! {getCoordinates,[],self()},
receive

	{wooper_result,[X,Y]} -&gt;
		[...];
	
	% Could be left out to ignore errors.
	% Otherwise one might prefer making this client crash:
	Error -&gt;
		[...]
		
end,
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
</p>


<h6>One-way Methods</h6>
<p>
<b>One-way methods</b> do not have to specify a sender PID, as no result is expected. If ever they sent one nevertheless, a warning will be sent back to them, the atom <code>wooper_method_returns_void</code> instead of <code>{wooper_result,Result}</code>.
</p>

<p>
Hence oneway methods should be called thanks to:
<ul>

	<li>2-element (i.e. with no PID specified) tuples: <code>{method_name,[Arg1,Arg2,..]}</code>, for example: <code>MyCat ! {setAge,5}</code> or <code>MyPoint ! {setCoordinates,[14,6]}</code></li>

	<li>or, if they do not take parameters, just the atom <code>method_name</code>, for example: <code>MyCat ! declareBirthday</code></li>

</ul>
</p>

<p>
No return should be expected (the instance does not even have the sender PID), so no receive should be attempted on the caller side. Due to their nature, if an error occurs instance-side during a oneway call, the caller will never be notified.
</p>


<h5>Method results</h5>
<p>
If the method execution succeeded, and if it is a request (not a oneway), <code>{wooper_result,ActualResult}</code> will be sent back, otherwise one of the following error messages will be emitted:
<ul>

<!--
	<li><code></code>: </li>
-->

	<li>
		<p><b>wooper_method_not_found</b>, i.e. <code>{wooper_method_not_found, Module, MethodName, MethodArity}</code>: for example <code>{wooper_method_not_found, class_Cat, layEggs, 2}</code>. <code>MethodArity</code> counts the implied state parameter. This error occurs whenever a called method could not be found in the whole inheritance graph. It means this method is not implemented, at least not with the deduced arity.
		</p>
		
		<p>More precisely, when a message <code>{method_name,[Arg1,Arg2,..,Argn]...}</code> (request or oneway) is received, <code>method_name/n+1</code> has be to called: WOOPER tries to find <code>method_name(State,Arg1,..,Argn)</code>, method name and arity must match. In the case where no method could be found, the <code>wooper_method_not_found</code> atom is returned, and the object state will not change
		</p>

</li>

	<li><b>wooper_method_failed</b>, i.e. <code>{wooper_method_failed, InstancePID, Module, MethodName, MethodArity, Parameters, ErrorTerm}</code>: for example, <code>{wooper_method_failed, &lt;0.30.0&gt;, class_Cat, myCrashingMethod, 1, [], {{badmatch,create_bug}, [..]]}</code>. If the exit message sent by the method specifies a PID, it is prepended to ErrorTerm. It means there is a runtime failure</li>

	<li><b>wooper_method_faulty_return</b>, i.e. <code>{wooper_method_faulty_return, InstancePID, Module, MethodName, MethodArity, ParameterList, ActualReturn}</code>: for example <code>{wooper_method_faulty_return, &lt;0.30.0&gt;, class_Cat, myFaultyMethod, 1, [], [{{state_holder,..]}</code>. This error occurs when other errors did not match (catch-all). The main reason for its happening is when debug mode is set and when a method implementation did not respect the expected method return convention (neither <code>wooper_return_state_result</code> nor
<code>wooper_return_state_only</code> used). It means the method is not implemented correctly (it has a bug)</li>
	
</ul>
</p>

<p>
So on the caller side, errors can be better discriminated if needed (but defensive development is not really favored in Erlang):
<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
MyPoint ! {getCoordinates,[],self()},
receive

	{wooper_result, [X,Y] } -&gt;
		[...];
	
	{wooper_method_not_found, Module, Method, Arity} -&gt;
		[...];

	{wooper_method_failed, Pid, Module, Method, Arity, Parameters, ErrorTerm} -&gt;
		[...];

	{wooper_method_faulty_return, Pid, Module, Method, Arity, Parameters, ErrorTerm} -&gt;
		[...];

	wooper_method_returns_void -&gt;
		[...];

	OtherError -&gt;
		% Should never happen:
		[...]
		
end,

</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
</p>


<h5>Method definition</h5>

<p>
Here we reverse the point of view: instead of calling a method, we are in the process of implementing a callable one.
</p>

<p>
A method signature has always for first parameter the state of the instance, for example: <code>getAge(State) -&gt; [..]</code>, or <code>getCoordinate(State,Number) -&gt; [..]</code>. For better clarity, this variable should be preferably named always <code>State</code>.
</p>

<p>
A method must always return at least the new instance state, even if the state did not change. In this case the state parameter is directly returned, as is:
<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
getWhiskerColor(State) -&gt;
	?wooper_return_state_result( State, ?getAttr(whisker_color) ).
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
State is unchanged here. 
</p>

<p>
Depending on its returning a specific result, the method signature will correspond either to:
<ul>
	<li>a <b>request</b>, and <code>?wooper_return_state_result(NewState,Result)</code> wil be used: the new state will be kept by the instance and the result will be sent to the client. Hence <code>wooper_return_state_result</code> means that the method returns a state <code>and</code> a result, in that order.  For example,
<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
getAge(State) -&gt;
	?wooper_return_state_result(State,?getAttr(age)).
	</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
All methods are of course given the parameters specified at their call. For example, for a cat having 2 male kitten and 3 female ones, we have:
<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
giveBirth(State,NumberOfMaleChildren,NumberOfFemaleChildren) -&gt; 
	[..]

MyCat ! {giveBirth,[2,3],self()}.
	</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
But requests can access to one more information than oneways: the PID of the client that sent the request. This can be done by reading the <code>request_sender</code> member of the state variable, which is automatically set by WOOPER:
<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
giveBirth(State,NumberOfMaleChildren,NumberOfFemaleChildren) -&gt; 
	ClientPID = State#state_holder.request_sender,
	[..]
	</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>

<p>
Thus requests have access to their client PID without having to specify it twice, i.e. with no need to specify it in the parameters as well as in the third element of the call tuple: instead of
<code>MyCat ! {giveBirth,[2,3,self()],self()}.</code>, only <code>MyCat ! {giveBirth,[2,3],self()}.</code> can be sent, while letting the possibility for the called request (here <code>giveBirth/3</code>, for a state and two parameters) to store the client PID (most probably in the state variable) for a later use.
</p>

<p>
 The <code>request_sender</code> member is set accordingly (i.e. with the right PID) only while a request method is being executed, otherwise its value is always the atom <code>undefined</code>.
</p>
 </li>
 
	<li>a <b>oneway</b>, and <code>?wooper_return_state_only(NewState)</code> will be used: the instance state will be updated, and no result will be returned. For example,
<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
setAge(State,NewAge) -&gt;
	?wooper_return_state_only(?setAttribute(State,age,NewAge)).
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
Oneways may leave the state unchanged, only being called for side-effects, for example:
<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
displayAge(State) -&gt;
	io:format("My age is ~B~n.",[getAttr(age)]),
	?wooper_return_state_only(State).
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>

</li>

</ul>
</p>

<p>
The two <code>wooper_return_state_*</code> macros are actually quite simple, they are just here to structure the method implementations (helping the method developer not mixing states and results), and to help ensuring, in debug mode, that methods are well-formed (an atom is then prepended to the returned tuple, and WOOPER matches it during post-invocation, before handling the return, for an increased safety). 
</p>

<br><p><center>[<a href="#usagetoc">Back to the usage table of contents</a>]</center></p><br>




<a name="statemanagement"></a>
<h3>State management</h3>

<p>
We are dealing here with the encapsulated inner state of an instance, which is only directly accessible inside its dedicated module.
</p>

<p>
An instance state is defined by a set of attributes. Each attribute is designated by a name and has a mutable value.
</p>

<p>
As seen in various examples, most method implementations will access (read/write) to attributes stored in the instance state, whose original version is always specified as their first parameter. 
</p>


<h4>Modifying state</h4>

<p>
Setting an attribute (creating and/or modifying it) should be done with the <code>setAttribute</code> macro: <code>?setAttribute(AState,AttributeName,NewAttributeValue)</code>. For example, <code>?setAttribute(State,age,3)</code> will set, in the state <code>State</code>, the <code>age</code> attribute to 3. 
</p>


<h4>Reading state</h4>
<p>
Getting the value of an attribute should be done with the <code>getAttribute</code> macro: <code>?getAttribute(AState,AttributeName)</code>. For example, <code>?getAttribute(State,whisker_color)</code>
 returns the value of the attribute <code>whisker_color</code> from state <code>State</code>.
</p>

<p>
The requested attribute may not exist in the specified state. In this case, <code>getAttribute</code> returns, instead of the result, <code>{ attribute_not_found, AttributeName, ClassName }</code>, for example <code>{ attribute_not_found, nozzle_color, class_Cat}</code>.
</p>

<p>
Quite often, when retrieving an attribute, the state variable will be named <code>State</code> (when using directly the original state specified in the method declaration). In this case, the <code>getAttr</code> macro can be used: <code>?getAttr(whisker_color)</code> expands as <code>?getAttribute(State,whisker_color)</code> (and is shorter).
</p>

<br><p><center>[<a href="#usagetoc">Back to the usage table of contents</a>]</center></p><br>





<a name="inheritpolymorph"></a>
<h3>Multiple inheritance &amp; polymorphism</h3>

<p>
Both are automatically managed by WOOPER: even if our cat class does not define a <code>getAge</code> method, it can be readily be used as it is inherited from its mother classes (here from <code>class_Creature</code>, an indirect mother class). All creature instances can be handled the same:

<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
% Inherited methods work exactly the same as methods defined directly 
% in the class:
MyCat ! {getAge,[],self()},
receive
		
	{wooper_result,Age} -&gt;
		io:format( "This is a ~B year old cat.", [Age] )

end,

% Polymorphism is immediate:
% (class_Platypus inheriting too from class_Mammal, hence from class_Creature)
MyPetList = [ MyCat, MyPlatypus ],
foreach( 
	fun(AnyCreature) -&gt;
		AnyCreature ! {getAge,[],self()},
		receive
		
			{wooper_result,Age} -&gt;
				io:format( "This is a ~B year old creature.", [Age] )

		end,
	MyPetList).
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
</p>

<br><p><center>[<a href="#usagetoc">Back to the usage table of contents</a>]</center></p><br>



<a name="lifecycle"></a>
<h3>Life-cycle</h3>

<p>
Creation and destruction of instances are managed respectively thanks to the <code>new</code> and the <code>delete</code> operators (both are WOOPER-reserved function names, for all arities):
<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
MyCat = class_Cat:new(Age,Gender,FurColor,WhiskerColor),
MyCat ! delete.
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
</p>


<h4>Instance creation: new and construct</h4>


<h5>Role of the new/construct pair</h5>

<p>
Whereas the purpose of <code>new</code> is to create a working instance on the user behalf, the role of <code>construct</code> is to initialize an instance of that class while being able to be chained for inheritance, as explained later. 
</p>

<p>
The <code>new</code> operator is automatically defined by WOOPER, but it relies on the class-specific <code>construct</code> special method (it cannot be called from outside the class module). The <code>construct</code> method is the one that must be implemented by the class developer.
</p>

<p>
Only one <code>new/construct</code> pair can be defined, but this unique twofold constructor may be defined to branch to as many subconstructors as needed: for example, <code>MyCat = Class_Cat:new(construct_from_point,[1,2]).</code>.
</p>


<h5>Declaration of the new/construct pair</h5>

<p>
When an instance is created, user-specified parameters are given to the <code>new</code> operator, notably to set up the instance initial state, i.e. its attributes. These parameters must be declared thanks to the <code>wooper_construct_parameters</code> define. For example, <code>-define( wooper_construct_parameters,).</code> (no parameter needed), or <code>-define( wooper_construct_parameters, Age, Gender ).</code> (two parameters needed).
</p>

<p>
The WOOPER-defined <code>new</code> operator automatically transmits these parameters to the <code>construct</code> method.
</p>

<p>
Based on the <code>wooper_construct_parameters</code> define (let us suppose n constructor parameters are listed in it), <code>new</code> and <code>construct</code> must be declared thanks to: <code>-define( wooper_construct_export, new/n, construct/n+1).</code>. <code>construct</code> takes one additional parameter, the instance state.
</p>

<p>
For example, if <code>-define( wooper_construct_parameters, Age, Gender ).</code> is declared, <code>-define( wooper_construct_export, new/2, construct/3 ).</code> should then be specified, and the corresponding method will be: <code>construct(State,?wooper_construct_parameters) -&gt; [..]</code>. If there is no construction-related parameter, then the method becomes: <code>construct(State) -&gt; [..]</code>. The <code>new</code> operator is always defined automatically by WOOPER, nothing is to be done for it.
</p>


<h5>Definition of the <code>construct</code> method</h5>

<p>
The <code>construct</code> methods are expected to be chained: they must be designed to be called by the ones of child classes, and they must call themselves the constructors of their mother classes, if any. Hence they always take the current state of the instance being created as a starting base, and returns it once updated, first from the direct mother classes, then by this class itself.
</p>

<p>
For example, <code>class_Cat</code> inherits directly from <code>class_Mammal</code> and <code>class_ViviparousBeing</code>, and has only one attribute (<code>whisker_color)</code> on its own:
<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
[..]
-define(wooper_superclasses,[class_Mammal,class_ViviparousBeing]).
[..]
-define(wooper_construct_parameters,Age,Gender,FurColor,WhiskerColor).
[..]
-define(wooper_construct_export,new/4,construct/5).
[..]
% Constructs a new Cat.
construct(State,?wooper_construct_parameters) -&gt;

	% First the direct mother classes:
	MammalState = class_Mammal:construct( State, Age, Gender, FurColor ),
	ViviparousMammalState = class_ViviparousBeing:construct( MammalState ),
	
	% Then the class-specific attributes:
	?setAttribute( ViviparousMammalState, whisker_color, WhiskerColor ).

</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>

</p>

<p>
The fact that the <code>Mammal</code> class itself inherits from the <code>Creature</code> class must not appear here: it is to be managed directly by <code>class_Mammal:construct</code> (only direct classes must be taken into account in a given inheritance level).
</p>

<p>
One should ensure that, in constructors, the successive states are always built from the last updated one:

<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
% WRONG, the age update is lost:
construct(State,Age,Gender) -&gt;
	AgeState = setAttribute(State,age,Age),
	setAttribute(<u>State</u>,gender,Gender),
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>


<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
% RIGHT:
construct(State,Age,Gender) -&gt;
	AgeState = setAttribute(State,age,Age),
	setAttribute(<u>AgeState</u>,gender,Gender),
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>

</p>


<h4>Instance deletion: delete</h4>

<p>
The <code>delete</code> operator can be omitted, in this case a default do-nothing destructor is used, and the instance is stopped and garbage-collected. 
If a specific action must be performed on deletion, potentially-chained destructors can be defined:
<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
% Overriding default destructor:	
% State should be returned, and destructors should be called in leaf-to-root
% order in inheritance tree.
delete(State) -&gt;
	% Perform here class-specific action (ex: socket or file explicit closing).
	LocalDelState = my_action( State ),
	% Then if needed call the mother class counterparts:
	OneDelState = class_MotherOne:delete( LocalDelState ),
	TwoDelState = class_MotherTwo:delete( OneDelState ),
	% Finally return the state to allow child classes to chain:
	TwoDelState.
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>

</p>


<br><p><center>[<a href="#usagetoc">Back to the usage table of contents</a>]</center></p><br>



<a name="misc"></a>
<h3>Misceallenous technical points</h3>


<p>
All WOOPER classes must include <a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/src/wooper.hrl?view=markup" target="_blank">wooper.hrl</a>: <code>-include("wooper.hrl").</code>. To help declaring the right defines in the right order, using the WOOPER <a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_Template.erl?view=markup" target="_blank">template</a> is recommended.
</p>

<p>
One should have <code>utils.beam</code>, <code>hashtable.beam</code> and <code>wooper_class_manager.beam</code> available to the interpreter before using WOOPER-based classes.
</p>

<p>
On UNIX-like platforms, using the Makefiles included with WOOPER archive is recommended. One just has to go at the root of the sources (from an extracted archive, you are expected to be in the <code>wooper-x.y</code> root directory) and simply run: <code>make</code> (assuming GNU make is available, so that the WOOPER <code>GNUmakefile</code> is used).
</p>

<p>
On other platforms, these modules must be compiled one way or another before using WOOPER, for example: 
<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
1> c(hashtable).
{ok,hashtable}
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
</p>

<p>
Finally, WOOPER is in some ways adding features very similar to the ones of Python (simple multiple inheritance, implied <code>self/State</code> parameter, attribute dictionaries, etc.; with less syntatic sugar available though) while still offering the major strengths of Erlang (concurrency, distribution, functional paradigm) and not hurting too much overall performances (mainly thanks to the prebuilt attribute and method hashtables).
</p>


<br><p><center>[<a href="#maintoc">Back to the table of contents</a>]</center></p><br>


<!-- #####################################################################" -->




<a name="example"></a>
<h2>WOOPER example</h2>

<p>
We created a small set of classes allowing to show multiple inheritance:

<center>
    <a href="wooper-example.png" target="_blank"><img src="wooper-example.png" alt="WOOPER example" width="95%"></img></a><br>
(click to enlarge)
</center>
</p>


<h3>Class implementations</h3>
<ul>

    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_Creature.erl?view=markup" target="_blank">class_Creature.erl</a></li>
    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_ViviparousBeing.erl?view=markup" target="_blank">class_ViviparousBeing.erl</a></li>
    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_OvoviviparousBeing.erl?view=markup" target="_blank">class_OvoviviparousBeing.erl</a></li>
    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_Mammal.erl?view=markup" target="_blank">class_Mammal.erl</a></li>
    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_Reptile.erl?view=markup" target="_blank">class_Reptile.erl</a></li>
    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_Cat.erl?view=markup" target="_blank">class_Cat.erl</a></li>
    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_Platypus.erl?view=markup" target="_blank">class_Platypus.erl</a></li>
	
</ul>


<h3>Tests</h3>
<ul>

    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_Creature_test.erl?view=markup" target="_blank">class_Creature_test.erl</a></li>
    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_ViviparousBeing_test.erl?view=markup" target="_blank">class_ViviparousBeing_test.erl</a></li>
    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_OvoviviparousBeing_test.erl?view=markup" target="_blank">class_OvoviviparousBeing_test.erl</a></li>
    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_Mammal_test.erl?view=markup" target="_blank">class_Mammal_test.erl</a></li>
    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_Reptile_test.erl?view=markup" target="_blank">class_Reptile_test.erl</a></li>
    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_Cat_test.erl?view=markup" target="_blank">class_Cat_test.erl</a></li>
    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_Platypus_test.erl?view=markup" target="_blank">class_Platypus_test.erl</a></li>
	
</ul>


<p><center>[<a href="#maintoc">Back to the table of contents</a>]</center></p><br>



<!-- #####################################################################" -->


<a name="current"></a>
<h2>Current stable version &amp; download</h2>

<h3>Using stable release archive</h3>
<p>
WOOPER 0.1 is ready to be used and can be downloaded <a href="http://sourceforge.net/project/showfiles.php?group_id=158516&package_id=239574" target="_blank">here</a>. Either a .zip or a .tar.bz2 can be retrieved. Starting from the 0.1 version, WOOPER should be fully functional (pun intended!). 
</p>

<p>
One way of building all of Wooper (base files and examples) is, from UNIX or on Windows from a Cygwin or MSYS shell, once the archive is downloaded and extracted, to execute <code>make all</code> from the WOOPER directory. For example:

<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
tar xvjf wooper-x.y.tar.bz2 && cd wooper-x.y && make all
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
It will build and run all, including the various WOOPER test suites.
</p>


<h3>Using cutting-edge SVN</h3>

<p>
A SVN (anonymous) check-out of WOOPER code can be obtained thanks to, for example:
<center>
    <table summary="a box" style="border: none">
        <tr>
          <td>
            <div class="box">
svn co https://ceylan.svn.sourceforge.net/svnroot/ceylan/Ceylan/trunk/src/code/scripts/erlang Wooper-code-checkout 
            </div>
          </td>
        </tr>
    </table>
</center>
</p>

<p>
Ceylan developers should used their Sourceforge user name so that they can commit changes:
<center>
    <table summary="a box" style="border: none">
        <tr>
          <td>
            <div class="box">
svn co --username YourSFUserName https://ceylan.svn.sourceforge.net/svnroot/ceylan/Ceylan/trunk/src/code/scripts/erlang Wooper-code-checkout 
            </div>
          </td>
        </tr>
    </table>
</center>
</p>

<p>
Check-out of WOOPER documentation can be performed thanks to:
<center>
    <table summary="a box" style="border: none">
        <tr>
          <td>
            <div class="box">
svn co https://ceylan.svn.sourceforge.net/svnroot/ceylan/Ceylan/trunk/src/doc/web/main/documentation/wooper Wooper-doc-checkout
            </div>
          </td>
        </tr>
    </table>
</center>

</p>

<p><center>[<a href="#maintoc">Back to the table of contents</a>]</center></p><br>

<!-- #####################################################################" -->



<a name="versions"></a>
<h2>Version history &amp; changes</h2>

<!--
<a name="version_X_Y"
<h3>Version </h3>
<p>
Not released yet (work-in-progress, only available on SVN). Major changes are:
<ul>
	<li></li>
</ul>

</p>
-->


<a name="version_0_1"></a>
<h3>Version 0.1</h3>
<p>
Released on Sunday, July 22, 2007. Already fully functional!
</p>


<a name="version_0_2"></a>
<h3>Version 0.2</h3>
<p>
Not released yet (work-in-progress, only available on SVN). Major changes are:
<ul>
	<li>the sender PID is made available to requests in the instance state variable (see <code>request_sender</code> member)</li>
	<li>fixed a potential race condition when two clients request nearly at the same time the WOOPER class manager (previous mechanism worked, class manager was a singleton indeed, but second client was not notified)</li>
	<li>improved build (Emakefile generated), comments, error output</li>
	<li>test template added</li>
	<li>documentation updated</li>
</ul>

</p>

<p><center>[<a href="#maintoc">Back to the table of contents</a>]</center></p><br>

<!-- #####################################################################" -->




<a name="inner"></a>
<h2>WOOPER inner workings</h2>

<p>
Each instance runs a main loop (<code>wooper_main_loop</code>, defined in <code>wooper.hrl</code>) that keeps its internal state and through a <code>receive</code> serves the methods specified by incoming messages.
</p>

<p>
The kept state is twofold:
<ul>
	<li><p>a <b>method virtual table</b>: this per-class hashtable is built at runtime, on the first creation of an instance of this class, and stored by the unique (singleton) Wooper class manager that shares it to all the class instances. This manager is itself spawned the first time it is needed, and stays ready for all instances of various classes being created (it uses a hashtable to associate to each class its specific virtual table).</p>
	
	<p>This per-class method table has for keys the known method names (atoms) for this class, associated to the values being the most specialized module, in inheritance tree, that defines that method. Hence each instance has a reference to a shared hashtable that allows for a direct method look-up. As the table is built only once and is shared by all instances, it adds very little overhead, space-wise and time-wise. Thanks to the hashtable, method look-up is efficient too
	</p>
	</li>
	
	<li>an <b>attribute table</b>: another hashtable, this time per-instance. Keys are attribute names, values are attributes values. It allows a seamless yet not too slow access to all data members, including inherited ones</li>
</ul>
</p>


<p>
WOOPER relies only on these specific files:
<ul>

<!--
    <li><a href="" target="_blank"></a></li>
-->

    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/src/wooper.hrl?view=markup" target="_blank">wooper.hrl</a>: the WOOPER core, which gives modules using it all the OOP constructs discussed</li>
    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/src/wooper_class_manager.hrl?view=markup" target="_blank">wooper_class_manager.hrl</a>: the (very short) class manager header</li>
    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/src/wooper_class_manager.hrl?view=markup" target="_blank">wooper_class_manager.erl</a>: the class manager itself, the unique process that is automatically spawned to share virtual tables among instances</li>
    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/common/hashtable.erl?view=markup" target="_blank">hashtable.erl</a>: efficient associative table used by WOOPER for virtual tables, methods, attributes</li>
    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/common/utils.erl?view=markup" target="_blank">utils.erl</a>: a small module used by the hashtable and other modules</li>
</ul>
</p>


<p><center>[<a href="#maintoc">Back to the table of contents</a>]</center></p><br>

<!-- #####################################################################" -->





<a name="next"></a>
<h2>Issues &amp; planned enhancements</h2>
 
<p>
<ul>

<!--
	<li><b></b>: </li>
-->

	<li>Is <b>wooper_main_loop</b> (in <code>wooper.hrl</code>) really tail-recursive ?</li>
	<li>Integrate automatic <b>persistant storage</b> of instance states into Mnesia databases</li>
	<li>Would there be a <b>more efficient</b> implementation of hashtables ? (ex: ets-based). More generally speaking, some profiling could be done to further increase overall performances</li>
	
</ul>

</p>

<p><center>[<a href="#maintoc">Back to the table of contents</a>]</center></p><br>



<!-- #####################################################################" -->


<a name="license"></a>
<h2>License</h2>
<p>
WOOPER is licensed by its author (Olivier Boudeville) under a disjunctive tri-license giving you the choice of one of the three following sets of free software/open source licensing terms:
<ul>

<!--
    <li><a href="" target="_blank"></a></li>
-->

    <li><a href="http://www.mozilla.org/MPL/MPL-1.1.html" target="_blank">Mozilla Public License</a> (MPL), version 1.1 or later (very close to the <a href="http://www.erlang.org/EPLICENSE" target="_blank">Erlang Public License</a>, except aspects regarding Ericsson and/or the Swedish law)</li>
    <li><a href="http://www.gnu.org/licenses/gpl-2.0.html" target="_blank">GNU General Public License</a> (GPL), version 2.0 or later</li>
    <li><a href="" target="_blank">GNU Lesser General Public License</a> (LGPL), version 2.1 or later</li>
</ul>
</p>

<p>
This allows the use of the WOOPER code in as wide a variety of software projects as possible, while still maintaining copyleft on this code. Being triple-licensed means that someone (the licensee) who modifies and/or distributes it can choose which of the available sets of license terms he is operating under. Enhancements are expected to be back-contributed, so that everyone can benefit from them.
</p>

<p><center>[<a href="#maintoc">Back to the table of contents</a>]</center></p><br>


<!-- #####################################################################" -->

<a name="sources"></a>
<h2>Sources, inpirations &amp; alternate solutions</h2>

<p>

<ul>
<!--
    <li><a href="" target="_blank"></a></li>
-->
	
    <li><b>Concurrent Programming in Erlang</b>, Joe Armstrong, Robert Virding, Claes Wikstrm et Mike Williams. Chapter 18, page 299: Object-oriented Programming. This book describes a simple way of implementing multiple inheritance, without virtual table, at the expense of a (problably slow) systematic method look-up (at each method call). No specific state management is supported</li>

    <li>Chris Rathman 's <a href="http://www.angelfire.com/tx4/cus/shapes/erlang.html" target="_blank">approach</a> to life cycle management and polymorphism. Inheritance not supported</li> 
	
    <li>
	As Burkhard Neppert suggested, an alternative way of implementing OOP here could be to use Erlang behaviours. This is the way OTP handles generic functionalities that can be specialized (e.g. <code>gen_server</code>). One approach could be to map each objet-oriented base class to an Erlang <b>behaviour</b>. See some guidelines about <a href="http://wiki.trapexit.org/index.php/Defining_Your_Own_Behaviour" target="_blank">defining</a> your own behaviours and making them <a href="http://wiki.trapexit.org/index.php/Cascading_Behaviours" target="_blank">cascade</a>
	</li>

    <li>
	
		<p>As mentioned by Niclas Eklund, despite quite different operating modes, WOOPER and <a href="http://www1.erlang.org/doc/apps/orber/index.html" target="_blank">Orber</a>, an Erlang implementation of a <b>CORBA ORB</b>
 (<em>Object Request Broker</em>) offer similar OOP features, as CORBA IDL implies an object-oriented approach (see their <a href="http://www.erlang.org/doc/apps/orber/ch_idl_to_erlang_mapping.html#6" target="_blank">OMG IDL to Erlang Mapping</a>).
		</p>

		<p>WOOPER and Orber are rather different beasts though: WOOPER is very lightweight (less than 1000 lines, including blank lines and numerous comments), does not involve a specific (IDL) compiler generating several stub/skeleton Erlang files, nor depends on OTP or Mnesia, whereas Orber offers a full CORBA implementation, including IDL language mapping, CosNaming, IIOP, Interface Repository, etc.
		</p>

		<p>Since Orber respects the OMG standard, integrating a new language (C/C++, Java, Smalltalk, Ada, Lisp, Python etc.) should be rather easy. On the other hand, if a full-blown CORBA-compliant middleware is not needed, if simplicity and ease of understanding is a key point, then WOOPER could be preferred. If unsure, give a try to both!
		</p>

		<p>
 See also another IDL-based approach (otherwise not connected to CORBA), the <a href="http://www.erlang.org/doc/apps/ic/ch_erl_genserv.html#5" target="_blank">Generic Server Back-end</a> (wrapper around <code>gen_server</code>).
		</p>

	</li>


</ul>

</p>

<p>
The WOOPER name is also a tribute to the underestimated <a href="http://en.wikipedia.org/wiki/WarGames" target="_blank">Wargames</a> movie (remember the <a href="http://en.wikipedia.org/wiki/WOPR" target="_blank">WOPR</a>, the NORAD central computer ?), which the author enjoyed a lot. It is as well a second-order tribute to the <em>Double Wooper King Size</em> (<em>Whopper</em> in most if not all countries), which is/was a great hamburger indeed (in France, they are not available anymore).
</p>

<p><center>[<a href="#maintoc">Back to the table of contents</a>]</center></p><br>


<!-- #####################################################################" -->


<a name="support"></a>
<h2>Support</h2>
<p>
Bugs, questions, remarks, patches, requests for enhancements, etc. are to be sent to the <a href="mailto:ceylan-wooperNOSPAM@lists.sourceforge.net" target="_blank">ceylan-wooper at lists dot sourceforge dot net</a>. One must <a href="https://lists.sourceforge.net/lists/listinfo/ceylan-wooper" target="_blank">register</a> first.
</p>

<p><center>[<a href="#maintoc">Back to the table of contents</a>]</center></p><br>

<!-- #####################################################################" -->

<a name="developers"></a>
<h2>For WOOPER developers</h2>
<p>
When a new WOOPER version is released, tag the corresponding file versions like in:
<center>
    <table summary="a box" style="border : none">
        <tr>
          <td>
            <div class="box">
svn copy https://ceylan.svn.sourceforge.net/svnroot/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper https://ceylan.svn.sourceforge.net/svnroot/ceylan/Ceylan/tags/wooper-release-0.1 -m "First release (0.1) of WOOPER, already fully functional."

            </div>
          </td>
        </tr>
    </table>
</center>
</p>

<p><center>[<a href="#maintoc">Back to the table of contents</a>]</center></p><br>

<!-- #####################################################################" -->

  <br>
  <br>

  <h3>Please react !</h3>

  <p>If you have information more detailed or more recent than those
  presented in this document, if you noticed errors, neglects or points
  insufficiently discussed, <a href=
  "mailto:olivier.boudeville@online.fr?subject=[Ceylan]%20WOOPER">
  drop us a line</a> !</p><br>
  <br>
  <hr>

  <center>
    [<a href="#_top_">Top</a>]<br>
    <br>
    <em>Last update: Sunday, September 2, 2007</em>
  </center>
</body>
</html>
