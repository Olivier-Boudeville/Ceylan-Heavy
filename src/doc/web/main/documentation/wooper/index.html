<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/REC-html40/loose.dtd">
<!--    This document is a part of the Ceylan project. 
        For any comment, please mail to olivier.boudeville@online.fr
-->
<!--    
        Creation date: Saturday, July 7, 2007.
        Author: Olivier Boudeville (olivier.boudeville@online.fr)
        Update made by:  the author
        Version number: 0.1
-->

<html lang="EN">
<head>
  <title>Ceylan - WOOPER documentation</title>
  <meta http-equiv="Content-Type" content=
  "text/html; charset=iso-8859-1">
  <meta name="description" content="Ceylan">
  <meta name="keywords" content="Ceylan, generic, GPL">
  <link href="../../../images/Ceylan-icon.png" rel="Ceylan icon">
  <link rel="STYLESHEET" type="text/css" href="../../../common/css/Ceylan.css">
</head>

<body>
  <div class="banner">
    <p><em>General</em> <a href="../../../common/black.html" onclick= 
    "parent.toolbar.location='../../MainMenu.html'">home page</a>
    <a href="../../Map.html">site map</a> <a href=
    "mailto:olivier.boudeville@online.fr?subject=[Ceylan]%20WOOPER">
    mail us</a></p>
  </div><a name="_top_"></a></span> 



<h1>WOOPER: <em>Wrapper for OOP in Erlang</em></h1>

<p>
WOOPER is an <a href="#license">open source</a> lightweight layer on top of the <a href="http://erlang.org" target="_blank">Erlang</a> language offering constructs dedicated to <a href="http://en.wikipedia.org/wiki/Object-oriented_programming" target="_blank">Object-Oriented Programming</a>. WOOPER is a (completely autonomous) part of the <a href="http://ceylan.sourceforge.net" target="_blank">Ceylan</a> project.
</p>


<p>
<a name="maintoc"></a>
<center><br>
        <table summary="Table of contents" style="border: none">
        <tr>
          <td>
<!--
                       <a href="#"></a><br>
-->

					<div class="box">
                       <a href="#overview">Overview</a><br>
                       <a href="#why">Why adding OOP to Erlang ?</a><br>
                       <a href="#how">How to use WOOPER ?</a><br>
                       <a href="#example">WOOPER example</a><br>
                       <a href="#troubleshooting">Troubleshooting</a><br>
                       <a href="#current">Current stable version &amp; download</a><br>
                       <a href="#versions">Version history &amp; changes</a><br>
                       <a href="#inner">Inner workings</a><br>
                       <a href="#next">Issues &amp; planned enhancements</a><br>
                       <a href="#license">License</a><br>
                       <a href="#sources">Sources, inpirations &amp; alternate solutions</a><br>
                       <a href="#support">Support</a><br>
                       <a href="#developers">For WOOPER developers</a>
					</div>

          </td>
        </tr>
      </table>
</center>
</p>

<!--
<br><p><center>[<a href="#maintoc">Back to the table of contents</a>]</center></p><br>
-->

<!-- #####################################################################" -->



<a name="overview"></a>
<h2>Overview</h2>

<p>
Some problems may almost only be tackled efficiently thanks to an object-oriented modeling. The set of code and conventions proposed here allows to have all the main OOP features (including polymorphism, life cycle management, state management and multiple inheritance) available from Erlang, so that an object-oriented approach at the implementation level can be easily achieved, for the cases where it makes sense.
</p>

<p>
Here is a simple example of how WOOPER instances can be managed. This shows <code>new/delete</code> operators, method calling (both request and oneway), and inheritance (a cat is here a viviparous mammal, as defined <a href="#example">below</a>):
<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
Eshell V5.5.2  (abort with ^G)
1&gt; Age=2,Gender=male,FurColor=sand,WhiskerColor=white.
white
2&gt; MyCat=class_Cat:new(Age,Gender,FurColor,WhiskerColor).
<0.33.0&gt;
3&gt; MyCat ! {canEat,tangerine,self()}, receive {wooper_result,R1} -&gt; R1 end.
false
4&gt; MyCat ! {canEat,meat,self()}, receive {wooper_result,R2} -&gt; R2 end.
true
5&gt; MyCat ! {getWhiskerColor,[],self()}, receive {wooper_result,R3} -&gt; R3 end.
white
6&gt; MyCat ! {getAge,[],self()}, receive {wooper_result,R4} -&gt; R4 end.
2
7&gt; MyCat ! {setAge,5}.
{setAge,5}
8&gt; MyCat ! {getAge,[],self()}, receive {wooper_result,R5} -&gt; R5 end.
5
9&gt; MyCat ! delete.
Destructing a Mammal (overriden destructor).
deleted

</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
</p>

<p>
This class <code>class_Cat</code> is itself defined this way:
<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
-module(class_Cat).


% Determines what are the mother classes of this class (if any):
-define(wooper_superclasses,[class_Mammal,class_ViviparousBeing]).


% Parameters taken by the constructor ('construct'). 
% They are here the ones of the Mammal mother class (the viviparous being 
% constructor does not need any parameter) plus whisker color.
% These are class-specific data needing to be set in the constructor:
-define(wooper_construct_parameters,Age,Gender,FurColor,WhiskerColor).

% Construction-related exported operators:
-define(wooper_construct_export,new/4,new_link/4,
	synchronous_new/4,synchronous_new_link/4,construct/5).

% Method declarations.
-define(wooper_method_export,getTeatCount/1,canEat/2,getWhiskerColor/1).

% Allows to define WOOPER base variables and methods for that class:
-include("wooper.hrl").


% Constructs a new Cat.
construct(State,?wooper_construct_parameters) -&gt;

	% First the direct mother classes:
	MammalState = class_Mammal:construct( State, Age, Gender, FurColor ),
	ViviparousMammalState = class_ViviparousBeing:construct( MammalState ),
	
	% Then the class-specific attributes:
	?setAttribute( ViviparousMammalState, whisker_color, WhiskerColor ).
	

% No guarantee of biological fidelity:	
getTeatCount(State) -&gt;
	?wooper_return_state_result( State, 6 ).

	
% Cats are supposed carnivorous though:
canEat(State,soup) -&gt;	
	?wooper_return_state_result( State, true );
	
canEat(State,chocolate) -&gt;	
	?wooper_return_state_result( State, true );
	
canEat(State,croquette) -&gt;	
	?wooper_return_state_result( State, true );

canEat(State,meat) -&gt;	
	?wooper_return_state_result( State, true );

canEat(State,_) -&gt;
	?wooper_return_state_result( State, false ).


getWhiskerColor(State)-&gt;
	?wooper_return_state_result( State, ?getAttr(whisker_color) ).
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
Straightforward, isn't it ? We will discuss it in-depth though.
</p>

<br><p><center>[<a href="#maintoc">Back to the table of contents</a>]</center></p><br>

<!-- #####################################################################" -->




<a name="why"></a>
<h2>Why adding Object-oriented elements to Erlang ?</h2>

<p>
Although applying blindly OOP with languages based on other paragdims (Erlang ones are functional and concurrent, it is not specifically targeting OOP) is a common mistake, there are some problems that may be deemed inherently "object-oriented", i.e. that cannot be effectively modelled without encapsulated abstractions sharing behaviours. 
</p>

<p>
Examples of this kind of systems are multi-agent simulations. If they often need massive concurrency, robustness, distribution, etc. (Erlang is particularly suited for that), the various actor types have also often to share numerous states and behaviours, while being able to specialize them on a per-type basis.
</p>

<p>
The <a href="#example">example</a> chosen here is a simulation of the interacting lives of numerous animals from various species. Obviously, they have to share behaviours (ex: all ovoviviparous beings may lay eggs, all creatures can live and die, all have an age, etc.), which cannot be mapped easily (read: automatically) to Erlang concepts without some generic constructs being added.
</p>

<p>
WOOPER, which stands for <em>Wrapper for OOP in Erlang</em>, is a lightweight yet effective (performance-wise, but also regarding developing efforts) means of making these constructs available, notably with regard to state management and multiple inheritance. The same simulations could be achieved without such OOP constructs, but at the expense of way too much manually-crafted specific (per-class) code. This process would be tedious, error-prone, and the result most often could be hardly maintained. 
</p>

<p><center>[<a href="#maintoc">Back to the main table of contents</a>]</center></p>


<!-- #####################################################################" -->


<br>

<a name="how"></a>
<h2>How to use WOOPER ?<br>Detailed description &amp; concept mappings</h2>


<a name="usagetoc"></a>
<center>
	<table summary="Usage table of contents" style="border: none">
        <tr>
          <td>
<!--
		       <a href="#"></a><br>
-->

			<div class="box">
		       <a href="#classes">Classes</a><br>
		       <a href="#instances">Instances</a><br>
		       <a href="#methods">Methods</a><br>
		       <a href="#statemanagement">State management</a><br>
		       <a href="#inheritpolymorph">Multiple inheritance &amp; polymorphism</a><br>
		       <a href="#lifecycle">Life cycle</a><br>
		       <a href="#misc">Misceallenous technical points</a>
			</div>

          </td>
        </tr>
      </table>
	  (<a href="#maintoc">Up to the main table of contents</a>)
</center>


<!--
<br><p><center>[<a href="#usagetoc">Back to the usage table of contents</a>]</center></p><br>
-->

<a name="classes"></a>
<h3>Classes</h3>


<h4>Class &amp; names</h4>
<p>
A class is a common scheme describing the behaviour and the internal data of its instances. With WOOPER each class must have a unique name.
</p>

<p>
To allow for <b>encapsulation</b>, here a class is mapped to an Erlang module, whose name is made from the <code>class_</code> prefix followed by the class name, all in lowercase but the first letter. For example, a class modeling a cat should translate into an Erlang module named <code>class_Cat</code>, thus in a file named <code>class_Cat.erl</code>. At the top of this file, the corresponding module would be therefore declared with: <code>-module(class_Cat).</code>.
</p>

<p>
The class name can be obtained through its <code>get_class_name</code> WOOPER-defined static method:

<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
&gt; class_Cat:get_class_name().
class_Cat
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
</p>


<h4>Inheritance &amp; superclasses</h4>
<p>
A WOOPER class can inherit from other classes, in this case the behaviour and the internal data of the mother classes are available by default to this child class. 
</p>

<p>
Being in a <b>multiple inheritance</b> context, a given class can have any number ([0..n]) of direct mother classes (which themselves may have mother classes, and so on). This is declared in WOOPER thanks to the <code>wooper_superclasses</code> define. For example, a class with no mother class should have, once its module is declared, <code>-define(wooper_superclasses,[]).</code>.
</p>

<p>
As for our cat, this animal could be modelled both as a mammal (itself a specialized creature) and a viviparous being (neither of them is a subset of the other, these are mostly unrelated concepts; at least for that example !). Hence its mother classes could be described as: <code>-define(wooper_superclasses,[class_Mammal, class_ViviparousBeing]).</code>
</p>


<p>
The superclasses (direct mother classes) of a given class can be retrieved thanks to its <code>get_superclasses</code> static method:

<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
&gt; class_Cat:get_superclasses().
[class_Mammal,class_ViviparousBeing]
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
</p>

<br><p><center>[<a href="#usagetoc">Back to the usage table of contents</a>]</center></p><br>



<a name="instances"></a>
<h3>Instances</h3>


<h4>Instance mapping</h4>
<p>
With WOOPER, which focuses on multi-agent systems, all <b>instances</b> of a class are mapped to Erlang processes (one instance, one process). They are therefore, in UML language, <em>active objects</em> (each has its own thread of execution, they apparently "live" simultaneously).
</p>


<h4>Instance state</h4>
<p>
Another part of encapsulation is <b>state management</b>: each instance should be stateful, and able to inherit the data members defined by its mother classes. In WOOPER, this is obtained thanks to a per-instance associative table, where keys are the name of attributes and values are their value. This will be detailed in the <a href="#statemanagement">state management</a> section.
</p>

<br><p><center>[<a href="#usagetoc">Back to the usage table of contents</a>]</center></p><br>



<a name="methods"></a>
<h3>Methods</h3>
<p>
Instances may offer <b>methods</b> that can be publicly called, including remotely (RMI: <em>Remote Method Invocation</em>). Methods (either inherited or defined directly in the class) are mapped to specific Erlang functions, triggered by messages. For example, our cat may define following methods:
<ul>

<!--
	<li></li>
-->
	<li><code>canEat</code>, taking one parameter describing the type of food, and returning whether the cat can eat that kind of food or not. The implementation should be cat-specific here, whereas the method signature is shared by all beings</li>
	
	<li><code>getWhiskersColor</code>, taking no parameter, returning the color of its whiskers. This is indeed cat-specific</li>
	
	<li>
		<p><code>declareBirthday</code>, incrementing the age of our cat, not taking any parameter nor returning anything. This will be therefore be implemented as a one-way call (i.e. not returning any result to the caller, hence not needing to know it), only interesting for its effect on the cat state: making it one year older.
		</p>	
		<p>Declaring a birthday is not cat-specific, nor mammal-specific: we can consider it being creature-specific. Cat instances should then inherit this method, preferably indirectly from the <code>class_Creature</code> class, in all cases without having to specify anything, since the <code>wooper_superclasses</code> define already implies that relationship</p>
	</li>

</ul>
</p>

<p>
 We will discuss the definition of these methods later, but for the moment let's determine their signatures and declarations, and how we are expected to call them.
</p>


<h4>Method declaration</h4>

<p>
The cat-specific methods are to be declared, in the <code>class_Cat</code>, thanks to the <code>wooper_method_export</code> clause. Their arity should be equal to the number of parameters they should be called with, plus one.
</p>

<p>
The additional parameter is an implicit one (automatically managed by WOOPER), corresponding to the state of the instance. This <code>State</code>
 variable defined by WOOPER can be somehow compared to the '<code>self</code>' parameter of Python, or to the '<code>this</code>' pointer of C++. That state is automatically kept by WOOPER classes in their main loop, and automatically prepended to the parameters of incoming method calls.
</p>

<p>
In our example, it would result in: <code>-define(wooper_method_export,canEat/2,getWhiskersColor/1).</code> (as <code>declareBirthday</code> will be inherited but not overriden, no need to declare it).
</p>


<p>
Some method names are reserved by WOOPER: no user method should have a name starting by <code>wooper</code>. Other names have a special meaning, notably <code>onWooperExitReceived</code>, discussed later.
</p>


<h4>Method invocation</h4>
<p> 
If MyCat is an instance of <code>class_Cat</code>, these methods (either defined locally or inherited) should be called thanks to a dedicated tuple:
<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
MyCat ! {canEat,soup,self()},
receive

	{wooper_result,true} -&gt;
		io:format( "This cat likes soup !!!" );

	{wooper_result,false} -&gt;
		io:format( "This cat does not seem omnivorous." )
		
end,

MyCat ! {getWhiskersColor,[],self()},
receive
		
	{wooper_result,white} -&gt;
		io:format( "This cat has normal whiskers." );
		
	{wooper_result,blue} -&gt;
		io:format( "What a weird cat..." )

end,

MyCat ! declareBirthday,	
end.	
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
</p>


<h5>Method name</h5>

<p>
Some information must be given here: methods are designated by their atom name (as declared in the <code>wooper_method_export</code> clause of the class in the inheritance tree that define them), which is always the first information given in the method call tuple.
</p>



<h5>Method parameters</h5>
<p>
As detailed below, there are requests (that return a result) and one-way calls (that change only the state of the instance, no reply sent back). Both can take any number of parameters, including none. <b>Marshalling</b> of parameters (and return values) is performed automatically by Erlang.  
</p>

<p>
Parameters are to be specified in a (possibly empty) list, as second element of the call tuple. If only one parameter is needed, the list can be omitted, and the parameter can be directly specified: <code>Me ! {setAge,30}.</code>
 works as well as <code>Me ! {setAge,[30]}.</code>.
</p>


<h5>Two kinds of methods</h5>

<h6>Request Methods</h6>

<p>To send an answer to a request from a caller, the instance needs to know the caller PID.
</p>

<p>Therefore <b>requests</b> have to specify, as the third element of the call tuple, an additional information: the PID to which the answer should be sent, almost always the caller (hence the <code>self()</code>). Finally these three potential information (method name, parameters, sender, i.e. an atom, usually a list and a PID) are gathered in a tuple sent as a message: <code>{method_name,[Arg1,Arg2,..],self()}</code>. For example: <code>MyCat ! {getAge,[],self()}</code> or <code>MyCalculator ! {sum,[1,2,4],self()}</code>.
</p>

<p>
<code>receive</code> should be used to retrieve the result, like in:

<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
MyPoint ! {getCoordinates,[],self()},
receive

	{wooper_result,[X,Y]} -&gt;
		[...];
	
	% Could be left out to ignore errors.
	% Otherwise one might prefer making this client crash:
	Error -&gt;
		[...]
		
end,
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
</p>


<h6>One-way Methods</h6>
<p>
<b>One-way methods</b> do not have to specify a sender PID, as no result is expected. If ever they sent one nevertheless, a warning will be sent back to them, the atom <code>wooper_method_returns_void</code> instead of <code>{wooper_result,Result}</code>.
</p>

<p>
Hence oneway methods should be called thanks to:
<ul>

	<li>2-element (i.e. with no PID specified) tuples: <code>{method_name,[Arg1,Arg2,..]}</code>, for example: <code>MyCat ! {setAge,5}</code> or <code>MyPoint ! {setCoordinates,[14,6]}</code></li>

	<li>or, if they do not take parameters, just the atom <code>method_name</code>, for example: <code>MyCat ! declareBirthday</code></li>

</ul>
</p>

<p>
No return should be expected (the instance does not even have the sender PID), so no receive should be attempted on the caller side. Due to their nature, if an error occurs instance-side during a oneway call, the caller will never be notified.
</p>

<p>
However, to help debugging, an error message is logged (using <code>error_logger:error_msg</code>) and the actual error message, the one that would be sent back to the caller if the method was a request, is given to <code>erlang:exit</code> instead.
</p>


<h5>Method results</h5>
<p>
If the method execution succeeded, and if it is a request (not a oneway), <code>{wooper_result,ActualResult}</code> will be sent back, otherwise one of the following error messages will be emitted:
<ul>

<!--
	<li><code></code>: </li>
-->

	<li>
		<p><b>wooper_method_not_found</b>, i.e. <code>{wooper_method_not_found, Pid, Module, MethodName, MethodArity, ListOfActualParameters}</code>: for example <code>{wooper_method_not_found, &lt;0.30.0&gt;, class_Cat, layEggs, 2, ...}</code>. <code>MethodArity</code> counts the implied state parameter. This error occurs whenever a called method could not be found in the whole inheritance graph. It means this method is not implemented, at least not with the deduced arity.
		</p>
		
		<p>More precisely, when a message <code>{method_name,[Arg1,Arg2,..,Argn]...}</code> (request or oneway) is received, <code>method_name/n+1</code> has be to called: WOOPER tries to find <code>method_name(State,Arg1,..,Argn)</code>, and method name and arity must match. If no method could be found, the <code>wooper_method_not_found</code> atom is returned, and the object state will not change, nor the instance will crash, as this error is deemed a client-side one
		</p>
	</li>

	<li>
		<p><b>wooper_method_failed</b>, i.e. <code>{wooper_method_failed, InstancePID, Module, MethodName, MethodArity, ListOfActualParameters, ErrorTerm}</code>: for example, <code>{wooper_method_failed, &lt;0.30.0&gt;, class_Cat, myCrashingMethod, 1, [], {{badmatch,create_bug}, [..]]}</code>. If the exit message sent by the method specifies a PID, it is prepended to ErrorTerm.
		</p>

		<p>Such a method error means there is a runtime failure, it is deemed a server-side issue, thus the instance process logs that error, sends an error term to the caller (if and only if it is a request), and then exits with the same error term
		</p>
	</li>

	<li><b>wooper_method_faulty_return</b>, i.e. <code>{wooper_method_faulty_return, InstancePID, Module, MethodName, MethodArity, ListOfActualParameters, ActualReturn}</code>: for example <code>{wooper_method_faulty_return, &lt;0.30.0&gt;, class_Cat, myFaultyMethod, 1, [], [{{state_holder,..]}</code>.

		<p>This error occurs when other errors did not match (catch-all). The main reason for its happening is when debug mode is set and when a method implementation did not respect the expected method return convention (neither <code>wooper_return_state_result</code> nor
<code>wooper_return_state_only</code> used). It means the method is not implemented correctly (it has a bug). This is a server-side failure, thus the instance process logs that error, sends an error term to the caller (if and only if it is a request), and then exits with the same error term
		</p>
	</li>
	
</ul>
</p>

<p>
So on the caller side, errors can be better discriminated if needed (but defensive development is not really favored in Erlang, one may let the caller crash on unexpected return instead):
<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
MyPoint ! {getCoordinates,[],self()},
receive

	{wooper_result, [X,Y] } -&gt;
		[...];
	
	{wooper_method_not_found, Pid, Module, Method, Arity, Parameters} -&gt;
		[...];

	{wooper_method_failed, Pid, Module, Method, Arity, Parameters, ErrorTerm} -&gt;
		[...];

	% Error term can be a tuple {Pid,Error} as well, depending on the exit:
	{wooper_method_failed, Pid, Module, Method, Arity, Parameters, {Pid,Error}} -&gt;
		[...];

	{wooper_method_faulty_return, Pid, Module, Method, Arity, Parameters, UnexpectedTerm} -&gt;
		[...];

	wooper_method_returns_void -&gt;
		[...];

	OtherError -&gt;
		% Should never happen:
		[...]
		
end,

</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
</p>


<h4>Method definition</h4>

<p>
Here we reverse the point of view: instead of calling a method, we are in the process of implementing a callable one.
</p>

<p>
A method signature has always for first parameter the state of the instance, for example: <code>getAge(State) -&gt; [..]</code>, or <code>getCoordinate(State,Number) -&gt; [..]</code>. For better clarity, this variable should be preferably named always <code>State</code>.
</p>

<p>
A method must always return at least the new instance state, even if the state did not change. In this case the state parameter is directly returned, as is:
<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
getWhiskerColor(State) -&gt;
	?wooper_return_state_result( State, ?getAttr(whisker_color) ).
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
State is unchanged here. 
</p>

<p>
Depending on its returning a specific result, the method signature will correspond either to:
<ul>
	<li>a <b>request</b>, and <code>?wooper_return_state_result(NewState,Result)</code> wil be used: the new state will be kept by the instance and the result will be sent to the client. Hence <code>wooper_return_state_result</code> means that the method returns a state <b>and</b> a result.  For example,
<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
getAge(State) -&gt;
	?wooper_return_state_result(State,?getAttr(age)).
	</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
All methods are of course given the parameters specified at their call. For example, for a cat having 2 male kitten and 3 female ones, we have:
<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
giveBirth(State,NumberOfMaleChildren,NumberOfFemaleChildren) -&gt; 
	[..]

MyCat ! {giveBirth,[2,3],self()}.
	</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
But requests can access to one more information than oneways: the PID of the client that sent the request. This can be done by using the <code>getSender</code> macro, which is automatically set by WOOPER:
<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
giveBirth(State,NumberOfMaleChildren,NumberOfFemaleChildren) -&gt; 
	ClientPID = ?getSender(),
	[..]
	</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>

<p>
Thus requests have access to their client PID without having to specify it twice, i.e. with no need to specify it in the parameters as well as in the third element of the call tuple: instead of
<code>MyCat ! {giveBirth,[2,3,self()],self()}.</code>, only <code>MyCat ! {giveBirth,[2,3],self()}.</code> can be sent, while letting the possibility for the called request (here <code>giveBirth/3</code>, for a state and two parameters) to access the client PID thanks to the <code>getSender</code> macro, and maybe store it (most probably in the state variable) for a later use.
</p>

<p>
The <code>getSender</code> macro should be used only for requests, as of course the sender PID has no meaning with oneways. The macro returns <code>undefined</code> in this case.
</p> </li>
 
	<li>a <b>oneway</b>, and <code>?wooper_return_state_only(NewState)</code> will be used: the instance state will be updated, and no result will be returned. For example,
<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
setAge(State,NewAge) -&gt;
	?wooper_return_state_only(?setAttribute(State,age,NewAge)).
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
Oneways may leave the state unchanged, only being called for side-effects, for example:
<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
displayAge(State) -&gt;
	io:format("My age is ~B~n.",[?getAttr(age)]),
	?wooper_return_state_only(State).
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>

</li>

</ul>
</p>

<p>
The two <code>wooper_return_state_*</code> macros are actually quite simple, they are just here to structure the method implementations (helping the method developer not mixing states and results), and to help ensuring, in debug mode, that methods are well-formed (an atom is then prepended to the returned tuple, and WOOPER matches it during post-invocation, before handling the return, for an increased safety). 
</p>


<h5>Auto-invocation</h5>

<p>
When writing a method of a class, one may want to call other methods <b>of that same class</b>, which are possibly overloaded.
</p>

<p>
For example, when developing a <code>declareBirthday</code> method of <code>class_Mammal</code> (which among other things increments the mammal age), you may want to perform a call to the <code>setAge</code> method of the current instance.
</p>

<p>
If you use just <code>setAge</code> or <code>class_Mammal:setAge</code>, you will never call the potentially overloaded versions from child classes: if an instance of child class <code>class_Cat</code> (which inherited  <code>declareBirthday</code> "as is") overloaded <code>setAge</code>, you may want that <code>declareBirthday</code> calls automatically <code>class_Cat:setAge</code> instead of <code>class_Mammal:setAge</code>.
</p>

<p>
This can be easily done asynchronously: just send a classical method call through a message, like in <code>self() ! {setAge,10}</code>. If this approach is useful when not needing the result of the call and/or not needing to have it executed at once, there are times when one wants to have that possibly overriden method executed directly and to access to the corresponding result.
</p>

<p>
For these cases, one should call <code>executeRequest</code> or <code>executeOneway</code>, depending of the type of the method to call.
These two helper functions behave quite similarly to actual method calls that use the operator <code>!</code>, except that no target instance has to be specified (since it is a call made by an instance to itself) and no message exchange is involved: the method look-up is just performed in the inheritance hierarchy, the correct method is called with the specified parameters and the result is then directly returned.
</p>

<p>
More precisely, <code>executeRequest</code> is <code>executeRequest/3</code> or <code>executeRequest/2</code>, its parameters being the current state, the name of the request-method, and, if specified, the parameters of the called request, either as a list or as a standalone one. It returns a triplet (3-tuple) made of the <code>wooper_result</code> atom, of the new state and of the result.
</p>

<p>
For example: 
<ul>

	<li><code>{wooper_result,NewState,Result} = executeRequest(CurrentState, my_request_name, [ "hello", 42 ])</code></li>
	
	<li><code>{wooper_result,NewState,Result} = executeRequest(CurrentState,another_request_name,42)</code></li>
	
	<li><code>{wooper_result,NewState,Result} = executeRequest(CurrentState,third_request_name)</code></li>

<!--
	<li><code></code></li>
-->

</ul>

</p>

<p>
<code>executeOneway</code> is either <code>executeOneway/3</code> or <code>executeOneway/2</code>, depending on whether the oneway takes parameters. If yes, they can be specified as a list (if there are more than one) or as a standalone parameter. A pair (2-tuple) is returned, made of the <code>wooper_result</code> atom and the new state.
</p>

<p>
For example:
<ul>

	<li><code>{wooper_result,NewState} = executeOneway(CurrentState,my_oneway_name,[ "hello", 42 ])</code></li>

	<li><code>{wooper_result,NewState,Result} = executeOneway(CurrentState,another_oneway_name,42)</code></li>

	<li><code>{wooper_result,NewState,Result} = executeOneway(CurrentState,another_oneway_name)</code></li>

<!--
	<li><code></code></li>
-->

</ul>

</p>

<p>
Both <code>executeRequest</code> and <code>executeOneway</code> specify <code>wooper_result</code> in the returned tuple, in order to have a better homogeneity in error handling.
</p>


<br><p><center>[<a href="#usagetoc">Back to the usage table of contents</a>]</center></p><br>




<a name="statemanagement"></a>
<h3>State management</h3>

<p>
We are dealing here with the encapsulated inner state of an instance, which is only directly accessible inside its dedicated module.
</p>

<p>
An instance state is defined by a set of attributes. Each attribute is designated by a name and has a mutable value.
</p>

<p>
As seen in various examples, most method implementations will access (read/write) to attributes stored in the instance state, whose original version (i.e. the state of the instance at method begin) is always specified as their first parameter. 
</p>


<h4>Modifying state</h4>

<p>
Setting an attribute (creating and/or modifying it) should be done with the <b>setAttribute</b> macro: <code>?setAttribute(AState,AttributeName,NewAttributeValue)</code>.
</p>

<p>
For example, <code>AgeState = ?setAttribute(State,age,3)</code> will return a new state, exact copy of <code>State</code> but for the attribute <code>age</code>, that will be set to 3, whether or not this attribute was already defined in <code>State</code>. 
</p>

<p>
In various cases, notably in constructors, one needs to define a series of attributes, and chaining <code>setAttribute</code> calls with intermediate states is not convenient. A better solution is to use the <b>setAttributes</b> macro (note the plural) to set a list of attribute name/attribute value pairs.
</p>

<p>
For example, <code>ConstructedState = ?setAttributes(State,[ {age,3}, {whisker_color,white} ])</code> will return a new state, exact copy of <code>State</code> but for the listed attributes, set to their respective specified value. 
</p>


<p>
An attribute may be removed, using the <b>removeAttribute</b> macro. For example: <code>NewState = ?removeAttribute(State,an_attribute)</code>.
</p>

<p>
Neither <code>setAttribute</code> nor <code>removeAttribute</code> can fail, even if the attribute to remove was not already existing.
</p>



<h4>Reading state</h4>

<p>
To test whether an attribute is defined, use the <b>hasAttribute</b> macro: <code>?hasAttribute(AState,AttributeName)</code>, which returns either true or false, and cannot fail.
</p>

<p>
For example, <code>true = ?hasAttribute(State,whisker_color)</code>
 matches if and if the attribute <code>whisker_color</code> is defined in state <code>State</code>.
</p>

<p>
Getting the value of an attribute should be done with the <b>getAttribute</b> macro: <code>?getAttribute(AState,AttributeName)</code>.
</p>

<p>
For example, <code>MyColor = ?getAttribute(State,whisker_color)</code>
 returns the value of the attribute <code>whisker_color</code> from state <code>State</code>.
</p>


<p>
The requested attribute may not exist in the specified state. In this case, a bad match is triggered: <code>{{badmatch,undefined},[{hashtable,getEntry,2},..</code>.
</p>

<p>
Quite often, when retrieving an attribute, the state variable will be named <code>State</code> (when using directly the original state specified in the method declaration). In this case, the <b>getAttr</b> macro can be used: <code>?getAttr(whisker_color)</code> expands as <code>?getAttribute(State,whisker_color)</code> (and is a bit shorter).
</p>



<h4>Read-Modify-Write operations</h4>
<p>
Some more helper macros are provided for common operations, to keep the syntax as lightweight as possible.



<h5>The <code>addToAttribute/3</code> macro</h5>

<b>addToAttribute(State,AttributeName,Value)</b>: when having a numerical attribute, adds specified number to the attribute. For example: <code>NewState = ?addToAttribute(State,a_numerical_attribute,6)</code>. If the target attribute does not exist, will trigger <code>{{badmatch,undefined},[{hashtable,addToEntry,3},..</code>. If it exists but no addition can be performed on it, will trigger <code>{badarith,[{hashtable,addToEntry,3},..</code>.



<h5>The <code>substractFromAttribute/3</code> macro</h5>

<b>substractFromAttribute(State,AttributeName,Value)</b>: when having a numerical attribute, substracts specified number from the attribute. For example: <code>NewState = ?substractFromAttribute(State,a_numerical_attribute,1)</code>. If the target attribute does not exist, will trigger <code>{{badmatch,undefined},[{hashtable,substractFromEntry,3},..</code>. If it exists but no addition can be performed on it, will trigger <code>{badarith,[{hashtable,substractFromEntry,3},..</code>.


<h5>The <code>toggleAttribute/2</code> macro</h5>

<b>toggleAttribute(State,BooleanAttributeName)</b>: when having a boolean attribute, whose values are either <code>true</code> or <code>false</code>, sets the opposite logical value to the current one. For example: <code>NewState = ?toggleAttribute(State,a_boolean_attribute)</code>. If the target attribute does not exist, will trigger <code>{{case_clause,undefined},[{hashtable,toggleEntry,2},..</code>. If it exists but is neither true or false, will trigger <code>{{case_clause,{value,..}},[{hashtable,toggleEntry,2},..</code>.


<h5>The <code>appendToAttribute/3</code> macro</h5>

<b>appendToAttribute(State,AttributeName,Element)</b>: when having a list attribute, appends specified element to the attribute list. For example: <code>NewState = ?appendToAttribute(State,a_list_attribute,hello)</code>. If the target attribute does not exist, will trigger <code>{{badmatch,undefined},[{hashtable,appendToEntry,3},..</code>. If it exists but is not already a list, it will not crash but will create an ill-formed list (ex: <code>[8|false]</code> when appending 8 to false, which is not a list).


<h5>The <code>deleteFromAttribute/3</code> macro</h5>

<b>deleteFromAttribute(State,AttributeName,Element)</b>: when having a list attribute, deletes first match of specified element from the attribute list. For example: <code>NewState = ?deleteFromAttribute(State,a_list_attribute,hello)</code>. If the target attribute does not exist, will trigger <code>{{badmatch,undefined},[{hashtable,deleteFromEntry,3},..</code>. If it exists but is not already a list, it will trigger <code>{function_clause,[{lists,delete,[..,..]},{hashtable,deleteFromEntry,3}</code>. If no element in the list matches the specified one, no error will be triggered and the list will be kept as is.

	
<h5>The <code>popFromAttribute/2</code> macro</h5>

<b>popFromAttribute(State,AttributeName)</b>:  when having a list attribute, removes the head from the list and returns a pair made of the updated state (same state except that the corresponding list attribute has lost its head) and of that head. For example: <code>{NewState,Head} = ?popFromAttribute(State,a_list_attribute)</code>. If the value of <code>a_list_attribute</code> was <code>[5,8,3]</code>, its new value (in <code>{NewState,Head}</code>) will be <code>[8,3]</code> and <code>Head</code> will be equal to 5.


<h5>The <code>addKeyValueToAttribute/4</code> macro</h5>

<b>addKeyValueToAttribute(State,AttributeName,Key,Value)</b>: when having a hashtable attribute, adds specified key/value pair to that hashtable. For example: <code>WithTableState = ?setAttribute( State, my_hashtable, hashtable:new() ), NewState = ?addKeyValueToAttribute( WithTableState, my_hashtable, my_key, my_value )</code>.

<!--
	<li><b></b>: <code></code></li>
-->

</ul>

</p>

<p>
See <a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/src/wooper.hrl?view=markup" target="_blank">wooper.hrl</a> for the actual definition of most of the WOOPER constructs.
</p>

<br><p><center>[<a href="#usagetoc">Back to the usage table of contents</a>]</center></p><br>





<a name="inheritpolymorph"></a>
<h3>Multiple inheritance &amp; polymorphism</h3>


<h4>Common case</h4>
<p>
Both are automatically managed by WOOPER: even if our cat class does not define a <code>getAge</code> method, it can be readily be used as it is inherited from its mother classes (here from <code>class_Creature</code>, an indirect mother class). All creature instances can be handled the same:

<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
% Inherited methods work exactly the same as methods defined directly 
% in the class:
MyCat ! {getAge,[],self()},
receive
		
	{wooper_result,Age} -&gt;
		io:format( "This is a ~B year old cat.", [Age] )

end,

% Polymorphism is immediate:
% (class_Platypus inheriting too from class_Mammal, hence from class_Creature)
MyPetList = [ MyCat, MyPlatypus ],
foreach( 
	fun(AnyCreature) -&gt;
		AnyCreature ! {getAge,[],self()},
		receive
		
			{wooper_result,Age} -&gt;
				io:format( "This is a ~B year old creature.", [Age] )

		end,
	MyPetList).
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
</p>


<h4>Diamond-shaped inheritance</h4>
<p>
In the case of a <a href="http://en.wikipedia.org/wiki/Diamond_problem" target="_blank">diamond-shaped inheritance</a>, as the method table is constructed in the order specified in the declaration of the superclasses  (<code>-define(wooper_superclasses,[class_X,class_Y, etc.]).</code>), and as child classes override mother ones, the selected <b>method</b> should be the one defined in the branch of the last child (if any), otherwise the one of the common ancestor.
</p>

<p>
Generally speaking, in that case, overriding the relevant methods in the class at the base of the diamond so that they perform an explicit call to the wanted module is by far the most reasonable solution.   
</p>

<p>
Regarding the instance state, the <b>attributes</b> are set by the constructors, therefore the developer can select in which order the direct mother classes should be constructed. However it always leads to calling multiple times the constructor of the class that sits at the top of the diamond. Its side-effects would then occur more than once.
</p>

<p>
More generally speaking, in my opinion diamond-shaped inheritance is seldom necessary. More often than not, it is the consequence of a bad OOP design, and should be avoided.
</p>


<br><p><center>[<a href="#usagetoc">Back to the usage table of contents</a>]</center></p><br>



<a name="lifecycle"></a>
<h3>Life-cycle</h3>

<p>
Creation and destruction of instances are managed respectively thanks to the <code>new</code>/<code>new_link</code> and the <code>delete</code> operators (both are WOOPER-reserved function names, for all arities):
<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
MyCat = class_Cat:new(Age,Gender,FurColor,WhiskerColor),
MyCat ! delete.
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
</p>


<h4>Instance creation: new/new_link and construct</h4>


<h5>Role of a new/construct pair</h5>

<p>
Whereas the purpose of <code>new</code>/<code>new_link</code> is to create a working instance on the user behalf, the role of <code>construct</code> is to initialize an instance of that class while being able to be chained for inheritance, as explained later. 
</p>

<p>
The <code>new_link</code> operator behaves exactly as the <code>new</code> operator, except that it creates an instance that is Erlang-linked with the process that called that operator, like <code>spawn_link</code> behaves compared to <code>spawn</code>..
</p>

<p>
The <code>new</code> and <code>new_link</code> operators are automatically defined by WOOPER, but they rely on the class-specific <code>construct</code> special method (only WOOPER is expected to call this method). This <code>construct</code> method is the one that must be implemented by the class developer.
</p>

<p>
Only one version of <code>new/new_link/construct</code> can be defined, but this unique threefold constructor may be defined to branch to as many subconstructors as needed. For example:
<ul>

	<li><code>MyCat = Class_Cat:new(construct_from_colors,[sand,white]).</code></li>

	<li><code>MyCat = Class_Cat:new(construct_from_age,4).</code></li>

	<li><code>MyCat = Class_Cat:new(construct_from_weight,3.8).</code></li>

<!--

-->

</ul>
</p>

<p>
As shown with the <code>new_link</code> operator, many variations of <code>new</code> could be imagined: linked or not, synchronous or not, with a time-out or not, on current node or on a user-specified one, etc. The most common variations are detailed below.
</p>

<p>
Currently, <code>new</code>, <code>new_link</code>, <code>synchronous_new</code> and <code>synchronous_new_link</code> are the only (default) built-in operators, whereas <code>synchronous_timed_new</code>, <code>remote_new</code>, etc. are not, so that the class developer is not required to declare too many <code>new</code> operator variations in each class.
</p>



<h6>Synchronous new</h6>

<p>
The basic <code>new/new_link</code> operators are <b>asynchronous</b>: they trigger the creation of a new instance, and return immediately, without waiting for it to complete. Thus the caller has no way to know when the spawned instance is up and running (if it ever happens). Two counterpart operators, <code>synchronous_new/synchronous_new_link</code>, behave like <code>new/new_link</code> except they will return when (and if) the created instance is up and running.
</p>

<p>
For example, after <code>MyMammal = class_Mammal:synchronous_new(...)</code>, one knows that the <code>MyMammal</code> instance is fully created and waiting for incoming messages.
</p>

<p>
These synchronous operations are performed by automatically ensuring that the created instance sends a message (<code>{spawn_successful,InstancePid}</code>)
to the process that created it, and that waits for it automatically thanks to WOOPER.
</p>


<h6>Timed Synchronous new</h6>

<p>
Note that, should the instance creation fail, the caller of a synchronous new would be blocked for ever. If one wanted to use a synchronous new with a time-out, the following code could be added in the class module and exported (alternatively, '<code>% -define(use_synchronous_timed_new,).</code>' could be uncommented in <code>wooper.hrl</code>, and all classes should then export this new operator):
<center>
    <table summary="a box" style="border : none">
        <tr>
          <td>
            <div class="box">
<code><pre>
% The duration in milliseconds before a time-out is triggered after a created
% instance does not seem to answer properly and on reasonable time:
-define(synchronous_time_out,5000).
			
% Spawns a new instance for this class, using specified parameters to
% construct it.
% Returns the PID of the newly created instance, or the time_out atom.
% Creation is synchronous: synchronous_new will return only when the created
% process reports it is up and running, or when a time-out occurs.
synchronous_timed_new(?wooper_construct_parameters) ->
	SpawnedPid = spawn(?MODULE, wooper_construct_and_run_synchronous,
		[ [?wooper_construct_parameters], self() ] ),
		
	% Blocks until the spawned process answers or a time-out occurs:	
	receive	
		
		{spawn_successful,SpawnedPid} ->
			SpawnedPid
	
	after ?synchronous_time_out -> 
	
		time_out
		
	end.
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
  
</p>


<h6>Remote new</h6>
<p>
Exactly like a process might be spawned on another Erlang node, an instance can be spawned on a user-specified node.
</p>

<p>
To do so, either add following code in target class module and export it, or uncomment '<code>% -define(use_remote_new,).</code>' in <code>wooper.hrl</code> to enable this operator for all classes:
<center>
    <table summary="a box" style="border : none">
        <tr>
          <td>
            <div class="box">
<code><pre>
% Spawns a new instance for this class on specified interconnected node, using
% specified parameters to construct it.
% If Node does not exist, a useless pid is returned. 
% Returns the PID of the newly created instance.
% Creation is asynchronous: remote_new returns as soon as the creation is
% triggered, without waiting for it to complete.
remote_new(Node,?wooper_construct_parameters) ->
	spawn(Node, ?MODULE, wooper_construct_and_run_synchronous,
		[ [?wooper_construct_parameters], self() ] ).
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
 
 
  
</p>





<h5>Declaration of the new/construct pair</h5>

<p>
When an instance is created, user-specified parameters are given to the relevant <code>new</code> operator, notably to set up the instance initial state, i.e. its attributes. These parameters must be declared thanks to the <code>wooper_construct_parameters</code> define. For example, <code>-define( wooper_construct_parameters,).</code> (no parameter needed), or <code>-define( wooper_construct_parameters, Age, Gender ).</code> (two parameters needed).
</p>

<p>
The WOOPER-defined <code>new</code> operator automatically transmits these parameters to the <code>construct</code> method.
</p>

<p>
Based on the <code>wooper_construct_parameters</code> define (let us suppose n constructor parameters are listed in it), <code>new</code> and <code>construct</code> must be declared thanks to: <code>-define( wooper_construct_export,new/n,new_link/n,construct/n+1).</code>. <code>construct</code> takes one additional parameter, the instance state.
</p>

<p>
For example, if <code>-define( wooper_construct_parameters, Age, Gender ).</code> is declared, <code>-define( wooper_construct_export, new/2, new_link/2, synchronous_new/2, synchronous_new_link/2, construct/3 ).</code> should then be specified, and the corresponding method will be: <code>construct(State,?wooper_construct_parameters) -&gt; [..]</code>. If there is no construction-related parameter, then the method becomes: <code>construct(State) -&gt; [..]</code>. All four <code>new</code> operators are always defined automatically by WOOPER, nothing is to be done for them.
</p>

<p>

</p>


<h5>Definition of the <code>construct</code> method</h5>

<p>
The <code>construct</code> methods are expected to be chained: they must be designed to be called by the ones of child classes, and they must call themselves the constructors of their mother classes, if any. Hence they always take the current state of the instance being created as a starting base, and returns it once updated, first from the direct mother classes, then by this class itself.
</p>

<p>
For example, <code>class_Cat</code> inherits directly from <code>class_Mammal</code> and <code>class_ViviparousBeing</code>, and has only one attribute (<code>whisker_color)</code> on its own:
<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
[..]
-define(wooper_superclasses,[class_Mammal,class_ViviparousBeing]).
[..]
-define(wooper_construct_parameters,Age,Gender,FurColor,WhiskerColor).
[..]
-define(wooper_construct_export,new/4,new_link/4,construct/5).
[..]
% Constructs a new Cat.
construct(State,?wooper_construct_parameters) -&gt;

	% First the direct mother classes:
	MammalState = class_Mammal:construct( State, Age, Gender, FurColor ),
	ViviparousMammalState = class_ViviparousBeing:construct( MammalState ),
	
	% Then the class-specific attributes:
	?setAttribute( ViviparousMammalState, whisker_color, WhiskerColor ).

</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>

</p>

<p>
The fact that the <code>Mammal</code> class itself inherits from the <code>Creature</code> class must not appear here: it is to be managed directly by <code>class_Mammal:construct</code> (only direct classes must be taken into account in a given inheritance level).
</p>

<p>
One should ensure that, in constructors, the successive states are always built from the last updated one:

<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
% WRONG, the age update is lost:
construct(State,Age,Gender) -&gt;
	AgeState = setAttribute(State,age,Age),
	setAttribute(<u>State</u>,gender,Gender),
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>


<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
% RIGHT but clumsy:
construct(State,Age,Gender) -&gt;
	AgeState = setAttribute(State,age,Age),
	setAttribute(<u>AgeState</u>,gender,Gender).
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>

<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
% BEST:
construct(State,Age,Gender) -&gt;
	setAttributes( State, [ {age,Age}, {gender,Gender} ]).
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>

</p>


<h4>Instance deletion: delete</h4>

<p>
The <code>delete</code> operator can be omitted, in this case a default do-nothing destructor is used, and the instance is stopped and garbage-collected. 
If a specific action must be performed on deletion, potentially-chained destructors can be defined:
<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
% Overriding default destructor:	
% State should be returned, and destructors should be called in leaf-to-root
% order in inheritance tree, thus first this class, then all the direct
% mother classes, if any.
delete(State) -&gt;
	% Perform here class-specific action (ex: socket or file explicit closing).
	LocalDelState = my_action( State ),
	% Then call the direct mother class counterparts:
	OneDelState = class_MotherOne:delete( LocalDelState ),
	TwoDelState = class_MotherTwo:delete( OneDelState ),
	% Finally return the state to allow child classes to chain:
	TwoDelState.
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>

</p>


<br><p><center>[<a href="#usagetoc">Back to the usage table of contents</a>]</center></p><br>



<a name="misc"></a>
<h3>Misceallenous technical points</h3>


<h4>EXIT messages</h4>
<p>
A class instance may receive EXIT messages from other processes. A given class can process these EXIT notifications by exporting the <code>onWooperExitReceived/3</code> method and by defining it, including by inheritance. For example:

<center>
    <table summary="Code" style="border : none">
        <tr>
          <td>
            <div class="box">
<code><pre>
onWooperExitReceived(State,Pid,ExitType) ->
	io:format( "MyClass EXIT handler ignored signal '~w' from ~w.~n",
		[ExitType,Pid] ),
	?wooper_return_state_only(State).	
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>

results in: 
<code>MyClass EXIT handler ignored signal 'normal' from &lt;0.40.0&gt;.</code>
</p>

<p>
If no class-specific EXIT handler is available, default WOOPER one will be used. It will just notify the user by displaying a message like: <code>WOOPER default EXIT handler ignored signal 'normal' from &lt;0.40.0&gt;.</code>
</p>


<h4>Practical build hints</h4>
<p>
All WOOPER classes must include <a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/src/wooper.hrl?view=markup" target="_blank">wooper.hrl</a>: <code>-include("wooper.hrl").</code>. To help declaring the right defines in the right order, using the WOOPER <a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_Template.erl.sample?view=markup" target="_blank">template</a> is recommended.
</p>

<p>
One should have <code>utils.beam</code>, <code>hashtable.beam</code> and <code>wooper_class_manager.beam</code> available to the interpreter before using WOOPER-based classes.
</p>

<p>
On UNIX-like platforms, using the Makefiles included with WOOPER archive is recommended. One just has to go at the root of the sources (from an extracted archive, you are expected to be in the <code>wooper-x.y</code> root directory) and simply run: <code>make</code> (assuming GNU make is available, so that the WOOPER <code>GNUmakefile</code> is used).
</p>

<p>
On other platforms, these modules must be compiled one way or another before using WOOPER, for example: 
<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
1> c(hashtable).
{ok,hashtable}
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
</p>

<p>
We provide as well a WOOPER-aware <a href="http://ceylan.svn.sourceforge.net/viewvc/*checkout*/ceylan/Ceylan/trunk/src/conf/environment/nedit.rc" target="_blank">nedit</a> configuration file for syntax highlighting (on black backgrounds), inspired from Daniel Solaz's <a href="http://www.trapexit.org/forum/viewtopic.php?p=30189" target="_blank">Erlang Nedit mode</a>.
</p>

<p>
Finally, WOOPER is in some ways adding features very similar to the ones of Python (simple multiple inheritance, implied <code>self/State</code> parameter, attribute dictionaries, etc.; with less syntatic sugar available though) while still offering the major strengths of Erlang (concurrency, distribution, functional paradigm) and not hurting too much overall performances (mainly thanks to the prebuilt attribute and method hashtables).
</p>


<br><p><center>[<a href="#maintoc">Back to the table of contents</a>]</center></p><br>


<!-- #####################################################################" -->




<a name="example"></a>
<h2>WOOPER example</h2>

<p>
We created a small set of classes allowing to show multiple inheritance:

<center>
    <a href="wooper-example.png" target="_blank"><img src="wooper-example.png" alt="WOOPER example" width="95%"></img></a><br>
(click to enlarge)
</center>
</p>


<h3>Class implementations</h3>
<ul>

    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_Creature.erl?view=markup" target="_blank">class_Creature.erl</a></li>
    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_ViviparousBeing.erl?view=markup" target="_blank">class_ViviparousBeing.erl</a></li>
    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_OvoviviparousBeing.erl?view=markup" target="_blank">class_OvoviviparousBeing.erl</a></li>
    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_Mammal.erl?view=markup" target="_blank">class_Mammal.erl</a></li>
    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_Reptile.erl?view=markup" target="_blank">class_Reptile.erl</a></li>
    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_Cat.erl?view=markup" target="_blank">class_Cat.erl</a></li>
    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_Platypus.erl?view=markup" target="_blank">class_Platypus.erl</a></li>
	
</ul>


<h3>Tests</h3>
<ul>

    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_Creature_test.erl?view=markup" target="_blank">class_Creature_test.erl</a></li>
    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_ViviparousBeing_test.erl?view=markup" target="_blank">class_ViviparousBeing_test.erl</a></li>
    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_OvoviviparousBeing_test.erl?view=markup" target="_blank">class_OvoviviparousBeing_test.erl</a></li>
    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_Mammal_test.erl?view=markup" target="_blank">class_Mammal_test.erl</a></li>
    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_Reptile_test.erl?view=markup" target="_blank">class_Reptile_test.erl</a></li>
    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_Cat_test.erl?view=markup" target="_blank">class_Cat_test.erl</a></li>
    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_Platypus_test.erl?view=markup" target="_blank">class_Platypus_test.erl</a></li>
	
</ul>


<p><center>[<a href="#maintoc">Back to the table of contents</a>]</center></p><br>



<!-- #####################################################################" -->


<a name="troubleshooting"></a>
<h2>Troubleshooting</h2>

<p>
Most errors while using WOOPER should result in relatively clear messages (ex: <code>wooper_method_failed</code> or <code>wooper_method_faulty_return</code>). There are a few gotchas though. 
</p>

<p>
One of them - experienced even by the WOOPER author - is to define a two-parameter oneway, whose second parameter is a PID, and to call this method wrongly as a request, instead of as a oneway. 
</p>

<p>
For example, let's suppose the <code>class_TimeManager</code> class defines the oneway method <code>start/3</code> as: <code>start(State,TerminationOffset,StopListenerPID) -&gt; ...</code>.
</p>

<p>
The correct approach to call this <b>oneway</b> could be <code>TimeManagerPid ! {start,[AnOffset,self()]}</code>. An absent-minded developer could have written <code>TimeManagerPid ! {start, AnOffset,self()}</code> instead.
</p>

<p>
This would have called a <code>request</code> method <code>start/2</code> (which could have been <code>start(State,TerminationOffset) -&gt; ...</code>, the PID being interpreted by WOOPER as the request sender PID), which most probably would not exist. This would result in a rather obscure error message like <code>Error in process <0.43.0> on node 'XXXX' with exit value: {badarg,[{class_TimeManager,wooper_main_loop,1}]}</code>.
</p>

<p>
One way of overcoming WOOPER issues is to activate the debug mode for all WOOPER-enabled compiled modules (ex: uncomment <code>-define(wooper_debug,).</code> in <code>wooper.hrl</code>).
</p>

<p>
If it is not enough to clear things up, an additional step is to add, on a per-class basis (ex: in <code>class_TimeManager.erl</code>), before the WOOPER include, <code>-define(wooper_log_wanted,).</code>. Then all WOOPER incoming method calls will be traced, for easier debugging.
</p>


<p><center>[<a href="#maintoc">Back to the table of contents</a>]</center></p><br>


<!-- #####################################################################" -->




<a name="example"></a>
<h2>WOOPER example</h2>
<h2>Current stable version &amp; download</h2>

<h3>Using stable release archive</h3>
<p>
WOOPER 0.2 is ready to be used and can be downloaded <a href="http://sourceforge.net/project/showfiles.php?group_id=158516&package_id=239574" target="_blank">here</a>. Either a .zip or a .tar.bz2 can be retrieved. Starting from the 0.1 version, WOOPER should be fully functional (pun intended!). 
</p>

<p>
One way of building all of Wooper (base files and examples) is, from UNIX or on Windows from a Cygwin or MSYS shell, once the archive is downloaded and extracted, to execute <code>make all</code> from the WOOPER directory. For example:

<center>
    <table summary="Code" style="border: none">
        <tr>
          <td>
            <div class="box">
<code><pre>
tar xvjf wooper-x.y.tar.bz2 && cd wooper-x.y && make all
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
It will build and run all, including the various WOOPER test suites.
</p>


<h3>Using cutting-edge SVN</h3>

<p>
A SVN (anonymous) check-out of WOOPER code can be obtained thanks to, for example:
<center>
    <table summary="a box" style="border: none">
        <tr>
          <td>
            <div class="box">
svn co https://ceylan.svn.sourceforge.net/svnroot/ceylan/Ceylan/trunk/src/code/scripts/erlang Wooper-code-checkout 
            </div>
          </td>
        </tr>
    </table>
</center>
</p>

<p>
Ceylan developers should used their Sourceforge user name so that they can commit changes:
<center>
    <table summary="a box" style="border: none">
        <tr>
          <td>
            <div class="box">
svn co --username YourSFUserName https://ceylan.svn.sourceforge.net/svnroot/ceylan/Ceylan/trunk/src/code/scripts/erlang Wooper-code-checkout 
            </div>
          </td>
        </tr>
    </table>
</center>
</p>

<p>
Check-out of WOOPER documentation can be performed thanks to:
<center>
    <table summary="a box" style="border: none">
        <tr>
          <td>
            <div class="box">
svn co --username YourSFUserName https://ceylan.svn.sourceforge.net/svnroot/ceylan/Ceylan/trunk/src/doc/web/main/documentation/wooper Wooper-doc-checkout
            </div>
          </td>
        </tr>
    </table>
</center>

</p>


<p>
If just wanting a SVN anonymous export, use for example:
<center>
    <table summary="a box" style="border : none">
        <tr>
          <td>
            <div class="box">
svn export http://ceylan.svn.sourceforge.net/svnroot/ceylan/Ceylan/trunk/src/code/scripts/erlang Wooper-code-export 
            </div>
          </td>
        </tr>
    </table>
</center>

and 

<center>
    <table summary="a box" style="border: none">
        <tr>
          <td>
            <div class="box">
svn export http://ceylan.svn.sourceforge.net/svnroot/ceylan/Ceylan/trunk/src/doc/web/main/documentation/wooper Wooper-doc-export
            </div>
          </td>
        </tr>
    </table>
</center>

</p>

<p><center>[<a href="#maintoc">Back to the table of contents</a>]</center></p><br>

<!-- #####################################################################" -->



<a name="versions"></a>
<h2>Version history &amp; changes</h2>

<!--
<a name="version_X_Y"
<h3>Version </h3>
<p>
Not released yet (work-in-progress, only available on SVN). Major changes are:
<ul>
	<li></li>
</ul>

</p>
-->


<a name="versiontoc"></a>
<center>
	<table summary="Table of contents for WOOPER versions" style="border: none">
        <tr>
          <td>
		   <div class="box">
		       <a href="#version_0_3">0.3</a> [cutting-edge, in SVN only]<br>
		       <a href="#version_0_2">0.2</a> [current stable]<br>
		       <a href="#version_0_1">0.1</a>

<!--
		       <a href="#"></a><br>
-->

          </div>

          </td>
        </tr>
      </table>
</center>



<a name="version_0_3"></a>
<h3>Version 0.3</h3>
<p>
Not released yet (work-in-progress, only available on SVN). Should be a BFO (Bug Fixes Only, if bugs were to be found) version, as functional coverage is pretty complete already.
<ul>

	<li>incoming EXIT messages are caught by a default WOOPER handler which can be overridden on a per-class basis by the user-specified <code>onWooperExitReceived/3</code> method</li>

	<li>direct method invocation supported, thanks to the <code>executeRequest</code> and <code>executeOneway</code> constructs</li>

	<li>synchronous spawn operations added: <code>synchronous_new/synchronous_new_link</code></li>

	<li>state management enriched: <code>popFromAttribute</code> added</li>

	<li>TO-DO: new on remote nodes to be added</li>

<!--
	<li></li>
-->
	
</ul>

</p>


<a name="version_0_2"></a>
<h3>Version 0.2</h3>
<p>
Released on Friday, December 21, 2007. Still fully functional!
<ul>
	<li>the sender PID is made available to requests in the instance state variable (see <code>request_sender</code> member, used automatically by the <code>getSender</code> macro)</li>
	<li>runtime errors better identified and notified</li>
	<li>macros for attribute management added, existing ones more robust and faster</li>
	<li>fixed a potential race condition when two clients request nearly at the same time the WOOPER class manager (previous mechanism worked, class manager was a singleton indeed, but second client was not notified)</li>
	<li>improved build (Emakefile generated), comments, error output</li>
	<li>test template added</li>
	<li>documentation updated</li>
</ul>

</p>

<a name="version_0_1"></a>
<h3>Version 0.1</h3>
<p>
Released on Sunday, July 22, 2007. Already fully functional!
</p>



<p><center>[<a href="#maintoc">Back to the table of contents</a>]</center></p><br>


<!-- #####################################################################" -->




<a name="inner"></a>
<h2>WOOPER inner workings</h2>

<p>
Each instance runs a main loop (<code>wooper_main_loop</code>, defined in <code>wooper.hrl</code>) that keeps its internal state and through a <code>receive</code> serves the methods specified by incoming messages.
</p>

<p>
The kept state is twofold:
<ul>
	<li><p>a <b>method virtual table</b>: this per-class hashtable is built at runtime, on the first creation of an instance of this class, and stored by the unique (singleton) Wooper class manager that shares it to all the class instances. This manager is itself spawned the first time it is needed, and stays ready for all instances of various classes being created (it uses a hashtable to associate to each class its specific virtual table).</p>
	
	<p>This per-class method table has for keys the known method names (atoms) for this class, associated to the values being the most specialized module, in inheritance tree, that defines that method. Hence each instance has a reference to a shared hashtable that allows for a direct method look-up. As the table is built only once and is shared by all instances, it adds very little overhead, space-wise and time-wise. Thanks to the hashtable, method look-up is efficient too
	</p>
	</li>
	
	<li>an <b>attribute table</b>: another hashtable, this time per-instance. Keys are attribute names, values are attributes values. It allows a seamless yet not too slow access to all data members, including inherited ones</li>
</ul>
</p>


<p>
WOOPER relies only on these specific files:
<ul>

<!--
    <li><a href="" target="_blank"></a></li>
-->

    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/src/wooper.hrl?view=markup" target="_blank">wooper.hrl</a>: the WOOPER core, which gives modules using it all the OOP constructs discussed</li>
    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/src/wooper_class_manager.hrl?view=markup" target="_blank">wooper_class_manager.hrl</a>: the (very short) class manager header</li>
    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/src/wooper_class_manager.hrl?view=markup" target="_blank">wooper_class_manager.erl</a>: the class manager itself, the unique process that is automatically spawned to share virtual tables among instances</li>
    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/common/hashtable.erl?view=markup" target="_blank">hashtable.erl</a>: efficient associative table used by WOOPER for virtual tables, methods, attributes</li>
    <li><a href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/common/utils.erl?view=markup" target="_blank">utils.erl</a>: a small module used by the hashtable and other modules</li>
</ul>
</p>


<p><center>[<a href="#maintoc">Back to the table of contents</a>]</center></p><br>

<!-- #####################################################################" -->





<a name="next"></a>
<h2>Issues &amp; planned enhancements</h2>
 
<p>
<ul>

<!--
	<li><b></b>: </li>
-->

	<li>Is <b>wooper_main_loop</b> (in <code>wooper.hrl</code>) really tail-recursive ? I think so</li>
	
	<li>Integrate automatic <b>persistant storage</b> of instance states into Mnesia databases</li>
	
	<li>Would there be a <b>more efficient</b> implementation of hashtables ? (ex: ets-based ?). More generally speaking, some profiling could be done to further increase overall performances</li>

	<li>Having to export by hand all new-related operators (ex: <code>new_link/n</code>) is cumbersome and prevent from having all the many <code>new</code> variations defined as built-in. Maybe an appropriate parse transform could do the trick ?</li>
	
</ul>

</p>

<p><center>[<a href="#maintoc">Back to the table of contents</a>]</center></p><br>



<!-- #####################################################################" -->


<a name="license"></a>
<h2>License</h2>
<p>
WOOPER is licensed by its author (Olivier Boudeville) under a disjunctive tri-license giving you the choice of one of the three following sets of free software/open source licensing terms:
<ul>

<!--
    <li><a href="" target="_blank"></a></li>
-->

    <li><a href="http://www.mozilla.org/MPL/MPL-1.1.html" target="_blank">Mozilla Public License</a> (MPL), version 1.1 or later (very close to the <a href="http://www.erlang.org/EPLICENSE" target="_blank">Erlang Public License</a>, except aspects regarding Ericsson and/or the Swedish law)</li>
    <li><a href="http://www.gnu.org/licenses/gpl-2.0.html" target="_blank">GNU General Public License</a> (GPL), version 2.0 or later</li>
    <li><a href="" target="_blank">GNU Lesser General Public License</a> (LGPL), version 2.1 or later</li>
</ul>
</p>

<p>
This allows the use of the WOOPER code in as wide a variety of software projects as possible, while still maintaining copyleft on this code. Being triple-licensed means that someone (the licensee) who modifies and/or distributes it can choose which of the available sets of license terms he is operating under. Enhancements are expected to be back-contributed, so that everyone can benefit from them.
</p>

<p><center>[<a href="#maintoc">Back to the table of contents</a>]</center></p><br>


<!-- #####################################################################" -->

<a name="sources"></a>
<h2>Sources, inpirations &amp; alternate solutions</h2>

<p>

<ul>
<!--
    <li><a href="" target="_blank"></a></li>
-->
	
    <li><b>Concurrent Programming in Erlang</b>, Joe Armstrong, Robert Virding, Claes Wikstrm et Mike Williams. Chapter 18, page 299: Object-oriented Programming. This book describes a simple way of implementing multiple inheritance, without virtual table, at the expense of a (problably slow) systematic method look-up (at each method call). No specific state management is supported</li>

    <li>Chris Rathman 's <a href="http://www.angelfire.com/tx4/cus/shapes/erlang.html" target="_blank">approach</a> to life cycle management and polymorphism. Inheritance not supported</li> 
	
    <li>
	As Burkhard Neppert suggested, an alternative way of implementing OOP here could be to use Erlang behaviours. This is the way OTP handles generic functionalities that can be specialized (e.g. <code>gen_server</code>). One approach could be to map each object-oriented base class to an Erlang <b>behaviour</b>. See some guidelines about <a href="http://wiki.trapexit.org/index.php/Defining_Your_Own_Behaviour" target="_blank">defining</a> your own behaviours and making them <a href="http://wiki.trapexit.org/index.php/Cascading_Behaviours" target="_blank">cascade</a>
	</li>

    <li>
	
		<p>As mentioned by Niclas Eklund, despite quite different operating modes, WOOPER and <a href="http://www1.erlang.org/doc/apps/orber/index.html" target="_blank">Orber</a>, an Erlang implementation of a <b>CORBA ORB</b>
 (<em>Object Request Broker</em>) offer similar OOP features, as CORBA IDL implies an object-oriented approach (see their <a href="http://www.erlang.org/doc/apps/orber/ch_idl_to_erlang_mapping.html#6" target="_blank">OMG IDL to Erlang Mapping</a>).
		</p>

		<p>WOOPER and Orber are rather different beasts though: WOOPER is very lightweight (less than 1000 lines, including blank lines and numerous comments), does not involve a specific (IDL) compiler generating several stub/skeleton Erlang files, nor depends on OTP or Mnesia, whereas Orber offers a full CORBA implementation, including IDL language mapping, CosNaming, IIOP, Interface Repository, etc.
		</p>

		<p>Since Orber respects the OMG standard, integrating a new language (C/C++, Java, Smalltalk, Ada, Lisp, Python etc.) should be rather easy. On the other hand, if a full-blown CORBA-compliant middleware is not needed, if simplicity and ease of understanding is a key point, then WOOPER could be preferred. If unsure, give a try to both!
		</p>

		<p>
 See also another IDL-based approach (otherwise not connected to CORBA), the <a href="http://www.erlang.org/doc/apps/ic/ch_erl_genserv.html#5" target="_blank">Generic Server Back-end</a> (wrapper around <code>gen_server</code>).
		</p>

	</li>


</ul>

</p>

<p>
The WOOPER name is also a tribute to the underestimated <a href="http://en.wikipedia.org/wiki/WarGames" target="_blank">Wargames</a> movie (remember the <a href="http://en.wikipedia.org/wiki/WOPR" target="_blank">WOPR</a>, the NORAD central computer ?), which the author enjoyed a lot. It is as well a second-order tribute to the <em>Double Wooper King Size</em> (<em>Whopper</em> in most if not all countries), which is/was a great hamburger indeed (in France, they are not available anymore).
</p>

<p><center>[<a href="#maintoc">Back to the table of contents</a>]</center></p><br>


<!-- #####################################################################" -->


<a name="support"></a>
<h2>Support</h2>
<p>
Bugs, questions, remarks, patches, requests for enhancements, etc. are to be sent to the <a href="mailto:ceylan-wooperNOSPAM@lists.sourceforge.net" target="_blank">ceylan-wooper at lists dot sourceforge dot net</a>. One must <a href="https://lists.sourceforge.net/lists/listinfo/ceylan-wooper" target="_blank">register</a> first.
</p>

<p><center>[<a href="#maintoc">Back to the table of contents</a>]</center></p><br>

<!-- #####################################################################" -->

<a name="developers"></a>
<h2>For WOOPER developers</h2>
<p>
When a new WOOPER version is released, tag the corresponding file versions like in:
<center>
    <table summary="a box" style="border : none">
        <tr>
          <td>
            <div class="box">
svn copy https://ceylan.svn.sourceforge.net/svnroot/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper https://ceylan.svn.sourceforge.net/svnroot/ceylan/Ceylan/tags/wooper-release-0.1 -m "First release (0.1) of WOOPER, already fully functional."

            </div>
          </td>
        </tr>
    </table>
</center>
</p>

<p><center>[<a href="#maintoc">Back to the table of contents</a>]</center></p><br>

<!-- #####################################################################" -->

  <br>
  <br>

  <h3>Please react !</h3>

  <p>If you have information more detailed or more recent than those
  presented in this document, if you noticed errors, neglects or points
  insufficiently discussed, <a href=
  "mailto:olivier.boudeville@online.fr?subject=[Ceylan]%20WOOPER">
  drop us a line</a> !</p><br>
  <br>
  <hr>

  <center>
    [<a href="#_top_">Top</a>]<br>
    <br>
    <em>Last update: Tuesday, October 7, 2008</em>
  </center>
</body>
</html>
