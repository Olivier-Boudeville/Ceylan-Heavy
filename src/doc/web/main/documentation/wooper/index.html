<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.4.1: http://docutils.sourceforge.net/" />
<title>WOOPER</title>
<style type="text/css">

/*
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:Date: $Date: 2005-12-18 01:56:14 +0100 (Sun, 18 Dec 2005) $
:Revision: $Revision: 4224 $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
	 The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left {
  clear: left }

img.align-right {
  clear: right }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;
  background-color: #eeeeee }

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

tt.docutils {
  background-color: #eeeeee }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="wooper">
<h1 class="title">WOOPER</h1>
<h2 class="subtitle" id="wrapper-for-object-oriented-programming-in-erlang"><em>Wrapper for Object-Oriented Programming in Erlang</em></h2>
<span class="target" id="top"></span><!-- stylesheet ../../../common/css/Ceylan.css -->
<p><span class="raw-html"><p>The WOOPER documentation is also available in the PDF format: see <a href="http://ceylan.sourceforge.net/main/documentation/wooper/wooper.pdf">wooper.pdf</a>.</p></span></p>
<p></p>
<p>Latest stable WOOPER archives are:</p>
<blockquote>
<ul class="simple">
<li><a class="reference" href="http://downloads.sourceforge.net/ceylan/wooper-0.3.tar.bz2">wooper-0.3.tar.bz2</a></li>
<li><a class="reference" href="http://downloads.sourceforge.net/ceylan/wooper-0.3.zip">wooper-0.3.zip</a></li>
</ul>
</blockquote>
<div class="contents topic">
<p class="topic-title first"><a id="id1" name="id1"><span id="table-of-contents"></span>Table of Contents</a></p>
<ul class="auto-toc simple">
<li><a class="reference" href="#overview" id="id15" name="id15">1&nbsp;&nbsp;&nbsp;Overview</a><ul class="auto-toc">
<li><a class="reference" href="#motivations-purpose" id="id16" name="id16">1.1&nbsp;&nbsp;&nbsp;Motivations &amp; Purpose</a></li>
<li><a class="reference" href="#wooper-mode-of-operation-in-a-nutshell" id="id17" name="id17">1.2&nbsp;&nbsp;&nbsp;WOOPER Mode of Operation In A Nutshell</a></li>
<li><a class="reference" href="#example" id="id18" name="id18">1.3&nbsp;&nbsp;&nbsp;Example</a></li>
</ul>
</li>
<li><a class="reference" href="#why-adding-object-oriented-capabilities-to-erlang" id="id19" name="id19">2&nbsp;&nbsp;&nbsp;Why Adding Object-Oriented Capabilities To Erlang?</a></li>
<li><a class="reference" href="#how-to-use-wooper-detailed-description-concept-mappings" id="id20" name="id20">3&nbsp;&nbsp;&nbsp;How to Use WOOPER: Detailed Description &amp; Concept Mappings</a><ul class="auto-toc">
<li><a class="reference" href="#classes" id="id21" name="id21">3.1&nbsp;&nbsp;&nbsp;Classes</a><ul class="auto-toc">
<li><a class="reference" href="#class-names" id="id22" name="id22">3.1.1&nbsp;&nbsp;&nbsp;Class &amp; Names</a></li>
<li><a class="reference" href="#inheritance-superclasses" id="id23" name="id23">3.1.2&nbsp;&nbsp;&nbsp;Inheritance &amp; Superclasses</a></li>
</ul>
</li>
<li><a class="reference" href="#instances" id="id24" name="id24">3.2&nbsp;&nbsp;&nbsp;Instances</a><ul class="auto-toc">
<li><a class="reference" href="#instance-mapping" id="id25" name="id25">3.2.1&nbsp;&nbsp;&nbsp;Instance Mapping</a></li>
<li><a class="reference" href="#instance-state" id="id26" name="id26">3.2.2&nbsp;&nbsp;&nbsp;Instance State</a></li>
</ul>
</li>
<li><a class="reference" href="#methods" id="id27" name="id27">3.3&nbsp;&nbsp;&nbsp;Methods</a><ul class="auto-toc">
<li><a class="reference" href="#method-declaration" id="id28" name="id28">3.3.1&nbsp;&nbsp;&nbsp;Method Declaration</a></li>
<li><a class="reference" href="#method-invocation" id="id29" name="id29">3.3.2&nbsp;&nbsp;&nbsp;Method Invocation</a></li>
<li><a class="reference" href="#method-name" id="id30" name="id30">3.3.3&nbsp;&nbsp;&nbsp;Method Name</a></li>
<li><a class="reference" href="#method-parameters" id="id31" name="id31">3.3.4&nbsp;&nbsp;&nbsp;Method Parameters</a></li>
<li><a class="reference" href="#two-kinds-of-methods" id="id32" name="id32">3.3.5&nbsp;&nbsp;&nbsp;Two Kinds of Methods</a><ul class="auto-toc">
<li><a class="reference" href="#request-methods" id="id33" name="id33">3.3.5.1&nbsp;&nbsp;&nbsp;Request Methods</a></li>
<li><a class="reference" href="#oneway-methods" id="id34" name="id34">3.3.5.2&nbsp;&nbsp;&nbsp;Oneway Methods</a></li>
</ul>
</li>
<li><a class="reference" href="#method-results" id="id35" name="id35">3.3.6&nbsp;&nbsp;&nbsp;Method Results</a><ul class="auto-toc">
<li><a class="reference" href="#execution-success-wooper-result-actualresult" id="id36" name="id36">3.3.6.1&nbsp;&nbsp;&nbsp;Execution Success: <tt class="docutils literal"><span class="pre">{wooper_result,ActualResult}</span></tt></a></li>
<li><a class="reference" href="#execution-failures" id="id37" name="id37">3.3.6.2&nbsp;&nbsp;&nbsp;Execution Failures</a><ul class="auto-toc">
<li><a class="reference" href="#wooper-method-not-found" id="id38" name="id38">3.3.6.2.1&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">wooper_method_not_found</span></tt></a></li>
<li><a class="reference" href="#wooper-method-failed" id="id39" name="id39">3.3.6.2.2&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">wooper_method_failed</span></tt></a></li>
<li><a class="reference" href="#wooper-method-faulty-return" id="id40" name="id40">3.3.6.2.3&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">wooper_method_faulty_return</span></tt></a></li>
<li><a class="reference" href="#caller-side-error-management" id="id41" name="id41">3.3.6.2.4&nbsp;&nbsp;&nbsp;Caller-Side Error Management</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference" href="#method-definition" id="id42" name="id42">3.3.7&nbsp;&nbsp;&nbsp;Method Definition</a><ul class="auto-toc">
<li><a class="reference" href="#for-requests" id="id43" name="id43">3.3.7.1&nbsp;&nbsp;&nbsp;For Requests</a></li>
<li><a class="reference" href="#for-oneways" id="id44" name="id44">3.3.7.2&nbsp;&nbsp;&nbsp;For Oneways</a></li>
<li><a class="reference" href="#usefulness-of-these-two-return-macros" id="id45" name="id45">3.3.7.3&nbsp;&nbsp;&nbsp;Usefulness Of These Two Return Macros</a></li>
</ul>
</li>
<li><a class="reference" href="#self-invocation-calling-a-method-from-the-instance-itself" id="id46" name="id46">3.3.8&nbsp;&nbsp;&nbsp;Self-Invocation: Calling a Method From The Instance Itself</a></li>
</ul>
</li>
<li><a class="reference" href="#id6" id="id47" name="id47">3.4&nbsp;&nbsp;&nbsp;State Management</a><ul class="auto-toc">
<li><a class="reference" href="#modifying-state" id="id48" name="id48">3.4.1&nbsp;&nbsp;&nbsp;Modifying State</a><ul class="auto-toc">
<li><a class="reference" href="#the-setattribute-3-macro" id="id49" name="id49">3.4.1.1&nbsp;&nbsp;&nbsp;The <tt class="docutils literal"><span class="pre">setAttribute/3</span></tt> Macro</a></li>
<li><a class="reference" href="#the-removeattribute-2-macro" id="id50" name="id50">3.4.1.2&nbsp;&nbsp;&nbsp;The <tt class="docutils literal"><span class="pre">removeAttribute/2</span></tt> Macro</a></li>
</ul>
</li>
<li><a class="reference" href="#reading-state" id="id51" name="id51">3.4.2&nbsp;&nbsp;&nbsp;Reading State</a><ul class="auto-toc">
<li><a class="reference" href="#the-hasattribute-2-macro" id="id52" name="id52">3.4.2.1&nbsp;&nbsp;&nbsp;The <tt class="docutils literal"><span class="pre">hasAttribute/2</span></tt> Macro</a></li>
<li><a class="reference" href="#the-getattribute-2-macro" id="id53" name="id53">3.4.2.2&nbsp;&nbsp;&nbsp;The <tt class="docutils literal"><span class="pre">getAttribute/2</span></tt> Macro</a></li>
<li><a class="reference" href="#the-getattr-2-macro" id="id54" name="id54">3.4.2.3&nbsp;&nbsp;&nbsp;The <tt class="docutils literal"><span class="pre">getAttr/2</span></tt> Macro</a></li>
</ul>
</li>
<li><a class="reference" href="#read-modify-write-operations" id="id55" name="id55">3.4.3&nbsp;&nbsp;&nbsp;Read-Modify-Write Operations</a><ul class="auto-toc">
<li><a class="reference" href="#the-addtoattribute-3-macro" id="id56" name="id56">3.4.3.1&nbsp;&nbsp;&nbsp;The <tt class="docutils literal"><span class="pre">addToAttribute/3</span></tt> Macro</a></li>
<li><a class="reference" href="#the-substractfromattribute-3-macro" id="id57" name="id57">3.4.3.2&nbsp;&nbsp;&nbsp;The <tt class="docutils literal"><span class="pre">substractFromAttribute/3</span></tt> Macro</a></li>
<li><a class="reference" href="#the-toggleattribute-2-macro" id="id58" name="id58">3.4.3.3&nbsp;&nbsp;&nbsp;The <tt class="docutils literal"><span class="pre">toggleAttribute/2</span></tt> Macro</a></li>
<li><a class="reference" href="#the-appendtoattribute-3-macro" id="id59" name="id59">3.4.3.4&nbsp;&nbsp;&nbsp;The <tt class="docutils literal"><span class="pre">appendToAttribute/3</span></tt> Macro</a></li>
<li><a class="reference" href="#the-deletefromattribute-3-macro" id="id60" name="id60">3.4.3.5&nbsp;&nbsp;&nbsp;The <tt class="docutils literal"><span class="pre">deleteFromAttribute/3</span></tt> Macro</a></li>
<li><a class="reference" href="#the-popfromattribute-2-macro" id="id61" name="id61">3.4.3.6&nbsp;&nbsp;&nbsp;The <tt class="docutils literal"><span class="pre">popFromAttribute/2</span></tt> Macro</a></li>
<li><a class="reference" href="#the-addkeyvaluetoattribute-4-macro" id="id62" name="id62">3.4.3.7&nbsp;&nbsp;&nbsp;The <tt class="docutils literal"><span class="pre">addKeyValueToAttribute/4</span></tt> Macro</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference" href="#multiple-inheritance-polymorphism" id="id63" name="id63">3.5&nbsp;&nbsp;&nbsp;Multiple Inheritance &amp; Polymorphism</a><ul class="auto-toc">
<li><a class="reference" href="#the-general-case" id="id64" name="id64">3.5.1&nbsp;&nbsp;&nbsp;The General Case</a></li>
<li><a class="reference" href="#the-special-case-of-diamond-shaped-inheritance" id="id65" name="id65">3.5.2&nbsp;&nbsp;&nbsp;The Special Case of Diamond-Shaped Inheritance</a></li>
</ul>
</li>
<li><a class="reference" href="#life-cycle" id="id66" name="id66">3.6&nbsp;&nbsp;&nbsp;Life-Cycle</a><ul class="auto-toc">
<li><a class="reference" href="#instance-creation-new-new-link-and-construct" id="id67" name="id67">3.6.1&nbsp;&nbsp;&nbsp;Instance Creation: <tt class="docutils literal"><span class="pre">new</span></tt>/<tt class="docutils literal"><span class="pre">new_link</span></tt> And <tt class="docutils literal"><span class="pre">construct</span></tt></a><ul class="auto-toc">
<li><a class="reference" href="#role-of-a-new-construct-pair" id="id68" name="id68">3.6.1.1&nbsp;&nbsp;&nbsp;Role of a new/construct Pair</a></li>
<li><a class="reference" href="#the-various-ways-of-creating-an-instance" id="id69" name="id69">3.6.1.2&nbsp;&nbsp;&nbsp;The Various Ways of Creating An Instance</a><ul class="auto-toc">
<li><a class="reference" href="#asynchronous-new" id="id70" name="id70">3.6.1.2.1&nbsp;&nbsp;&nbsp;Asynchronous new</a></li>
<li><a class="reference" href="#synchronous-new" id="id71" name="id71">3.6.1.2.2&nbsp;&nbsp;&nbsp;Synchronous new</a></li>
<li><a class="reference" href="#timed-synchronous-new" id="id72" name="id72">3.6.1.2.3&nbsp;&nbsp;&nbsp;Timed Synchronous new</a></li>
<li><a class="reference" href="#remote-new" id="id73" name="id73">3.6.1.2.4&nbsp;&nbsp;&nbsp;Remote new</a></li>
</ul>
</li>
<li><a class="reference" href="#declaration-of-the-new-construct-pair" id="id74" name="id74">3.6.1.3&nbsp;&nbsp;&nbsp;Declaration of the new/construct Pair</a></li>
<li><a class="reference" href="#some-examples" id="id75" name="id75">3.6.1.4&nbsp;&nbsp;&nbsp;Some Examples</a></li>
<li><a class="reference" href="#definition-of-the-construct-method" id="id76" name="id76">3.6.1.5&nbsp;&nbsp;&nbsp;Definition of the <tt class="docutils literal"><span class="pre">construct</span></tt> Method</a></li>
</ul>
</li>
<li><a class="reference" href="#instance-deletion" id="id77" name="id77">3.6.2&nbsp;&nbsp;&nbsp;Instance Deletion</a><ul class="auto-toc">
<li><a class="reference" href="#automatic-chaining-of-destructors" id="id78" name="id78">3.6.2.1&nbsp;&nbsp;&nbsp;Automatic Chaining Of Destructors</a></li>
<li><a class="reference" href="#asynchronous-destructor-delete-1" id="id79" name="id79">3.6.2.2&nbsp;&nbsp;&nbsp;Asynchronous Destructor: <tt class="docutils literal"><span class="pre">delete/1</span></tt></a></li>
<li><a class="reference" href="#synchronous-destructor-synchronous-delete-1" id="id80" name="id80">3.6.2.3&nbsp;&nbsp;&nbsp;Synchronous Destructor: <tt class="docutils literal"><span class="pre">synchronous_delete/1</span></tt></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a class="reference" href="#miscellaneous-technical-points" id="id81" name="id81">4&nbsp;&nbsp;&nbsp;Miscellaneous Technical Points</a><ul class="auto-toc">
<li><a class="reference" href="#exit-messages" id="id82" name="id82">4.1&nbsp;&nbsp;&nbsp;EXIT Messages</a></li>
<li><a class="reference" href="#practical-build-hints" id="id83" name="id83">4.2&nbsp;&nbsp;&nbsp;Practical Build Hints</a></li>
<li><a class="reference" href="#similarity-with-python" id="id84" name="id84">4.3&nbsp;&nbsp;&nbsp;Similarity With Python</a></li>
</ul>
</li>
<li><a class="reference" href="#wooper-example" id="id85" name="id85">5&nbsp;&nbsp;&nbsp;WOOPER Example</a><ul class="auto-toc">
<li><a class="reference" href="#class-implementations" id="id86" name="id86">5.1&nbsp;&nbsp;&nbsp;Class implementations</a></li>
<li><a class="reference" href="#tests" id="id87" name="id87">5.2&nbsp;&nbsp;&nbsp;Tests</a></li>
</ul>
</li>
<li><a class="reference" href="#troubleshooting" id="id88" name="id88">6&nbsp;&nbsp;&nbsp;Troubleshooting</a><ul class="auto-toc">
<li><a class="reference" href="#general-case" id="id89" name="id89">6.1&nbsp;&nbsp;&nbsp;General Case</a><ul class="auto-toc">
<li><a class="reference" href="#compilation-warnings" id="id90" name="id90">6.1.1&nbsp;&nbsp;&nbsp;Compilation Warnings</a></li>
<li><a class="reference" href="#runtime-errors" id="id91" name="id91">6.1.2&nbsp;&nbsp;&nbsp;Runtime Errors</a></li>
</ul>
</li>
<li><a class="reference" href="#mismatches-in-method-call" id="id92" name="id92">6.2&nbsp;&nbsp;&nbsp;Mismatches In Method Call</a><ul class="auto-toc">
<li><a class="reference" href="#oneway-versus-request-calls" id="id93" name="id93">6.2.1&nbsp;&nbsp;&nbsp;Oneway Versus Request Calls</a></li>
<li><a class="reference" href="#list-parameter-incorrectly-specified-in-call" id="id94" name="id94">6.2.2&nbsp;&nbsp;&nbsp;List Parameter Incorrectly Specified In Call</a></li>
<li><a class="reference" href="#error-with-exit-value-undef-hashtable-new" id="id95" name="id95">6.2.3&nbsp;&nbsp;&nbsp;Error With Exit Value: <tt class="docutils literal"><span class="pre">{undef,[{hashtable,new,[..]}..</span></tt></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference" href="#current-stable-version-download" id="id96" name="id96">7&nbsp;&nbsp;&nbsp;Current Stable Version &amp; Download</a><ul class="auto-toc">
<li><a class="reference" href="#using-stable-release-archive" id="id97" name="id97">7.1&nbsp;&nbsp;&nbsp;Using Stable Release Archive</a></li>
<li><a class="reference" href="#using-cutting-edge-svn" id="id98" name="id98">7.2&nbsp;&nbsp;&nbsp;Using Cutting-Edge SVN</a></li>
</ul>
</li>
<li><a class="reference" href="#version-history-changes" id="id99" name="id99">8&nbsp;&nbsp;&nbsp;Version History &amp; Changes</a><ul class="auto-toc">
<li><a class="reference" href="#version-0-4-cutting-edge-in-svn-only" id="id100" name="id100">8.1&nbsp;&nbsp;&nbsp;Version 0.4 [cutting-edge, in SVN only]</a></li>
<li><a class="reference" href="#version-0-3-current-stable" id="id101" name="id101">8.2&nbsp;&nbsp;&nbsp;Version 0.3 [current stable]</a></li>
<li><a class="reference" href="#version-0-2" id="id102" name="id102">8.3&nbsp;&nbsp;&nbsp;Version 0.2</a></li>
<li><a class="reference" href="#version-0-1" id="id103" name="id103">8.4&nbsp;&nbsp;&nbsp;Version 0.1</a></li>
</ul>
</li>
<li><a class="reference" href="#wooper-inner-workings" id="id104" name="id104">9&nbsp;&nbsp;&nbsp;WOOPER Inner Workings</a><ul class="auto-toc">
<li><a class="reference" href="#method-virtual-table" id="id105" name="id105">9.1&nbsp;&nbsp;&nbsp;Method Virtual Table</a></li>
<li><a class="reference" href="#attribute-table" id="id106" name="id106">9.2&nbsp;&nbsp;&nbsp;Attribute Table</a></li>
</ul>
</li>
<li><a class="reference" href="#issues-planned-enhancements" id="id107" name="id107">10&nbsp;&nbsp;&nbsp;Issues &amp; Planned Enhancements</a></li>
<li><a class="reference" href="#licence" id="id108" name="id108">11&nbsp;&nbsp;&nbsp;Licence</a></li>
<li><a class="reference" href="#sources-inspirations-alternate-solutions" id="id109" name="id109">12&nbsp;&nbsp;&nbsp;Sources, Inspirations &amp; Alternate Solutions</a></li>
<li><a class="reference" href="#support" id="id110" name="id110">13&nbsp;&nbsp;&nbsp;Support</a></li>
<li><a class="reference" href="#for-wooper-developers" id="id111" name="id111">14&nbsp;&nbsp;&nbsp;For WOOPER Developers</a></li>
<li><a class="reference" href="#please-react" id="id112" name="id112">15&nbsp;&nbsp;&nbsp;Please React!</a></li>
</ul>
</div>
<p></p>
<div class="section">
<h1><a class="toc-backref" href="#id15" id="overview" name="overview">1&nbsp;&nbsp;&nbsp;Overview</a></h1>
<p>WOOPER, which stands for <em>Wrapper for Object-Oriented Programming in Erlang</em>, is an <a class="reference" href="#open-source">open source</a> lightweight layer on top of the <a class="reference" href="http://erlang.org">Erlang</a> language, which provides constructs dedicated to <a class="reference" href="http://en.wikipedia.org/wiki/Object-oriented_programming">Object-Oriented Programming</a> (OOP).</p>
<p>WOOPER is a (completely autonomous) part of the <a class="reference" href="http://ceylan.sourceforge.net">Ceylan</a> project.</p>
<div class="section">
<h2><a class="toc-backref" href="#id16" id="motivations-purpose" name="motivations-purpose">1.1&nbsp;&nbsp;&nbsp;Motivations &amp; Purpose</a></h2>
<p>Some problems may almost only be tackled efficiently thanks to an object-oriented modelling.</p>
<p>The set of code and conventions proposed here allows to benefit from all the main OOP features (including polymorphism, life cycle management, state management and multiple inheritance) directly from Erlang (which natively does not rely on the OOP paradigm), so that an object-oriented approach at the implementation level can be easily achieved, in the cases where it makes sense.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id17" id="wooper-mode-of-operation-in-a-nutshell" name="wooper-mode-of-operation-in-a-nutshell">1.2&nbsp;&nbsp;&nbsp;WOOPER Mode of Operation In A Nutshell</a></h2>
<p>The WOOPER constructs translate into Erlang ones according to the following mapping:</p>
<blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="81%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">WOOPER concept</th>
<th class="head">Corresponding Erlang mapping</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>class definition</td>
<td>module</td>
</tr>
<tr><td>instance</td>
<td>process</td>
</tr>
<tr><td>instance reference</td>
<td>process identifier (PID)</td>
</tr>
<tr><td>new operators</td>
<td>WOOPER-provided functions, making use of user-defined <tt class="docutils literal"><span class="pre">construct/N</span></tt> function</td>
</tr>
<tr><td>delete operators</td>
<td>WOOPER-provided functions, unless user-specified</td>
</tr>
<tr><td>method definition</td>
<td>module functions that respect some conventions</td>
</tr>
<tr><td>method invocation</td>
<td>sending of appropriate inter-process messages</td>
</tr>
<tr><td>method look-up</td>
<td>class-specific virtual table taking into account inheritance transparently</td>
</tr>
<tr><td>instance state</td>
<td>instance-specific hashtable kept by the instance-specific WOOPER tail-recursive infinite loop</td>
</tr>
<tr><td>instance attributes</td>
<td>key/value pairs stored in the instance hashtable</td>
</tr>
<tr><td>class (static) method</td>
<td>module function</td>
</tr>
</tbody>
</table>
</blockquote>
<p>In practice, developing a class with WOOPER just involves including the <a class="reference" href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/src/wooper.hrl?view=markup">wooper.hrl</a> header file and respecting the WOOPER conventions detailed below.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id18" id="example" name="example">1.3&nbsp;&nbsp;&nbsp;Example</a></h2>
<p>Here is a simple example of how WOOPER instances can be managed. This shows <tt class="docutils literal"><span class="pre">new/delete</span></tt> operators, method calling (both request and oneway), and inheritance (a cat is here a viviparous mammal, as defined in the <a class="reference" href="#example">example</a> below):</p>
<pre class="literal-block">
-module(class_Cat).

% Determines what are the mother classes of this class (if any):
-define( wooper_superclasses, [class_Mammal,class_ViviparousBeing] ).

% Parameters taken by the constructor ('construct').
% They are here the ones of the Mammal mother class
% (the viviparous being constructor does not need any parameter),
% plus cat-specific whisker color.
% These are all the class-specific data needing
% to be specified to the constructor:
-define(wooper_construct_parameters,Age,Gender,FurColor,WhiskerColor).

% Declaring all variations of WOOPER standard life-cycle operations:
% (template pasted, just two replacements performed to update arities)
-define( wooper_construct_export, new/4, new_link/4,
	synchronous_new/4, synchronous_new_link/4,
	synchronous_timed_new/4, synchronous_timed_new_link/4,
	remote_new/5, remote_new_link/5, remote_synchronous_new/5,
	remote_synchronous_new_link/5, remote_synchronous_timed_new/5,
	remote_synchronous_timed_new_link/5, construct/5 ).

% Method declarations.
-define( wooper_method_export, getTeatCount/1, canEat/2,
	  getWhiskerColor/1 ).

% Allows to define WOOPER base variables and methods for that class:
-include(&quot;wooper.hrl&quot;).

% Constructs a new Cat.
construct( State, ?wooper_construct_parameters ) -&gt;
	% First the direct mother classes:
	MammalState = class_Mammal:construct( State, Age, Gender, FurColor ),
	ViviparousMammalState = class_ViviparousBeing:construct( MammalState ),
	% Then the class-specific attributes:
	?setAttribute( ViviparousMammalState, whisker_color, WhiskerColor ).

% No guarantee on biological fidelity:
getTeatCount(State) -&gt;
	?wooper_return_state_result( State, 6 ).

% Cats are supposed carnivorous though:
canEat(State,soup) -&gt;
	?wooper_return_state_result( State, true );

canEat(State,croquette) -&gt;
	?wooper_return_state_result( State, true );

canEat(State,meat) -&gt;
	?wooper_return_state_result( State, true );

canEat(State,_) -&gt;
	?wooper_return_state_result( State, false ).

% This method is cat-specific:
getWhiskerColor(State)-&gt;
	?wooper_return_state_result( State, ?getAttr(whisker_color) ).
</pre>
<p>Straightforward, isn't it? We will discuss it in-depth though.</p>
<p>To test this class, just extract your WOOPER archive, like in:</p>
<pre class="literal-block">
tar xvjf wooper-x.y.tar.bz2
cd wooper-x.y
</pre>
<p>and run, from the root of this archive (the <tt class="docutils literal"><span class="pre">wooper-x.y</span></tt> directory):</p>
<pre class="literal-block">
make all &amp;&amp; cd wooper/examples &amp;&amp; make class_Cat_run
</pre>
<p>Then, in the <tt class="docutils literal"><span class="pre">examples</span></tt> directory, the test defined in <tt class="docutils literal"><span class="pre">class_Cat_test.erl</span></tt> should run against the class defined in <tt class="docutils literal"><span class="pre">class_Cat.erl</span></tt>; no error should be detected:</p>
<pre class="literal-block">
[..]
Deleting cat &lt;0.41.0&gt;! (overridden destructor)
Deleting mammal &lt;0.41.0&gt;! (overridden destructor)
--&gt; This cat could be created and be synchronously deleted, as expected.
--&gt; End of test for module class_Cat.
</pre>
<p></p>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id19" id="why-adding-object-oriented-capabilities-to-erlang" name="why-adding-object-oriented-capabilities-to-erlang">2&nbsp;&nbsp;&nbsp;Why Adding Object-Oriented Capabilities To Erlang?</a></h1>
<p>Although applying blindly OOP with languages based on other paradigms (Erlang ones are functional and concurrent, the language is not specifically targeting OOP) is a common mistake, there are some problems that may be deemed inherently &quot;object-oriented&quot;, i.e. that cannot be effectively modelled without encapsulated abstractions sharing behaviours.</p>
<p>Examples of this kind of systems are multi-agent simulations. If they often need massive concurrency, robustness, distribution, etc. (Erlang is particularly suitable for that), the various actor types have also often to share numerous states and behaviours, while being able to specialise them on a per-type basis.</p>
<p>The <a class="reference" href="#example">example</a> chosen here is a simulation of the interacting lives of numerous animals from various species. Obviously, they have to share behaviours (ex: all ovoviviparous beings may lay eggs, all creatures can live and die, all have an age, etc.), which cannot be mapped easily (read: automatically) to Erlang concepts without adding some generic constructs.</p>
<p>WOOPER, which stands for <em>Wrapper for OOP in Erlang</em>, is a lightweight yet effective (performance-wise, but also regarding the overall developing efforts) means of making these constructs available, notably in terms of state management and multiple inheritance.</p>
<p>The same programs could be implemented without such OOP constructs, but at the expense of way too much manually-crafted specific (per-class) code. This process would be tedious, error-prone, and most often the result could hardly be maintained.</p>
<p></p>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id20" id="how-to-use-wooper-detailed-description-concept-mappings" name="how-to-use-wooper-detailed-description-concept-mappings">3&nbsp;&nbsp;&nbsp;How to Use WOOPER: Detailed Description &amp; Concept Mappings</a></h1>
<div class="contents local topic">
<ul class="auto-toc simple">
<li><a class="reference" href="#classes" id="id113" name="id113">3.1&nbsp;&nbsp;&nbsp;Classes</a><ul class="auto-toc">
<li><a class="reference" href="#class-names" id="id114" name="id114">3.1.1&nbsp;&nbsp;&nbsp;Class &amp; Names</a></li>
<li><a class="reference" href="#inheritance-superclasses" id="id115" name="id115">3.1.2&nbsp;&nbsp;&nbsp;Inheritance &amp; Superclasses</a></li>
</ul>
</li>
<li><a class="reference" href="#instances" id="id116" name="id116">3.2&nbsp;&nbsp;&nbsp;Instances</a><ul class="auto-toc">
<li><a class="reference" href="#instance-mapping" id="id117" name="id117">3.2.1&nbsp;&nbsp;&nbsp;Instance Mapping</a></li>
<li><a class="reference" href="#instance-state" id="id118" name="id118">3.2.2&nbsp;&nbsp;&nbsp;Instance State</a></li>
</ul>
</li>
<li><a class="reference" href="#methods" id="id119" name="id119">3.3&nbsp;&nbsp;&nbsp;Methods</a><ul class="auto-toc">
<li><a class="reference" href="#method-declaration" id="id120" name="id120">3.3.1&nbsp;&nbsp;&nbsp;Method Declaration</a></li>
<li><a class="reference" href="#method-invocation" id="id121" name="id121">3.3.2&nbsp;&nbsp;&nbsp;Method Invocation</a></li>
<li><a class="reference" href="#method-name" id="id122" name="id122">3.3.3&nbsp;&nbsp;&nbsp;Method Name</a></li>
<li><a class="reference" href="#method-parameters" id="id123" name="id123">3.3.4&nbsp;&nbsp;&nbsp;Method Parameters</a></li>
<li><a class="reference" href="#two-kinds-of-methods" id="id124" name="id124">3.3.5&nbsp;&nbsp;&nbsp;Two Kinds of Methods</a></li>
<li><a class="reference" href="#method-results" id="id125" name="id125">3.3.6&nbsp;&nbsp;&nbsp;Method Results</a></li>
<li><a class="reference" href="#method-definition" id="id126" name="id126">3.3.7&nbsp;&nbsp;&nbsp;Method Definition</a></li>
<li><a class="reference" href="#self-invocation-calling-a-method-from-the-instance-itself" id="id127" name="id127">3.3.8&nbsp;&nbsp;&nbsp;Self-Invocation: Calling a Method From The Instance Itself</a></li>
</ul>
</li>
<li><a class="reference" href="#id6" id="id128" name="id128">3.4&nbsp;&nbsp;&nbsp;State Management</a><ul class="auto-toc">
<li><a class="reference" href="#modifying-state" id="id129" name="id129">3.4.1&nbsp;&nbsp;&nbsp;Modifying State</a></li>
<li><a class="reference" href="#reading-state" id="id130" name="id130">3.4.2&nbsp;&nbsp;&nbsp;Reading State</a></li>
<li><a class="reference" href="#read-modify-write-operations" id="id131" name="id131">3.4.3&nbsp;&nbsp;&nbsp;Read-Modify-Write Operations</a></li>
</ul>
</li>
<li><a class="reference" href="#multiple-inheritance-polymorphism" id="id132" name="id132">3.5&nbsp;&nbsp;&nbsp;Multiple Inheritance &amp; Polymorphism</a><ul class="auto-toc">
<li><a class="reference" href="#the-general-case" id="id133" name="id133">3.5.1&nbsp;&nbsp;&nbsp;The General Case</a></li>
<li><a class="reference" href="#the-special-case-of-diamond-shaped-inheritance" id="id134" name="id134">3.5.2&nbsp;&nbsp;&nbsp;The Special Case of Diamond-Shaped Inheritance</a></li>
</ul>
</li>
<li><a class="reference" href="#life-cycle" id="id135" name="id135">3.6&nbsp;&nbsp;&nbsp;Life-Cycle</a><ul class="auto-toc">
<li><a class="reference" href="#instance-creation-new-new-link-and-construct" id="id136" name="id136">3.6.1&nbsp;&nbsp;&nbsp;Instance Creation: <tt class="docutils literal"><span class="pre">new</span></tt>/<tt class="docutils literal"><span class="pre">new_link</span></tt> And <tt class="docutils literal"><span class="pre">construct</span></tt></a></li>
<li><a class="reference" href="#instance-deletion" id="id137" name="id137">3.6.2&nbsp;&nbsp;&nbsp;Instance Deletion</a></li>
</ul>
</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id113" id="classes" name="classes">3.1&nbsp;&nbsp;&nbsp;Classes</a></h2>
<div class="section">
<h3><a class="toc-backref" href="#id114" id="class-names" name="class-names">3.1.1&nbsp;&nbsp;&nbsp;Class &amp; Names</a></h3>
<p>A class is a blueprint to create objects, a common scheme describing the behaviour and the internal data types of its instances, i.e. the attributes and methods that the created objects all share.</p>
<p>With WOOPER each class must have a unique name.</p>
<p>To allow for <strong>encapsulation</strong>, a WOOPER class is mapped to an Erlang module, whose name is by convention made from the <tt class="docutils literal"><span class="pre">class_</span></tt> prefix followed by the class name, in the so-called <a class="reference" href="http://en.wikipedia.org/wiki/CamelCase">CamelCase</a>: all words are spelled in lower-case except their first letter, and there are no separators between words, like in: <em>ThisIsAnExample</em>.</p>
<p>For example, a class modeling a cat should translate into an Erlang module named <tt class="docutils literal"><span class="pre">class_Cat</span></tt>, thus in a file named <tt class="docutils literal"><span class="pre">class_Cat.erl</span></tt>. At the top of this file, the corresponding module would be therefore declared with: <tt class="docutils literal"><span class="pre">-module(class_Cat).</span></tt>.</p>
<p>The class name can be obtained through its <tt class="docutils literal"><span class="pre">get_class_name</span></tt> WOOPER-defined static method:</p>
<pre class="literal-block">
&gt; class_Cat:get_class_name().
class_Cat
</pre>
<p>Note that a static method (i.e. a class method that does not apply to any specific instance) of a class X is nothing more than an Erlang function exported from the corresponding <tt class="docutils literal"><span class="pre">class_X</span></tt> module: all exported functions can be seen as static methods.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id115" id="inheritance-superclasses" name="inheritance-superclasses">3.1.2&nbsp;&nbsp;&nbsp;Inheritance &amp; Superclasses</a></h3>
<p>A WOOPER class can inherit from other classes, in this case the behaviour and the internal data defined in the mother classes are available by default to this child class.</p>
<p>Being in a <strong>multiple inheritance</strong> context, a given class can have any number (<tt class="docutils literal"><span class="pre">[0..n]</span></tt>) of direct mother classes, which themselves may have mother classes, and so on.</p>
<p>This is declared in WOOPER thanks to the <tt class="docutils literal"><span class="pre">wooper_superclasses</span></tt> define. For example, a class with no mother class should specify, once having declared its module, <tt class="docutils literal"><span class="pre">-define(wooper_superclasses,[]).</span></tt>.</p>
<p>As for our cat, this animal could be modelled both as a mammal (itself a specialised creature) and a viviparous being <a class="footnote-reference" href="#id3" id="id2" name="id2">[1]</a>. Hence its mother classes could be described as: <tt class="docutils literal"><span class="pre">-define(wooper_superclasses,[class_Mammal,</span> <span class="pre">class_ViviparousBeing]).</span></tt></p>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2" name="id3">[1]</a></td><td>Neither of them is a subset of the other, these are mostly unrelated concepts; at least in the context of that example!</td></tr>
</tbody>
</table>
<p>The superclasses (direct mother classes) of a given class can be known thanks to its <tt class="docutils literal"><span class="pre">get_superclasses</span></tt> static method:</p>
<pre class="literal-block">
&gt; class_Cat:get_superclasses().
[class_Mammal,class_ViviparousBeing]
</pre>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id116" id="instances" name="instances">3.2&nbsp;&nbsp;&nbsp;Instances</a></h2>
<div class="section">
<h3><a class="toc-backref" href="#id117" id="instance-mapping" name="instance-mapping">3.2.1&nbsp;&nbsp;&nbsp;Instance Mapping</a></h3>
<p>With WOOPER, which focuses on multi-agent systems, all <strong>instances</strong> of a class are mapped to Erlang processes (one WOOPER instance is exactly one Erlang process).</p>
<p>They are therefore, in UML language, <em>active objects</em> (each has its own thread of execution, they may apparently &quot;live&quot; simultaneously).</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id118" id="instance-state" name="instance-state">3.2.2&nbsp;&nbsp;&nbsp;Instance State</a></h3>
<p>Another need is to rely on <strong>state management</strong> and <strong>encapsulation</strong>: each instance should be stateful, have its state private, and be able to inherit automatically the data members defined by its mother classes.</p>
<p>In WOOPER, this is obtained thanks to a per-instance associative table, whose keys are the names of attributes and whose values are the attribute values. This will be detailed in the <a class="reference" href="#state-management">state management</a> section.</p>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id119" id="methods" name="methods">3.3&nbsp;&nbsp;&nbsp;Methods</a></h2>
<p>Instances may declare <strong>methods</strong> that can be publicly called, whether locally or remotely (i.e. on other networked computers, like with RMI or with CORBA). Distribution is seamlessly managed thanks to Erlang.</p>
<p>Methods (either inherited or defined directly in the class) are mapped to specific Erlang functions, triggered by Erlang messages.</p>
<p>For example, our cat may define following methods:</p>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">canEat</span></tt>, taking one parameter specifying the type of food, and returning whether the cat can eat that kind of food. The implementation should be cat-specific here, whereas the method signature is shared by all beings</li>
<li><tt class="docutils literal"><span class="pre">getWhiskersColor</span></tt>, taking no parameter, returning the color of its whiskers. This is indeed a purely cat-specific method</li>
<li><tt class="docutils literal"><span class="pre">declareBirthday</span></tt>, incrementing the age of our cat, not taking any parameter nor returning anything. It will be therefore be implemented as a oneway call (i.e. not returning any result to the caller, hence not even needing to know it), only interesting for its effect on the cat state: here, making it one year older</li>
</ul>
</blockquote>
<p>Declaring a birthday is not cat-specific, nor mammal-specific: we can consider it being creature-specific. Cat instances should then inherit this method, preferably indirectly from the <tt class="docutils literal"><span class="pre">class_Creature</span></tt> class, in all cases without having to specify anything, since the <tt class="docutils literal"><span class="pre">wooper_superclasses</span></tt> define already implies it.</p>
<p>We will discuss the definition of these methods later, but for the moment let's determine their signatures and declarations, and how we are expected to call them.</p>
<div class="section">
<h3><a class="toc-backref" href="#id120" id="method-declaration" name="method-declaration">3.3.1&nbsp;&nbsp;&nbsp;Method Declaration</a></h3>
<p>The cat-specific methods are to be declared:</p>
<blockquote>
<ul class="simple">
<li>in the <tt class="docutils literal"><span class="pre">class_Cat</span></tt></li>
<li>thanks to the <tt class="docutils literal"><span class="pre">wooper_method_export</span></tt> clause</li>
</ul>
</blockquote>
<p>Their arity should be equal to the number of parameters they should be called with, plus one.</p>
<p>The additional parameter is an implicit one (automatically managed by WOOPER), corresponding to the state of the instance.</p>
<p>This <tt class="docutils literal"><span class="pre">State</span></tt> variable defined by WOOPER can be somehow compared to the <tt class="docutils literal"><span class="pre">self</span></tt> parameter of Python, or to the <tt class="docutils literal"><span class="pre">this</span></tt> hidden pointer of C++. That state is automatically kept by WOOPER instances in their main loop, and automatically prepended to the parameters of incoming method calls.</p>
<p>In our example, the declarations would result in: <tt class="docutils literal"><span class="pre">-define(</span> <span class="pre">wooper_method_export,</span> <span class="pre">canEat/2,</span> <span class="pre">getWhiskersColor/1</span> <span class="pre">).</span></tt>.</p>
<p>As <tt class="docutils literal"><span class="pre">declareBirthday</span></tt> will be inherited but not overridden, no need to declare it.</p>
<p>Some method names are reserved for WOOPER: no user method should have a name starting by <tt class="docutils literal"><span class="pre">wooper</span></tt>.</p>
<p>The complete list of reserved function names that do not start with the <tt class="docutils literal"><span class="pre">wooper_</span></tt> prefix is:</p>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">get_class_name</span></tt></li>
<li><tt class="docutils literal"><span class="pre">get_superclasses</span></tt></li>
<li><tt class="docutils literal"><span class="pre">executeRequest</span></tt></li>
<li><tt class="docutils literal"><span class="pre">executeOneway</span></tt></li>
<li><tt class="docutils literal"><span class="pre">delete_any_process_in</span></tt></li>
<li><tt class="docutils literal"><span class="pre">is_wooper_debug</span></tt></li>
</ul>
</blockquote>
<p>They are reserved for all arities.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id121" id="method-invocation" name="method-invocation">3.3.2&nbsp;&nbsp;&nbsp;Method Invocation</a></h3>
<p>Let's suppose that the <tt class="docutils literal"><span class="pre">MyCat</span></tt> variable designates an instance of <tt class="docutils literal"><span class="pre">class_Cat</span></tt>. Then this <tt class="docutils literal"><span class="pre">MyCat</span></tt> reference is actually just the PID of the Erlang process corresponding to this instance.</p>
<p>All methods, either defined directly by the actual class or inherited, are to be called thanks to a proper Erlang message.</p>
<p>When the caller needs a result to be sent back, it must specify to the instance what is its PID (i.e. the caller PID), so that the instance knows to whom the answer should be sent.</p>
<p>Therefore the <tt class="docutils literal"><span class="pre">self()</span></tt> parameter in the call tuples below corresponds to the PID <em>of the caller</em>: <tt class="docutils literal"><span class="pre">MyCat</span></tt> is the PID of the target instance.</p>
<p>The three methods previously discussed would indeed be called that way:</p>
<pre class="literal-block">
% Calling the canEat request of our cat instance:
MyCat ! {canEat,soup,self()},
receive
	{wooper_result,true} -&gt;
				 io:format( &quot;This cat likes soup!!!&quot; );

	{wooper_result,false} -&gt;
				 io:format( &quot;This cat does not seem omnivorous.&quot; )
end,

% A parameter-less request:
MyCat ! {getWhiskersColor,[],self()},
receive
	{wooper_result,white} -&gt;
				 io:format( &quot;This cat has normal whiskers.&quot; );

	{wooper_result,blue} -&gt;
				 io:format( &quot;What a weird cat...&quot; )
end,

% A parameter-less oneway:
MyCat ! declareBirthday.
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id122" id="method-name" name="method-name">3.3.3&nbsp;&nbsp;&nbsp;Method Name</a></h3>
<p>Methods are designated by their atom name, as declared in the <tt class="docutils literal"><span class="pre">wooper_method_export</span></tt> clause of the class in the inheritance tree that defines them.</p>
<p>The method name is always the first information given in the method call tuple.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id123" id="method-parameters" name="method-parameters">3.3.4&nbsp;&nbsp;&nbsp;Method Parameters</a></h3>
<p>As detailed below, there are:</p>
<blockquote>
<ul class="simple">
<li><em>requests</em> methods: they perform some processing and then return a result to the caller</li>
<li><em>oneway</em> methods: they only change the state of the instance, with no reply being sent back</li>
</ul>
</blockquote>
<p>Both can take any number of parameters, including none. The <strong>marshalling</strong> of these parameters and, if relevant, of returned values is performed automatically by Erlang.</p>
<p>Parameters are to be specified in a (possibly empty) list, as second element of the call tuple.</p>
<p>If only one parameter is needed, the list can be omitted, and the parameter can be directly specified: <tt class="docutils literal"><span class="pre">Me</span> <span class="pre">!</span> <span class="pre">{setAge,31}.</span></tt> works just as well as <tt class="docutils literal"><span class="pre">Me</span> <span class="pre">!</span> <span class="pre">{setAge,[31]}.</span></tt>.</p>
<div class="note">
<p class="first admonition-title"><a id="single-method-parameter-is-a-list" name="single-method-parameter-is-a-list">Note</a></p>
<p>This cannot apply if the unique parameter is a list, as this would be ambiguous.</p>
<p>For example: <tt class="docutils literal"><span class="pre">Foods</span> <span class="pre">=</span> <span class="pre">[meat,soup,croquette],</span> <span class="pre">MyCat</span> <span class="pre">!</span> <span class="pre">{setFavoriteFoods,Foods}</span></tt> would result in a call to <tt class="docutils literal"><span class="pre">setFavoriteFoods/4</span></tt>, i.e. a call to <tt class="docutils literal"><span class="pre">setFavoriteFoods(State,meat,soup,croquette)</span></tt>, whereas the intent of the programmer is probably to call a <tt class="docutils literal"><span class="pre">setFavoriteFoods/2</span></tt> method like <tt class="docutils literal"><span class="pre">setFavoriteFoods(State,Foods)</span> <span class="pre">when</span> <span class="pre">is_list(Foods)</span> <span class="pre">-&gt;</span> <span class="pre">[..]</span></tt>.</p>
<p class="last">The proper call would then be <tt class="docutils literal"><span class="pre">MyCat</span> <span class="pre">!</span> <span class="pre">{setFavoriteFoods,[Foods]}</span></tt>, i.e. the parameter list should be used, it would then contain only one element, the food list, whose content would therefore be doubly enclosed.</p>
</div>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id124" id="two-kinds-of-methods" name="two-kinds-of-methods">3.3.5&nbsp;&nbsp;&nbsp;Two Kinds of Methods</a></h3>
<div class="section">
<h4><a class="toc-backref" href="#id33" id="request-methods" name="request-methods">3.3.5.1&nbsp;&nbsp;&nbsp;Request Methods</a></h4>
<p>For an instance to be able to send an answer to a <strong>request</strong> triggered by a caller, of course that instance needs to know the caller PID.</p>
<p>Therefore requests have to specify, as the third element of the call tuple, an additional information: the PID to which the answer should be sent, which is almost always the caller (hence the <tt class="docutils literal"><span class="pre">self()</span></tt> in the actual calls).</p>
<p>So these three potential information (request name, parameters, reference of the sender, i.e. an atom, usually a list, and a PID) are gathered in a tuple sent as a message: <tt class="docutils literal"><span class="pre">{request_name,[Arg1,Arg2,..],self()}</span></tt>.</p>
<p>If only one parameter is to be sent, and if that parameter is not a list, then this can become <tt class="docutils literal"><span class="pre">{request_name,Arg,self()}</span></tt>.</p>
<p>For example: <tt class="docutils literal"><span class="pre">MyCat</span> <span class="pre">!</span> <span class="pre">{getAge,[],self()}</span></tt> or <tt class="docutils literal"><span class="pre">MyCalculator</span> <span class="pre">!</span> <span class="pre">{sum,[1,2,4],self()}</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">receive</span></tt> should then be used by the caller to retrieve the request result, like in:</p>
<pre class="literal-block">
MyPoint ! {getCoordinates,[],self()},
receive
				 {wooper_result,[X,Y]} -&gt;
								 [...];
				 % Could be left out to ignore errors.
				 % Otherwise one might prefer making this caller block:
				 Error -&gt;
								 [...]
end,
</pre>
</div>
<div class="section">
<h4><a class="toc-backref" href="#id34" id="oneway-methods" name="oneway-methods">3.3.5.2&nbsp;&nbsp;&nbsp;Oneway Methods</a></h4>
<p>When calling <strong>oneway methods</strong>, the caller does not have to specify its PID, as no result is expected to be returned back to it.</p>
<p>If ever the caller sends by mistake its PID nevertheless, a warning would be sent back to it, the atom <tt class="docutils literal"><span class="pre">wooper_method_returns_void</span></tt> instead of <tt class="docutils literal"><span class="pre">{wooper_result,Result}</span></tt>.</p>
<p>The proper way of calling a oneway method is to send to it an Erlang message  that is:</p>
<blockquote>
<ul class="simple">
<li>either a pair, i.e. a 2-element tuple (therefore with no PID specified): <tt class="docutils literal"><span class="pre">{oneway_name,[Arg1,Arg2,..]}</span></tt> or <tt class="docutils literal"><span class="pre">{oneway_name,Arg}</span></tt> if <tt class="docutils literal"><span class="pre">Arg</span></tt> is not a list. For example: <tt class="docutils literal"><span class="pre">MyPoint</span> <span class="pre">!</span> <span class="pre">{setCoordinates,[14,6]}</span></tt> or <tt class="docutils literal"><span class="pre">MyCat</span> <span class="pre">!</span> <span class="pre">{setAge,5}</span></tt></li>
<li>or, if the oneway do not take any parameter, just the atom <tt class="docutils literal"><span class="pre">oneway_name</span></tt>. For example: <tt class="docutils literal"><span class="pre">MyCat</span> <span class="pre">!</span> <span class="pre">declareBirthday</span></tt></li>
</ul>
</blockquote>
<p>No return should be expected (the called instance does not even know the PID of the caller), so no receive should be attempted on the caller side.</p>
<p>Due to the nature of oneways, if an error occurs instance-side during the call, the caller will never be notified of it.</p>
<p>However, to help the debugging, an error message is then logged (using <tt class="docutils literal"><span class="pre">error_logger:error_msg</span></tt>) and the actual error message, the one that would be sent back to the caller if the method was a request, is given to <tt class="docutils literal"><span class="pre">erlang:exit</span></tt> instead.</p>
</div>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id125" id="method-results" name="method-results">3.3.6&nbsp;&nbsp;&nbsp;Method Results</a></h3>
<div class="section">
<h4><a class="toc-backref" href="#id36" id="execution-success-wooper-result-actualresult" name="execution-success-wooper-result-actualresult">3.3.6.1&nbsp;&nbsp;&nbsp;Execution Success: <tt class="docutils literal"><span class="pre">{wooper_result,ActualResult}</span></tt></a></h4>
<p>If the execution of a method succeeded, and if it is a request (not a oneway, which would not return anything), then <tt class="docutils literal"><span class="pre">{wooper_result,ActualResult}</span></tt> will be sent back.</p>
<p>Otherwise one of the following error messages will be emitted.</p>
</div>
<div class="section">
<h4><a class="toc-backref" href="#id37" id="execution-failures" name="execution-failures">3.3.6.2&nbsp;&nbsp;&nbsp;Execution Failures</a></h4>
<p>When the execution of a method fails, three main error results can be returned.</p>
<p>A summary could be:</p>
<table border="1" class="docutils">
<colgroup>
<col width="43%" />
<col width="35%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Error Result</th>
<th class="head">Interpretation</th>
<th class="head">Guilty</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal"><span class="pre">wooper_method_not_found</span></tt></td>
<td>No such method exists in
the target class.</td>
<td>Caller</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">wooper_method_failed</span></tt></td>
<td>Method triggered a runtime
error (it has a bug).</td>
<td>Called instance</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">wooper_method_faulty_return</span></tt></td>
<td>Method does not respect
the WOOPER return
convention.</td>
<td>Called instance</td>
</tr>
</tbody>
</table>
<div class="section">
<h5><a class="toc-backref" href="#id38" id="wooper-method-not-found" name="wooper-method-not-found">3.3.6.2.1&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">wooper_method_not_found</span></tt></a></h5>
<p>The corresponding error message is <tt class="docutils literal"><span class="pre">{wooper_method_not_found,</span> <span class="pre">InstancePid,</span> <span class="pre">Classname,</span> <span class="pre">MethodName,</span> <span class="pre">MethodArity,</span> <span class="pre">ListOfActualParameters}</span></tt>.</p>
<p>For example <tt class="docutils literal"><span class="pre">{wooper_method_not_found,</span> <span class="pre">&lt;0.30.0&gt;,</span> <span class="pre">class_Cat,</span> <span class="pre">layEggs,</span> <span class="pre">2,</span> <span class="pre">...}</span></tt>.</p>
<p>Note that <tt class="docutils literal"><span class="pre">MethodArity</span></tt> counts the implied state parameter (that will be discussed later), i.e. here <tt class="docutils literal"><span class="pre">layEggs/2</span></tt> might be defined as <tt class="docutils literal"><span class="pre">layEggs(State,NumberOfNewEggs)</span> <span class="pre">-&gt;</span> <span class="pre">[...]</span></tt>.</p>
<p>This error occurs whenever a called method could not be found in the whole inheritance graph of the target class. It means this method is not implemented, at least not with the deduced arity.</p>
<p>More precisely, when a message <tt class="docutils literal"><span class="pre">{method_name,[Arg1,Arg2,..,Argn]...}</span></tt> (request or oneway) is received, <tt class="docutils literal"><span class="pre">method_name/n+1</span></tt> has be to called: WOOPER tries to find <tt class="docutils literal"><span class="pre">method_name(State,Arg1,..,Argn)</span></tt>, and the method name and arity must match.</p>
<p>If no method could be found, the <tt class="docutils literal"><span class="pre">wooper_method_not_found</span></tt> atom is returned (if the method is a request, otherwise the error is logged), and the object state will not change, nor the instance will crash, as this error is deemed a caller-side one (i.e. the instance has a priori nothing to do with the error).</p>
</div>
<div class="section">
<h5><a class="toc-backref" href="#id39" id="wooper-method-failed" name="wooper-method-failed">3.3.6.2.2&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">wooper_method_failed</span></tt></a></h5>
<p>The corresponding error message is <tt class="docutils literal"><span class="pre">{wooper_method_failed,</span> <span class="pre">InstancePid,</span> <span class="pre">Classname,</span> <span class="pre">MethodName,</span> <span class="pre">MethodArity,</span> <span class="pre">ListOfActualParameters,</span> <span class="pre">ErrorTerm}</span></tt>.</p>
<p>For example, <tt class="docutils literal"><span class="pre">{wooper_method_failed,</span> <span class="pre">&lt;0.30.0&gt;,</span> <span class="pre">class_Cat,</span> <span class="pre">myCrashingMethod,</span> <span class="pre">1,</span> <span class="pre">[],</span> <span class="pre">{{badmatch,create_bug},</span> <span class="pre">[..]]}</span></tt>.</p>
<p>If the exit message sent by the method specifies a PID, it is prepended to ErrorTerm.</p>
<p>Such a method error means there is a runtime failure, it is deemed a instance-side issue (the caller should not be responsible for it), thus the instance process logs that error, sends an error term to the caller (if and only if it is a request), and then exits with the same error term.</p>
</div>
<div class="section">
<h5><a class="toc-backref" href="#id40" id="wooper-method-faulty-return" name="wooper-method-faulty-return">3.3.6.2.3&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">wooper_method_faulty_return</span></tt></a></h5>
<p>The corresponding error message is <tt class="docutils literal"><span class="pre">{wooper_method_faulty_return,</span> <span class="pre">InstancePid,</span> <span class="pre">Classname,</span> <span class="pre">MethodName,</span> <span class="pre">MethodArity,</span> <span class="pre">ListOfActualParameters,</span> <span class="pre">ActualReturn}</span></tt>.</p>
<p>For example, <tt class="docutils literal"><span class="pre">{wooper_method_faulty_return,</span> <span class="pre">&lt;0.30.0&gt;,</span> <span class="pre">class_Cat,</span> <span class="pre">myFaultyMethod,</span> <span class="pre">1,</span> <span class="pre">[],</span> <span class="pre">[{{state_holder,..]}</span></tt>.</p>
<p>This error occurs when no other error matched (this is a catch-all case).</p>
<p>The main reason for this to happen is when debug mode is set and when a method implementation did not respect the expected method return convention (neither <tt class="docutils literal"><span class="pre">wooper_return_state_result</span></tt> nor <tt class="docutils literal"><span class="pre">wooper_return_state_only</span></tt> used).</p>
<p>It means the method is not implemented correctly (it has a bug), or that it was not (re)compiled with the proper debug mode, i.e. the one the caller was compiled with.</p>
<p>This is an instance-side failure (the caller has no responsibility for that), thus the instance process logs that error, sends an error term to the caller (if and only if it is a request), and then exits with the same error term.</p>
</div>
<div class="section">
<h5><a class="toc-backref" href="#id41" id="caller-side-error-management" name="caller-side-error-management">3.3.6.2.4&nbsp;&nbsp;&nbsp;Caller-Side Error Management</a></h5>
<p>As we can see, errors can be better discriminated if needed, on the caller side.
Therefore one could make use of that information, as in:</p>
<pre class="literal-block">
MyPoint ! {getCoordinates,[],self()},
receive
	{wooper_result, [X,Y] } -&gt;
				 [...];
	{wooper_method_not_found, Pid, Class, Method, Arity, Params} -&gt;
				 [...];
	{wooper_method_failed, Pid, Class, Method, Arity, Params, ErrorTerm} -&gt;
				 [...];
	% Error term can be a tuple {Pid,Error} as well, depending on the exit:
	{wooper_method_failed, Pid, Class, Method, Arity, Params, {Pid,Error}} -&gt;
				 [...];
	{wooper_method_faulty_return, Pid, Class, Method, Arity, Params, UnexpectedTerm} -&gt;
				 [...];
	wooper_method_returns_void -&gt;
				 [...];
	OtherError -&gt;
				 % Should never happen:
				 [...]
end.
</pre>
<p>However defensive development is not really favoured in Erlang, one may let the caller crash on unexpected return instead. Therefore generally one may rely simply on matching the message sent in case of success <a class="footnote-reference" href="#id5" id="id4" name="id4">[2]</a>:</p>
<pre class="literal-block">
MyPoint ! {getCoordinates,[],self()},
receive
	{wooper_result, [X,Y] } -&gt;
				 [...]
end.
</pre>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4" name="id5">[2]</a></td><td>Then, in case of failure, the method call will become blocking.</td></tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id126" id="method-definition" name="method-definition">3.3.7&nbsp;&nbsp;&nbsp;Method Definition</a></h3>
<p>Here we reverse the point of view: instead of <strong>calling</strong> a method, we are in the process of <strong>implementing</strong> a callable one.</p>
<p>A method signature has always for first parameter the state of the instance, for example: <tt class="docutils literal"><span class="pre">getAge(State)</span> <span class="pre">-&gt;</span> <span class="pre">[..]</span></tt>, or <tt class="docutils literal"><span class="pre">getCoordinate(State,Number)</span> <span class="pre">-&gt;</span> <span class="pre">[..]</span></tt>.</p>
<p>For the sake of clarity, this variable should preferably always be named <tt class="docutils literal"><span class="pre">State</span></tt>.</p>
<p>A method must always return at least the newer instance state, even if the state did not change.</p>
<p>In this case the initial state parameter is directly returned, as is:</p>
<pre class="literal-block">
getWhiskerColor(State) -&gt;
	?wooper_return_state_result( State, ?getAttr(whisker_color) ).
</pre>
<p>State is unchanged here.</p>
<p>Note that when a method &quot;returns&quot; the state of the instance, it returns it to the (local, process-wise) private WOOPER-based main loop of that instance: in other words, the state variable will never be exported outside of its process. Encapsulation is ensured, as the instance is the only process able to access its own state. On method ending, the instance then just loops again, with an updated state.</p>
<p>Thus the caller will only receive the <strong>result</strong> of a method, if it is a request. Otherwise, i.e. with oneways, nothing is sent back.</p>
<p>More precisely, depending on its returning a specific result, the method signature will correspond either to a request or a oneway, and will use, respectively, either the <tt class="docutils literal"><span class="pre">wooper_return_state_result</span></tt> or the <tt class="docutils literal"><span class="pre">wooper_return_state_only</span></tt> macro.</p>
<div class="section">
<h4><a class="toc-backref" href="#id43" id="for-requests" name="for-requests">3.3.7.1&nbsp;&nbsp;&nbsp;For Requests</a></h4>
<p>Requests will use <tt class="docutils literal"><span class="pre">?wooper_return_state_result(NewState,Result)</span></tt>: the new state will be kept by the instance, whereas the result will be sent to the caller. Hence <tt class="docutils literal"><span class="pre">wooper_return_state_result</span></tt> means that the method returns a state <strong>and</strong> a result.</p>
<p>For example:</p>
<pre class="literal-block">
getAge(State) -&gt;
				 ?wooper_return_state_result(State,?getAttr(age)).
</pre>
<p>All methods are of course given the parameters specified at their call.</p>
<p>For example, we can declare:</p>
<pre class="literal-block">
giveBirth(State,NumberOfMaleChildren,NumberOfFemaleChildren) -&gt;
				 [..]
</pre>
<p>And then we may call it, in the case of a cat having 2 male kitten and 3 female ones, with:</p>
<pre class="literal-block">
MyCat ! {giveBirth,[2,3],self()}.
</pre>
<p>Requests can access to one more information than oneways: the PID of the caller that sent the request.</p>
<p>This can be done by using the <tt class="docutils literal"><span class="pre">getSender</span></tt> macro, which is automatically set by WOOPER:</p>
<pre class="literal-block">
giveBirth(State,NumberOfMaleChildren,NumberOfFemaleChildren) -&gt;
  CallerPID = ?getSender(),
  [..]
</pre>
<p>Thus requests have access to their caller PID without having to specify it twice, i.e. with no need to specify it in the parameters as well as in the third element of the call tuple: instead of
<tt class="docutils literal"><span class="pre">MyCat</span> <span class="pre">!</span> <span class="pre">{giveBirth,[2,3,self()],self()}.</span></tt>, only <tt class="docutils literal"><span class="pre">MyCat</span> <span class="pre">!</span> <span class="pre">{giveBirth,[2,3],self()}.</span></tt> can be used, while still letting the possibility for the called request (here <tt class="docutils literal"><span class="pre">giveBirth/3</span></tt>, for a state and two parameters) to access the caller PID thanks to the <tt class="docutils literal"><span class="pre">getSender</span></tt> macro, and maybe store it for a later use.</p>
<p>Note that having to handle explicitly the caller PID is rather uncommon, as WOOPER takes care automatically of the sending of the result back to the caller.</p>
<p>The <tt class="docutils literal"><span class="pre">getSender</span></tt> macro should only be used for requests, as of course the sender PID has no meaning in the case of oneways.</p>
<p>If that macro is called nevertheless from a oneway, then it returns the atom <tt class="docutils literal"><span class="pre">undefined</span></tt>.</p>
</div>
<div class="section">
<h4><a class="toc-backref" href="#id44" id="for-oneways" name="for-oneways">3.3.7.2&nbsp;&nbsp;&nbsp;For Oneways</a></h4>
<p>Oneway will use <tt class="docutils literal"><span class="pre">?wooper_return_state_only(NewState)</span></tt>: the instance state will be updated, but no result will be returned to the caller, which is not even known.</p>
<p>For example:</p>
<pre class="literal-block">
setAge(State,NewAge) -&gt;
  ?wooper_return_state_only( ?setAttribute(State,age,NewAge) ).
</pre>
<p>can be called that way:</p>
<pre class="literal-block">
MyCat ! {setAge,4}.
% No result to expect.
</pre>
<p>Oneways may leave the state unchanged, only being called for side-effects, for example:</p>
<pre class="literal-block">
displayAge(State) -&gt;
  io:format(&quot;My age is ~B~n.&quot;,[ ?getAttr(age) ]),
  ?wooper_return_state_only(State).
</pre>
</div>
<div class="section">
<h4><a class="toc-backref" href="#id45" id="usefulness-of-these-two-return-macros" name="usefulness-of-these-two-return-macros">3.3.7.3&nbsp;&nbsp;&nbsp;Usefulness Of These Two Return Macros</a></h4>
<p>The two macros are actually quite simple, they are just here to structure the method implementations (helping the method developer not mixing updated states and results), and to help ensuring, in debug mode, that methods return well-formed results: an atom is then prepended to the returned tuple and WOOPER matches it during post-invocation, before handling the return, for an increased safety.</p>
<p>For example, in debug mode, <tt class="docutils literal"><span class="pre">?wooper_return_state_result(AState,AResult)</span></tt> will simply translate into <tt class="docutils literal"><span class="pre">{wooper_result,AState,AResult}</span></tt>, and when the execution of the method is over, WOOPER will attempt to match the method returned value with that triplet (3-tuple).</p>
<p>Similarly, <tt class="docutils literal"><span class="pre">?wooper_return_state_only(AState)</span></tt> will translate into <tt class="docutils literal"><span class="pre">{wooper_result,AState}</span></tt>.</p>
<p>If not in debug mode, then the <tt class="docutils literal"><span class="pre">wooper_result</span></tt> element will not be used in the returned tuples, for example <tt class="docutils literal"><span class="pre">?wooper_return_state_result(AState,AResult)</span></tt> will just be <tt class="docutils literal"><span class="pre">{AState,AResult}</span></tt>.</p>
<p>Performances should increase a bit, at the expense of a less safe checking of the values returned by methods.</p>
<p>The two <tt class="docutils literal"><span class="pre">wooper_return_state_*</span></tt> macros have been introduced so that the unwary developer does not forget that his requests should not only return a result, by also a state, and that the order is always: first the state, then the result, not the other way round.</p>
</div>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id127" id="self-invocation-calling-a-method-from-the-instance-itself" name="self-invocation-calling-a-method-from-the-instance-itself">3.3.8&nbsp;&nbsp;&nbsp;Self-Invocation: Calling a Method From The Instance Itself</a></h3>
<p>When implementing a method of a class, one may want to call other methods <strong>of that same class</strong>, which are possibly overloaded.</p>
<p>For example, when developing a <tt class="docutils literal"><span class="pre">declareBirthday</span></tt> method of <tt class="docutils literal"><span class="pre">class_Mammal</span></tt> (which among other things has to increment the mammal age), you may want to perform a call to the <tt class="docutils literal"><span class="pre">setAge</span></tt> method of the current instance.</p>
<p>If you just call <tt class="docutils literal"><span class="pre">setAge</span></tt> or <tt class="docutils literal"><span class="pre">class_Mammal:setAge</span></tt>, then you will never call the potentially overloaded versions from child classes: if an instance of child class <tt class="docutils literal"><span class="pre">class_Cat</span></tt> (which inherited <tt class="docutils literal"><span class="pre">declareBirthday</span></tt> &quot;as is&quot;) overloaded <tt class="docutils literal"><span class="pre">setAge</span></tt>, you may want that <tt class="docutils literal"><span class="pre">declareBirthday</span></tt> calls automatically <tt class="docutils literal"><span class="pre">class_Cat:setAge</span></tt> instead of <tt class="docutils literal"><span class="pre">class_Mammal:setAge</span></tt>.</p>
<p>This call can be easily performed asynchronously: a classical message-based method call can be used, like in <tt class="docutils literal"><span class="pre">self()</span> <span class="pre">!</span> <span class="pre">{setAge,10}</span></tt>. If this approach is useful when not directly needing from the method the result of the call and/or not needing to have it executed at once, there are cases when one wants to have that possibly overridden method being executed <em>directly</em> and to access to the corresponding modified state and, possibly, output result.</p>
<p>In these cases, one should call the WOOPER-defined <tt class="docutils literal"><span class="pre">executeRequest</span></tt> or <tt class="docutils literal"><span class="pre">executeOneway</span></tt> function, depending of the type of the method to call.</p>
<p>These two helper functions behave quite similarly to the actual method calls that are based on the operator <tt class="docutils literal"><span class="pre">!</span></tt>, except that no target instance has to be specified (since it is a call made by an instance to itself) and that no message exchange is involved: the method look-up is just performed through the inheritance hierarchy, the correct method is called with the specified parameters and the result is then directly returned.</p>
<p>More precisely, <tt class="docutils literal"><span class="pre">executeRequest</span></tt> is <tt class="docutils literal"><span class="pre">executeRequest/3</span></tt> or <tt class="docutils literal"><span class="pre">executeRequest/2</span></tt>, its parameters being the current state, the name of the request-method, and, if specified, the parameters of the called request, either as a list or as a standalone one.</p>
<p><tt class="docutils literal"><span class="pre">executeRequest</span></tt> returns a pair made of the new state and of the result.</p>
<p>For example:</p>
<blockquote>
<ul class="simple">
<li>request taking more than one parameter: <tt class="docutils literal"><span class="pre">{NewState,Result}</span> <span class="pre">=</span> <span class="pre">executeRequest(CurrentState,</span> <span class="pre">my_request_name,</span> <span class="pre">[</span> <span class="pre">&quot;hello&quot;,</span> <span class="pre">42</span> <span class="pre">])</span></tt></li>
<li>request taking exactly one parameter: <tt class="docutils literal"><span class="pre">{NewState,Result}</span> <span class="pre">=</span> <span class="pre">executeRequest(CurrentState,</span> <span class="pre">another_request_name,</span> <span class="pre">42)</span></tt></li>
<li>request taking no parameter: <tt class="docutils literal"><span class="pre">{NewState,Result}</span> <span class="pre">=</span> <span class="pre">executeRequest(CurrentState,</span> <span class="pre">third_request_name)</span></tt></li>
</ul>
</blockquote>
<p>Regarding now <tt class="docutils literal"><span class="pre">executeOneway</span></tt>, it is either <tt class="docutils literal"><span class="pre">executeOneway/3</span></tt> or <tt class="docutils literal"><span class="pre">executeOneway/2</span></tt>, depending on whether the oneway takes parameters. If yes, they can be specified as a list (if there are more than one) or as a standalone parameter.</p>
<p><tt class="docutils literal"><span class="pre">executeOneway</span></tt> returns the new state.</p>
<p>For example:</p>
<blockquote>
<ul class="simple">
<li>oneway taking more than one parameter: <tt class="docutils literal"><span class="pre">NewState</span> <span class="pre">=</span> <span class="pre">executeOneway(CurrentState,my_oneway_name,[</span> <span class="pre">&quot;hello&quot;,</span> <span class="pre">42</span> <span class="pre">])</span></tt></li>
<li>oneway taking exactly one parameter: <tt class="docutils literal"><span class="pre">NewState</span> <span class="pre">=</span> <span class="pre">executeOneway(CurrentState,another_oneway_name,42)</span></tt></li>
<li>oneway taking no parameter: <tt class="docutils literal"><span class="pre">NewState</span> <span class="pre">=</span> <span class="pre">executeOneway(CurrentState,third_oneway_name)</span></tt></li>
</ul>
</blockquote>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id128" id="id6" name="id6"><span id="state-management"></span>3.4&nbsp;&nbsp;&nbsp;State Management</a></h2>
<p>We are discussing here about how an instance is to manage its inner state.</p>
<p>Its state is only directly accessible from inside its dedicated class module: the state of an instance is private, the outside can access to it only through the methods declared by the class of this instance.</p>
<p>An instance state (the one which is given by WOOPER as the <tt class="docutils literal"><span class="pre">State</span></tt> variable, first parameter of all methods) is defined as a <strong>set of attributes</strong>.</p>
<p>Each attribute is designated by a name and has a mutable value, which can be any Erlang term.</p>
<p>The current state of an instance can be thought as a list <a class="footnote-reference" href="#id8" id="id7" name="id7">[3]</a> of <tt class="docutils literal"><span class="pre">{attribute_name,attribute_value}</span></tt> pairs, like in: <tt class="docutils literal"><span class="pre">[</span> <span class="pre">{color,black}</span> <span class="pre">,</span> <span class="pre">{age,5}</span> <span class="pre">,</span> <span class="pre">{name,&quot;Tortilla&quot;}</span> <span class="pre">]</span></tt>.</p>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7" name="id8">[3]</a></td><td>Actually it is a <a class="reference" href="http://en.wikipedia.org/wiki/Hashtable">hashtable</a>, for efficiency reasons. It uses the hash value of a key (like the <tt class="docutils literal"><span class="pre">age</span></tt> key) as an index used to find the corresponding value (here, <tt class="docutils literal"><span class="pre">5</span></tt>) in the relevant bucket of the table. The point is that this look-up is performed in constant time on average, regardless of how many key/value pairs are stored in the table, whereas most data structures, like plain lists, will have look-up durations that will increase with the number of pairs they contain, thus being most often slower than their hashtable-based counterparts.</td></tr>
</tbody>
</table>
<p>A set of macros allows to operate on these state variables, notably to read and write the attributes they contain.</p>
<p>As seen in the various examples, method implementations will access (read/write) to attributes stored in the instance state, whose original version (i.e. the state of the instance at method begin) is always specified as their first parameter, <tt class="docutils literal"><span class="pre">State</span></tt>.</p>
<p>This current state can be then modified in the method, and its updated version will be returned locally to WOOPER, thanks to the final call in the method, one of the two <tt class="docutils literal"><span class="pre">wooper_return_state_*</span></tt> macros.</p>
<p>Then the code automatically instantiated by the WOOPER header in the class implementation will loop again with the updated state for this instance, waiting for the next method call.</p>
<div class="section">
<h3><a class="toc-backref" href="#id129" id="modifying-state" name="modifying-state">3.4.1&nbsp;&nbsp;&nbsp;Modifying State</a></h3>
<div class="section">
<h4><a class="toc-backref" href="#id49" id="the-setattribute-3-macro" name="the-setattribute-3-macro">3.4.1.1&nbsp;&nbsp;&nbsp;The <tt class="docutils literal"><span class="pre">setAttribute/3</span></tt> Macro</a></h4>
<p>Setting an attribute (creating and/or modifying it) should be done with the <strong>setAttribute</strong> macro: <tt class="docutils literal"><span class="pre">?setAttribute(AState,AttributeName,NewAttributeValue)</span></tt>.</p>
<p>For example, <tt class="docutils literal"><span class="pre">AgeState</span> <span class="pre">=</span> <span class="pre">?setAttribute(State,age,3)</span></tt> will return a new state, bound to <tt class="docutils literal"><span class="pre">AgeState</span></tt>, exact copy of <tt class="docutils literal"><span class="pre">State</span></tt> (with all the attribute pairs equal) but for the <tt class="docutils literal"><span class="pre">age</span></tt> attribute, whose value will be set to 3 (whether or not this attribute was already defined in <tt class="docutils literal"><span class="pre">State</span></tt>).</p>
<p>Therefore during the method execution multiple states can be defined (ex: <tt class="docutils literal"><span class="pre">State</span></tt> and <tt class="docutils literal"><span class="pre">AgeState</span></tt>), before all but the one that is returned are garbage-collected.</p>
<p>Note that the corresponding state duplication remains efficient both in terms of processing and memory, as the different underlying hashtables (ex: <tt class="docutils literal"><span class="pre">State</span></tt> and <tt class="docutils literal"><span class="pre">AgeState</span></tt>) actually <strong>share</strong> all their terms except the one modified, thanks to the immutability of Erlang variables, which allows to reference rather than copy.</p>
<p>In various cases, notably in constructors, one needs to define a series of attributes in a row, but chaining <tt class="docutils literal"><span class="pre">setAttribute</span></tt> calls with intermediate states is not really convenient.</p>
<p>A better solution is to use the <strong>setAttributes</strong> macro (note the plural) to set a list of attribute name/attribute value pairs.</p>
<p>For example, <tt class="docutils literal"><span class="pre">ConstructedState</span> <span class="pre">=</span> <span class="pre">?setAttributes(State,[</span> <span class="pre">{age,3},</span> <span class="pre">{whisker_color,white}</span> <span class="pre">])</span></tt> will return a new state, exact copy of <tt class="docutils literal"><span class="pre">State</span></tt> but for the listed attributes, set to their respective specified value.</p>
</div>
<div class="section">
<h4><a class="toc-backref" href="#id50" id="the-removeattribute-2-macro" name="the-removeattribute-2-macro">3.4.1.2&nbsp;&nbsp;&nbsp;The <tt class="docutils literal"><span class="pre">removeAttribute/2</span></tt> Macro</a></h4>
<p>An attribute may also be removed, using the <strong>removeAttribute</strong> macro.</p>
<p>For example: <tt class="docutils literal"><span class="pre">NewState</span> <span class="pre">=</span> <span class="pre">?removeAttribute(State,an_attribute)</span></tt>. The resulting state will have no key corresponding to <tt class="docutils literal"><span class="pre">an_attribute</span></tt>.</p>
<p>Neither <tt class="docutils literal"><span class="pre">setAttribute</span></tt> nor <tt class="docutils literal"><span class="pre">removeAttribute</span></tt> can fail, regardless of the attribute being already existing or not.</p>
</div>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id130" id="reading-state" name="reading-state">3.4.2&nbsp;&nbsp;&nbsp;Reading State</a></h3>
<div class="section">
<h4><a class="toc-backref" href="#id52" id="the-hasattribute-2-macro" name="the-hasattribute-2-macro">3.4.2.1&nbsp;&nbsp;&nbsp;The <tt class="docutils literal"><span class="pre">hasAttribute/2</span></tt> Macro</a></h4>
<p>To test whether an attribute is defined, use the <strong>hasAttribute</strong> macro: <tt class="docutils literal"><span class="pre">?hasAttribute(AState,AttributeName)</span></tt>, which returns either <tt class="docutils literal"><span class="pre">true</span></tt> or <tt class="docutils literal"><span class="pre">false</span></tt>, and cannot fail.</p>
<p>For example, <tt class="docutils literal"><span class="pre">true</span> <span class="pre">=</span> <span class="pre">?hasAttribute(State,whisker_color)</span></tt> matches if and only if the attribute <tt class="docutils literal"><span class="pre">whisker_color</span></tt> is defined in state <tt class="docutils literal"><span class="pre">State</span></tt>.</p>
<p>Note that generally it is a bad practice to define attributes outside of the constructor of an instance, as the availability of an attribute could then depend on the actual state, which is an eventuality generally difficult to manage reliably.</p>
<p>A better approach is instead to define all possible attributes directly from the constructor. They would then be assigned to their initial value and, if none is appropriate, they should be set to the atom <tt class="docutils literal"><span class="pre">undefined</span></tt> (instead of not being defined at all).</p>
</div>
<div class="section">
<h4><a class="toc-backref" href="#id53" id="the-getattribute-2-macro" name="the-getattribute-2-macro">3.4.2.2&nbsp;&nbsp;&nbsp;The <tt class="docutils literal"><span class="pre">getAttribute/2</span></tt> Macro</a></h4>
<p>Getting the value of an attribute should be done with the <strong>getAttribute</strong> macro: <tt class="docutils literal"><span class="pre">?getAttribute(AState,AttributeName)</span></tt>.</p>
<p>For example, <tt class="docutils literal"><span class="pre">MyColor</span> <span class="pre">=</span> <span class="pre">?getAttribute(State,whisker_color)</span></tt> returns the value of the attribute <tt class="docutils literal"><span class="pre">whisker_color</span></tt> from state <tt class="docutils literal"><span class="pre">State</span></tt>.</p>
<p>The requested attribute may not exist in the specified state. In this case, a bad match is triggered.</p>
<p>In the previous example, if the attribute <tt class="docutils literal"><span class="pre">whisker_color</span></tt> had not been defined, then <tt class="docutils literal"><span class="pre">getAttribute</span></tt> would have returned: <tt class="docutils literal"><span class="pre">{{badmatch,{hashtable_key_not_found,whisker_color}},[{hashtable,getEntry,2},..</span></tt>.</p>
</div>
<div class="section">
<h4><a class="toc-backref" href="#id54" id="the-getattr-2-macro" name="the-getattr-2-macro">3.4.2.3&nbsp;&nbsp;&nbsp;The <tt class="docutils literal"><span class="pre">getAttr/2</span></tt> Macro</a></h4>
<p>Quite often, when having to retrieve the value of an attribute from a state variable, that variable will be named <tt class="docutils literal"><span class="pre">State</span></tt>, notably when using directly the original state specified in the method declaration.</p>
<p>In this case, the <strong>getAttr</strong> macro can be used: <tt class="docutils literal"><span class="pre">?getAttr(whisker_color)</span></tt> expands as <tt class="docutils literal"><span class="pre">?getAttribute(State,whisker_color)</span></tt>, and is a bit shorter.</p>
</div>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id131" id="read-modify-write-operations" name="read-modify-write-operations">3.4.3&nbsp;&nbsp;&nbsp;Read-Modify-Write Operations</a></h3>
<p>Some more helper macros are provided for the most common operations, to keep the syntax as lightweight as possible.</p>
<div class="section">
<h4><a class="toc-backref" href="#id56" id="the-addtoattribute-3-macro" name="the-addtoattribute-3-macro">3.4.3.1&nbsp;&nbsp;&nbsp;The <tt class="docutils literal"><span class="pre">addToAttribute/3</span></tt> Macro</a></h4>
<p>The corresponding signature is <tt class="docutils literal"><span class="pre">addToAttribute(State,AttributeName,Value)</span></tt>: when having a numerical attribute, adds specified number to the attribute.</p>
<p>For example: <tt class="docutils literal"><span class="pre">NewState</span> <span class="pre">=</span> <span class="pre">?addToAttribute(State,a_numerical_attribute,6)</span></tt>.</p>
<p>If the target attribute does not exist, will trigger <tt class="docutils literal"><span class="pre">{{badmatch,undefined},[{hashtable,addToEntry,3},..</span></tt>.</p>
<p>If it exists but no addition can be performed on it (meaningless for the type of the current value), will trigger <tt class="docutils literal"><span class="pre">{badarith,[{hashtable,addToEntry,3},..</span></tt>.</p>
</div>
<div class="section">
<h4><a class="toc-backref" href="#id57" id="the-substractfromattribute-3-macro" name="the-substractfromattribute-3-macro">3.4.3.2&nbsp;&nbsp;&nbsp;The <tt class="docutils literal"><span class="pre">substractFromAttribute/3</span></tt> Macro</a></h4>
<p>The corresponding signature is <tt class="docutils literal"><span class="pre">substractFromAttribute(State,AttributeName,Value)</span></tt>: when having a numerical attribute, subtracts specified number from the attribute.</p>
<p>For example: <tt class="docutils literal"><span class="pre">NewState</span> <span class="pre">=</span> <span class="pre">?substractFromAttribute(State,a_numerical_attribute,1)</span></tt>.</p>
<p>If the target attribute does not exist, will trigger <tt class="docutils literal"><span class="pre">{{badmatch,undefined},[{hashtable,substractFromEntry,3},..</span></tt>.</p>
<p>If it exists but no subtraction can be performed on it (meaningless for the type of the current value), will trigger <tt class="docutils literal"><span class="pre">{badarith,[{hashtable,substractFromEntry,3},..</span></tt>.</p>
</div>
<div class="section">
<h4><a class="toc-backref" href="#id58" id="the-toggleattribute-2-macro" name="the-toggleattribute-2-macro">3.4.3.3&nbsp;&nbsp;&nbsp;The <tt class="docutils literal"><span class="pre">toggleAttribute/2</span></tt> Macro</a></h4>
<p>The corresponding signature is <tt class="docutils literal"><span class="pre">toggleAttribute(State,BooleanAttributeName)</span></tt>: when having a boolean attribute, whose values are either <tt class="docutils literal"><span class="pre">true</span></tt> or <tt class="docutils literal"><span class="pre">false</span></tt>, sets the opposite logical value to the current one.</p>
<p>For example: <tt class="docutils literal"><span class="pre">NewState</span> <span class="pre">=</span> <span class="pre">?toggleAttribute(State,a_boolean_attribute)</span></tt>.</p>
<p>If the target attribute does not exist, will trigger <tt class="docutils literal"><span class="pre">{{case_clause,undefined},[{hashtable,toggleEntry,2},..</span></tt>.</p>
<p>If it exists but is neither true or false, will trigger <tt class="docutils literal"><span class="pre">{{case_clause,{value,..}},[{hashtable,toggleEntry,2},..</span></tt>.</p>
</div>
<div class="section">
<h4><a class="toc-backref" href="#id59" id="the-appendtoattribute-3-macro" name="the-appendtoattribute-3-macro">3.4.3.4&nbsp;&nbsp;&nbsp;The <tt class="docutils literal"><span class="pre">appendToAttribute/3</span></tt> Macro</a></h4>
<p>The corresponding signature is <tt class="docutils literal"><span class="pre">appendToAttribute(State,AttributeName,Element)</span></tt>: when having a list attribute, appends specified element to the attribute list, in first position.</p>
<p>For example, if <tt class="docutils literal"><span class="pre">a_list_attribute</span></tt> was already set to <tt class="docutils literal"><span class="pre">[see_you,goodbye]</span></tt> in <tt class="docutils literal"><span class="pre">State</span></tt>, then after <tt class="docutils literal"><span class="pre">NewState</span> <span class="pre">=</span> <span class="pre">?appendToAttribute(State,a_list_attribute,hello)</span></tt>, the <tt class="docutils literal"><span class="pre">a_list_attribute</span></tt> attribute defined in <tt class="docutils literal"><span class="pre">NewState</span></tt> will be equal to <tt class="docutils literal"><span class="pre">[hello,see_you,goodbye]</span></tt>.</p>
<p>If the target attribute does not exist, will trigger <tt class="docutils literal"><span class="pre">{{badmatch,undefined},[{hashtable,appendToEntry,3},..</span></tt>.</p>
<p>If it exists but is not already a list, it will not crash but will create an ill-formed list (ex: <tt class="docutils literal"><span class="pre">[8|false]</span></tt> when appending 8 to <tt class="docutils literal"><span class="pre">false</span></tt>, which is not a list).</p>
</div>
<div class="section">
<h4><a class="toc-backref" href="#id60" id="the-deletefromattribute-3-macro" name="the-deletefromattribute-3-macro">3.4.3.5&nbsp;&nbsp;&nbsp;The <tt class="docutils literal"><span class="pre">deleteFromAttribute/3</span></tt> Macro</a></h4>
<p>The corresponding signature is <tt class="docutils literal"><span class="pre">deleteFromAttribute(State,AttributeName,Element)</span></tt>: when having a list attribute, deletes first match of specified element from the attribute list.</p>
<p>For example: <tt class="docutils literal"><span class="pre">NewState</span> <span class="pre">=</span> <span class="pre">?deleteFromAttribute(State,a_list_attribute,hello)</span></tt>, with the value corresponding to the <tt class="docutils literal"><span class="pre">a_list_attribute</span></tt> attribute in <tt class="docutils literal"><span class="pre">State</span></tt> variable being <tt class="docutils literal"><span class="pre">[goodbye,hello,cheers,hello,see_you]</span></tt> should return a state whose <tt class="docutils literal"><span class="pre">a_list_attribute</span></tt> attribute would be equal to <tt class="docutils literal"><span class="pre">[goodbye,cheers,hello,see_you]</span></tt>, all other attributes being unchanged.</p>
<p>If the target attribute does not exist, will trigger <tt class="docutils literal"><span class="pre">{{badmatch,undefined},[{hashtable,deleteFromEntry,3},..</span></tt>.</p>
<p>If it exists but is not already a list, it will trigger <tt class="docutils literal"><span class="pre">{function_clause,[{lists,delete,[..,..]},{hashtable,deleteFromEntry,3}</span></tt>.</p>
<p>If no element in the list matches the specified one, no error will be triggered and the list will be kept as is.</p>
</div>
<div class="section">
<h4><a class="toc-backref" href="#id61" id="the-popfromattribute-2-macro" name="the-popfromattribute-2-macro">3.4.3.6&nbsp;&nbsp;&nbsp;The <tt class="docutils literal"><span class="pre">popFromAttribute/2</span></tt> Macro</a></h4>
<p>The corresponding signature is <tt class="docutils literal"><span class="pre">popFromAttribute(State,AttributeName)</span></tt>: when having an attribute of type list, this macro removes the head from the list and returns a pair made of the updated state (same state except that the corresponding list attribute has lost its head, it is equal to the list tail now) and of that head.</p>
<p>For example: <tt class="docutils literal"><span class="pre">{NewState,Head}</span> <span class="pre">=</span> <span class="pre">?popFromAttribute(State,a_list_attribute)</span></tt>. If the value of the attribute <tt class="docutils literal"><span class="pre">a_list_attribute</span></tt> was <tt class="docutils literal"><span class="pre">[5,8,3]</span></tt>, its new value (in <tt class="docutils literal"><span class="pre">NewState</span></tt>) will be <tt class="docutils literal"><span class="pre">[8,3]</span></tt> and <tt class="docutils literal"><span class="pre">Head</span></tt> will be bound to 5.</p>
</div>
<div class="section">
<h4><a class="toc-backref" href="#id62" id="the-addkeyvaluetoattribute-4-macro" name="the-addkeyvaluetoattribute-4-macro">3.4.3.7&nbsp;&nbsp;&nbsp;The <tt class="docutils literal"><span class="pre">addKeyValueToAttribute/4</span></tt> Macro</a></h4>
<p>The corresponding signature is <tt class="docutils literal"><span class="pre">addKeyValueToAttribute(State,AttributeName,Key,Value)</span></tt>: when having an attribute whose value is a hashtable (therefore, it is a hashtable in the WOOPER hashtable), adds specified key/value pair to that hashtable attribute.</p>
<p>For example: <tt class="docutils literal"><span class="pre">WithTableState</span> <span class="pre">=</span> <span class="pre">?setAttribute(</span> <span class="pre">State,</span> <span class="pre">my_hashtable,</span> <span class="pre">hashtable:new()</span> <span class="pre">),</span> <span class="pre">NewState</span> <span class="pre">=</span> <span class="pre">?addKeyValueToAttribute(</span> <span class="pre">WithTableState,</span> <span class="pre">my_hashtable,</span> <span class="pre">my_key,</span> <span class="pre">my_value</span> <span class="pre">)</span></tt> will result in having the attribute <tt class="docutils literal"><span class="pre">my_hashtable</span></tt> in state variable <tt class="docutils literal"><span class="pre">WithTableState</span></tt> being an hashtable with only one entry, whose key is <tt class="docutils literal"><span class="pre">my_key</span></tt> and whose value is <tt class="docutils literal"><span class="pre">my_value</span></tt>.</p>
<p>See <a class="reference" href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/src/wooper.hrl?view=markup">wooper.hrl</a> for the actual definition of most of these WOOPER constructs.</p>
</div>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id132" id="multiple-inheritance-polymorphism" name="multiple-inheritance-polymorphism">3.5&nbsp;&nbsp;&nbsp;Multiple Inheritance &amp; Polymorphism</a></h2>
<div class="section">
<h3><a class="toc-backref" href="#id133" id="the-general-case" name="the-general-case">3.5.1&nbsp;&nbsp;&nbsp;The General Case</a></h3>
<p>Both multiple inheritance and polymorphism are automatically managed by WOOPER: even if our cat class does not define a <tt class="docutils literal"><span class="pre">getAge</span></tt> method, it can nevertheless readily be called on a cat instance, as it is inherited from its mother classes (here from <tt class="docutils literal"><span class="pre">class_Creature</span></tt>, an indirect mother class).</p>
<p>Therefore all creature instances can be handled the same, regardless of their actual classes:</p>
<pre class="literal-block">
% Inherited methods work exactly the same as methods defined
% directly in the class:
MyCat ! {getAge,[],self()},
receive
				 {wooper_result,Age} -&gt;
								 io:format( &quot;This is a ~B year old cat.&quot;, [Age] )
end,

% Polymorphism is immediate:
% (class_Platypus inheriting too from class_Mammal,
% hence from class_Creature).
MyPetList = [ MyCat, MyPlatypus ],
foreach(
				 fun(AnyCreature) -&gt;
								 AnyCreature ! {getAge,[],self()},
								 receive
												 {wooper_result,Age} -&gt;
																 io:format( &quot;This is a ~B year old creature.&quot;, [Age] )
								 end,
				 MyPetList).
</pre>
<p>should output some like:</p>
<pre class="literal-block">
This is a 4 year old creature.
This is a 9 year old creature.
</pre>
<p>The point here is that the implementer does not have to know what are the actual classes of the instances he handles, provided they share a common ancestor: polymorphism allows to handle them transparently.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id134" id="the-special-case-of-diamond-shaped-inheritance" name="the-special-case-of-diamond-shaped-inheritance">3.5.2&nbsp;&nbsp;&nbsp;The Special Case of Diamond-Shaped Inheritance</a></h3>
<p>In the case of a <a class="reference" href="http://en.wikipedia.org/wiki/Diamond_problem">diamond-shaped inheritance</a>, as the method table is constructed in the order specified in the declaration of the superclasses (<tt class="docutils literal"><span class="pre">-define(wooper_superclasses,[class_X,class_Y,</span> <span class="pre">etc.]).</span></tt>), and as child classes override mother ones, when an incoming WOOPER message arrives the selected <strong>method</strong> should be the one defined in the last branch of the last child (if any), otherwise the one defined in the next to last branch of the last child, etc.</p>
<p>Generally speaking, overriding in that case the relevant methods in the child class at the base of the diamond so that they perform explicitly a direct call to the wanted module is by far the most reasonable solution, in terms of clarity and maintainability.</p>
<p>Regarding the instance state, the <strong>attributes</strong> are set by the constructors, therefore the developer can select in which order the direct mother classes should be constructed. However it always leads to calling multiple times the constructor of the class that sits at the top of the diamond. Any side-effect it would induce would then occur as many times as this class is a common ancestor of the actual class.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">More generally speaking, diamond-shaped inheritance is seldom necessary. More often than not, it is the consequence of a bad OOP design, and should be avoided anyway.</p>
</div>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id135" id="life-cycle" name="life-cycle">3.6&nbsp;&nbsp;&nbsp;Life-Cycle</a></h2>
<p>Basically, creation and destruction of instances are managed respectively thanks to the <tt class="docutils literal"><span class="pre">new</span></tt>/<tt class="docutils literal"><span class="pre">new_link</span></tt> and the <tt class="docutils literal"><span class="pre">delete</span></tt> operators (all these operators are WOOPER-reserved function names, for all arities):</p>
<pre class="literal-block">
MyCat = class_Cat:new(Age,Gender,FurColor,WhiskerColor),
MyCat ! delete.
</pre>
<div class="section">
<h3><a class="toc-backref" href="#id136" id="instance-creation-new-new-link-and-construct" name="instance-creation-new-new-link-and-construct">3.6.1&nbsp;&nbsp;&nbsp;Instance Creation: <tt class="docutils literal"><span class="pre">new</span></tt>/<tt class="docutils literal"><span class="pre">new_link</span></tt> And <tt class="docutils literal"><span class="pre">construct</span></tt></a></h3>
<div class="section">
<h4><a class="toc-backref" href="#id68" id="role-of-a-new-construct-pair" name="role-of-a-new-construct-pair">3.6.1.1&nbsp;&nbsp;&nbsp;Role of a new/construct Pair</a></h4>
<p>Whereas the purpose of <tt class="docutils literal"><span class="pre">new</span></tt>/<tt class="docutils literal"><span class="pre">new_link</span></tt> is to create a working instance on the user's behalf, the role of <tt class="docutils literal"><span class="pre">construct</span></tt> is to initialise an instance of that class while being able to be chained for inheritance, as explained later.</p>
<p>All calls to a <tt class="docutils literal"><span class="pre">new</span></tt> operator result in an underlying call to the corresponding <tt class="docutils literal"><span class="pre">construct</span></tt> method.</p>
<p>For example, <tt class="docutils literal"><span class="pre">MyCat</span> <span class="pre">=</span> <span class="pre">class_Cat:new(A,B,C,D)</span></tt> will rely on <tt class="docutils literal"><span class="pre">class_Cat:construct/5</span></tt> to set-up a proper initial state for the <tt class="docutils literal"><span class="pre">MyCat</span></tt> instance: <tt class="docutils literal"><span class="pre">class_Cat:construct(State,A,B,C,D)</span></tt> will be called for</p>
<p>The <tt class="docutils literal"><span class="pre">new_link</span></tt> operator behaves exactly as the <tt class="docutils literal"><span class="pre">new</span></tt> operator, except that it creates an instance that is Erlang-linked with the process that called that operator, exactly like <tt class="docutils literal"><span class="pre">spawn_link</span></tt> behaves compared to <tt class="docutils literal"><span class="pre">spawn</span></tt>.</p>
<p>The <tt class="docutils literal"><span class="pre">new</span></tt> and <tt class="docutils literal"><span class="pre">new_link</span></tt> operators are automatically defined by WOOPER, but they rely on the class-specific user-defined <tt class="docutils literal"><span class="pre">construct</span></tt> special method (only WOOPER is expected to call this method). This <tt class="docutils literal"><span class="pre">construct</span></tt> method is the one that must be implemented by the class developer.</p>
<p>Only one version of <tt class="docutils literal"><span class="pre">new</span></tt>, <tt class="docutils literal"><span class="pre">new_link</span></tt> and <tt class="docutils literal"><span class="pre">construct</span></tt> can be defined, but they may branch to as many subconstructors as needed.</p>
<p>For example:</p>
<pre class="literal-block">
MyFirstDog  = Class_Dog:new( create_from_colors, [sand,white] ),
MySecondDog = Class_Dog:new( create_from_age, 5 ),
MyThirdDog  = Class_Dog:new( create_from_weight, 4.4 ).
</pre>
</div>
<div class="section">
<h4><a class="toc-backref" href="#id69" id="the-various-ways-of-creating-an-instance" name="the-various-ways-of-creating-an-instance">3.6.1.2&nbsp;&nbsp;&nbsp;The Various Ways of Creating An Instance</a></h4>
<p>As shown with the <tt class="docutils literal"><span class="pre">new_link</span></tt> operator, even with the same set of constructing parameters, many variations of <tt class="docutils literal"><span class="pre">new</span></tt> can be imagined: linked or not, synchronous or not, with a time-out or not, on current node or on a user-specified one, etc.</p>
<p>For a class whose construction needs N actual parameters, the following construction operators are built-in:</p>
<blockquote>
<ul class="simple">
<li>instance is to be created on the <strong>local</strong> node:<ul>
<li>non-blocking: <tt class="docutils literal"><span class="pre">new/N</span></tt> and <tt class="docutils literal"><span class="pre">new_link/N</span></tt></li>
<li>blocking: <tt class="docutils literal"><span class="pre">synchronous_new/N</span></tt> and <tt class="docutils literal"><span class="pre">synchronous_new_link/N</span></tt></li>
<li>blocking with time-out: <tt class="docutils literal"><span class="pre">synchronous_timed_new/N</span></tt> and <tt class="docutils literal"><span class="pre">synchronous_timed_new_link/N</span></tt></li>
</ul>
</li>
<li>instance is to be created on specified <strong>remote</strong> node:<ul>
<li>non-blocking: <tt class="docutils literal"><span class="pre">remote_new/N+1</span></tt> and <tt class="docutils literal"><span class="pre">remote_new_link/N+1</span></tt></li>
<li>blocking: <tt class="docutils literal"><span class="pre">remote_synchronous_new/N+1</span></tt> and <tt class="docutils literal"><span class="pre">remote_synchronous_new_link/N+1</span></tt></li>
<li>blocking with time-out: <tt class="docutils literal"><span class="pre">remote_synchronous_timed_new/N+1</span></tt> and <tt class="docutils literal"><span class="pre">remote_synchronous_timed_new_link/N+1</span></tt></li>
</ul>
</li>
</ul>
</blockquote>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">All <tt class="docutils literal"><span class="pre">remote_*</span></tt> variations require one more parameter (to be specified first), since the remote node on which the instance should be created has of course to be specified.</p>
</div>
<p>The supported <tt class="docutils literal"><span class="pre">new</span></tt> variations are detailed below.</p>
<div class="section">
<h5><a class="toc-backref" href="#id70" id="asynchronous-new" name="asynchronous-new">3.6.1.2.1&nbsp;&nbsp;&nbsp;Asynchronous new</a></h5>
<p>This corresponds to the plain <tt class="docutils literal"><span class="pre">new</span></tt>, <tt class="docutils literal"><span class="pre">new_link</span></tt> operators etc. discussed earlier. These basic operators are <strong>asynchronous</strong> (non-blocking): they trigger the creation of a new instance, and return immediately, without waiting for it to complete.</p>
</div>
<div class="section">
<h5><a class="toc-backref" href="#id71" id="synchronous-new" name="synchronous-new">3.6.1.2.2&nbsp;&nbsp;&nbsp;Synchronous new</a></h5>
<p>With the previous asynchronous forms, the caller has no way of knowing when the spawned instance is up and running (if it ever happens).</p>
<p>Thus two counterpart operators, <tt class="docutils literal"><span class="pre">synchronous_new/synchronous_new_link</span></tt> are also available.</p>
<p>They behave like <tt class="docutils literal"><span class="pre">new/new_link</span></tt> except they will return only when (and if) the created instance is up and running: they are blocking, synchronous, operators.</p>
<p>For example, after <tt class="docutils literal"><span class="pre">MyMammal</span> <span class="pre">=</span> <span class="pre">class_Mammal:synchronous_new(...)</span></tt>, one knows that the <tt class="docutils literal"><span class="pre">MyMammal</span></tt> instance is fully created and waiting for incoming messages.</p>
<p>The implementation of these synchronous operations relies on a message (<tt class="docutils literal"><span class="pre">{spawn_successful,InstancePid}</span></tt>) being automatically sent by the created instance to the WOOPER code on the caller side, so that the <tt class="docutils literal"><span class="pre">synchronous_new</span></tt> operator will return to the user code only once successfully constructed and ready to handle messages.</p>
</div>
<div class="section">
<h5><a class="toc-backref" href="#id72" id="timed-synchronous-new" name="timed-synchronous-new">3.6.1.2.3&nbsp;&nbsp;&nbsp;Timed Synchronous new</a></h5>
<p>Note that, should the instance creation fail, the caller of a synchronous new would then be blocked for ever, as the awaited message would actually never be sent.</p>
<p>This is why the <tt class="docutils literal"><span class="pre">*synchronous_timed_new*</span></tt> operators are defined: if the time-out (its default duration is 5 seconds) expires while waiting for the created instance to answer, then they will return the <tt class="docutils literal"><span class="pre">time_out</span></tt> atom instead of the PID of the created instance.</p>
<p>The caller is then able to check whether the creation succeeded thanks to a simple pattern-matching.</p>
</div>
<div class="section">
<h5><a class="toc-backref" href="#id73" id="remote-new" name="remote-new">3.6.1.2.4&nbsp;&nbsp;&nbsp;Remote new</a></h5>
<p>Exactly like a process might be spawned on another Erlang node, a WOOPER instance can be created on any user-specified available Erlang node.</p>
<p>To do so, the <tt class="docutils literal"><span class="pre">remote_*new*</span></tt> variations shall be used. They behave exactly like their local counterparts, except that they take an additional information as first parameter: the node on which they must be created.</p>
<p>For example: <tt class="docutils literal"><span class="pre">MyCat</span> <span class="pre">=</span> <span class="pre">class_Cat:remote_new(</span> <span class="pre">TargetNode,</span> <span class="pre">Age,</span> <span class="pre">Gender,</span> <span class="pre">FurColor,</span> <span class="pre">WhiskerColor</span> <span class="pre">).</span></tt></p>
</div>
</div>
<div class="section">
<h4><a class="toc-backref" href="#id74" id="declaration-of-the-new-construct-pair" name="declaration-of-the-new-construct-pair">3.6.1.3&nbsp;&nbsp;&nbsp;Declaration of the new/construct Pair</a></h4>
<p>When an instance is created, user-specified parameters are given to the relevant <tt class="docutils literal"><span class="pre">new</span></tt> operator, notably to set up the instance initial state, i.e. its attributes. These parameters must be declared thanks to the <tt class="docutils literal"><span class="pre">wooper_construct_parameters</span></tt> define.</p>
<p>For example, <tt class="docutils literal"><span class="pre">-define(</span> <span class="pre">wooper_construct_parameters,</span> <span class="pre">Age,</span> <span class="pre">Gender</span> <span class="pre">).</span></tt> implies that two parameters, an age and a gender, are needed for an instance to be created.</p>
<p>If the instance is created without needing any parameter, then no <tt class="docutils literal"><span class="pre">wooper_construct_parameters</span></tt> macro should be defined at all (i.e. using <tt class="docutils literal"><span class="pre">-define(</span> <span class="pre">wooper_construct_parameters,).</span></tt> is <strong>not</strong> allowed).</p>
<p>In the general case where there is at least one parameter, the WOOPER-defined <tt class="docutils literal"><span class="pre">new</span></tt> operators automatically transmit these parameters to the <tt class="docutils literal"><span class="pre">construct</span></tt> method.</p>
<p>Based on the <tt class="docutils literal"><span class="pre">wooper_construct_parameters</span></tt> define (let us suppose N constructor parameters are listed in it), all the variations of the <tt class="docutils literal"><span class="pre">new</span></tt> operator and <tt class="docutils literal"><span class="pre">construct</span></tt> can be declared thanks to:</p>
<pre class="literal-block">
% Declaring all variations of WOOPER standard life-cycle operations:
% (template pasted, two replacements performed to update arities)
-define( wooper_construct_export, new/N, new_link/N,
	synchronous_new/N, synchronous_new_link/N,
	synchronous_timed_new/N, synchronous_timed_new_link/N,
	remote_new/N+1, remote_new_link/N+1, remote_synchronous_new/N+1,
	remote_synchronous_new_link/N+1, remote_synchronous_timed_new/N+1,
	remote_synchronous_timed_new_link/N+1, construct/N+1 ).
</pre>
<p>As there are quite a lot of construction operators available, the recommended mode of operation of declaring them all is to use the following template:</p>
<pre class="literal-block">
% Declaring all variations of WOOPER standard life-cycle operations:
% (template pasted, two replacements performed to update arities)
-define( wooper_construct_export, new/A, new_link/A,
	synchronous_new/A, synchronous_new_link/A,
	synchronous_timed_new/A, synchronous_timed_new_link/A,
	remote_new/B, remote_new_link/B, remote_synchronous_new/B,
	remote_synchronous_new_link/B, remote_synchronous_timed_new/B,
	remote_synchronous_timed_new_link/B, construct/B, delete/1 ).
</pre>
<p>and to use your text editor to replace <tt class="docutils literal"><span class="pre">A</span></tt> with your actual <tt class="docutils literal"><span class="pre">N</span></tt> and <tt class="docutils literal"><span class="pre">B</span></tt> with <tt class="docutils literal"><span class="pre">N+1</span></tt>.</p>
<p>If the class does not declare a specific destructor, then the corresponding declaration in the previous template (<tt class="docutils literal"><span class="pre">delete/1</span></tt>) must be removed.</p>
<p>For example, if wanting to create a bird (<tt class="docutils literal"><span class="pre">MyBird</span> <span class="pre">=</span> <span class="pre">class_Bird:new(Age,Gender)</span></tt>), we would have <tt class="docutils literal"><span class="pre">N=2</span></tt> (two actual constructing parameters: age and gender), thus <tt class="docutils literal"><span class="pre">A</span></tt> has to be replaced by <tt class="docutils literal"><span class="pre">2</span></tt>, and B by <tt class="docutils literal"><span class="pre">3</span></tt>:</p>
<p>We see that <tt class="docutils literal"><span class="pre">construct</span></tt> needs <tt class="docutils literal"><span class="pre">N+1</span></tt> parameters instead of <tt class="docutils literal"><span class="pre">N</span></tt>, to account for its first additional parameter, which is the <tt class="docutils literal"><span class="pre">State</span></tt> variable.</p>
</div>
<div class="section">
<h4><a class="toc-backref" href="#id75" id="some-examples" name="some-examples">3.6.1.4&nbsp;&nbsp;&nbsp;Some Examples</a></h4>
<p>They can be used as templates:</p>
<pre class="literal-block">
-module(class_Bird).
-define( wooper_superclasses, [class_X,class_Y] ).
-define( wooper_construct_parameters, Age, Gender ).

% Declaring all variations of WOOPER standard life-cycle operations:
% (template pasted, two replacements performed to update arities)
-define( wooper_construct_export, new/2, new_link/2,
	synchronous_new/2, synchronous_new_link/2,
	synchronous_timed_new/2, synchronous_timed_new_link/2,
	remote_new/3, remote_new_link/3, remote_synchronous_new/3,
	remote_synchronous_new_link/3, remote_synchronous_timed_new/3,
	remote_synchronous_timed_new_link/3, construct/3, delete/1 ).

% Method declarations.
-define( wooper_method_export, my_first_method/X, second_method/Y ).

% Allows to define WOOPER base variables and methods for that class:
-include(&quot;wooper.hrl&quot;).

% Using the construct macro is prefered to duplicating the list of
% parameters:
construct( State, ?wooper_construct_parameters ) -&gt;
  ...
</pre>
<p>If no construction-related parameter was needed, then it would become:</p>
<pre class="literal-block">
-module(class_OtherBird).
-define( wooper_superclasses, [class_X,class_Y] ).
% No '-define( wooper_construct_parameters,).' here!

% Declaring all variations of WOOPER standard life-cycle operations:
% (template pasted, two replacements performed to update arities)
-define( wooper_construct_export, new/0, new_link/0,
	synchronous_new/0, synchronous_new_link/0,
	synchronous_timed_new/0, synchronous_timed_new_link/0,
	remote_new/1, remote_new_link/1, remote_synchronous_new/1,
	remote_synchronous_new_link/1, remote_synchronous_timed_new/1,
	remote_synchronous_timed_new_link/1, construct/1, delete/1 ).

% Method declarations.
-define( wooper_method_export, my_first_method/X, second_method/Y ).

% Allows to define WOOPER base variables and methods for that class:
-include(&quot;wooper.hrl&quot;).

construct( State ) -&gt;
  ...
</pre>
<p>All variations of the <tt class="docutils literal"><span class="pre">new</span></tt> operator are always defined automatically by WOOPER: nothing special is to be done for them, besides the <tt class="docutils literal"><span class="pre">wooper_construct_export</span></tt> declaration we just mentioned here.</p>
</div>
<div class="section">
<h4><a class="toc-backref" href="#id76" id="definition-of-the-construct-method" name="definition-of-the-construct-method">3.6.1.5&nbsp;&nbsp;&nbsp;Definition of the <tt class="docutils literal"><span class="pre">construct</span></tt> Method</a></h4>
<p>In the context of class inheritance, the <tt class="docutils literal"><span class="pre">construct</span></tt> methods are expected to be chained: they must be designed to be called by the ones of their child classes, and they must call themselves the constructors of their mother classes, if any.</p>
<p>Hence they always take the current state of the instance being created as a starting base, and returns it once updated, first from the direct mother classes, then by this class itself.</p>
<p>For example, <tt class="docutils literal"><span class="pre">class_Cat</span></tt> inherits directly from <tt class="docutils literal"><span class="pre">class_Mammal</span></tt> and from <tt class="docutils literal"><span class="pre">class_ViviparousBeing</span></tt>, and has only one attribute (<tt class="docutils literal"><span class="pre">whisker_color)</span></tt> on its own:</p>
<pre class="literal-block">
[..]
-define(wooper_superclasses,[class_Mammal,class_ViviparousBeing]).
[..]
-define(wooper_construct_parameters,Age,Gender,FurColor,WhiskerColor).
[..]
-define( wooper_construct_export, new/4, new_link/4,
	synchronous_new/4, synchronous_new_link/4,
	synchronous_timed_new/4, synchronous_timed_new_link/4,
	remote_new/5, remote_new_link/5, remote_synchronous_new/5,
	remote_synchronous_new_link/5, remote_synchronous_timed_new/5,
	remote_synchronous_timed_new_link/5, construct/5 ).

[..]
% Constructs a new Cat.
construct(State,?wooper_construct_parameters) -&gt;
	% First the direct mother classes:
	MammalState = class_Mammal:construct( State, Age, Gender, FurColor ),
	ViviparousMammalState = class_ViviparousBeing:construct( MammalState ),
	% Then the class-specific attributes:
	?setAttribute( ViviparousMammalState, whisker_color, WhiskerColor ).
</pre>
<p>The fact that the <tt class="docutils literal"><span class="pre">Mammal</span></tt> class itself inherits from the <tt class="docutils literal"><span class="pre">Creature</span></tt> class must not appear here: it is to be managed directly by <tt class="docutils literal"><span class="pre">class_Mammal:construct</span></tt> (at any given inheritance level, only direct classes must be taken into account).</p>
<p>One should ensure that, in constructors, the successive states are always built from the last updated one, unlike:</p>
<pre class="literal-block">
% WRONG, the age update is lost:
construct(State,Age,Gender) -&gt;
	AgeState = setAttribute(State,age,Age),
				 % AgeState should be used here, not State:
	setAttribute(State,gender,Gender),
</pre>
<p>This would be correct:</p>
<pre class="literal-block">
% RIGHT but a bit clumsy:
construct(State,Age,Gender) -&gt;
	AgeState = setAttribute(State,age,Age),
	setAttribute(AgeState,gender,Gender).
</pre>
<p>Recommended form:</p>
<pre class="literal-block">
% BEST:
construct(State,Age,Gender) -&gt;
	setAttributes( State, [ {age,Age}, {gender,Gender} ]).
</pre>
</div>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id137" id="instance-deletion" name="instance-deletion">3.6.2&nbsp;&nbsp;&nbsp;Instance Deletion</a></h3>
<div class="section">
<h4><a class="toc-backref" href="#id78" id="automatic-chaining-of-destructors" name="automatic-chaining-of-destructors">3.6.2.1&nbsp;&nbsp;&nbsp;Automatic Chaining Of Destructors</a></h4>
<p>We saw that, when implementing a constructor (<tt class="docutils literal"><span class="pre">construct/N</span></tt>), like in all other OOP approaches the constructors of the direct mother classes have to be explicitly called, so that they can be given the proper parameters.</p>
<p>Conversely, with WOOPER, when defining a destructor for a class (<tt class="docutils literal"><span class="pre">delete/1</span></tt>), one only has to specify what are the <em>specific</em> operations (if any) that are required so that an instance of that class is deleted: the proper calling of the destructors of mother classes across the inheritance graph is automatically taken in charge by WOOPER.</p>
<p>Note also that as soon as you define a destructor, you have to declare it in the <tt class="docutils literal"><span class="pre">wooper_construct_export</span></tt> section.</p>
<p>For example:</p>
<pre class="literal-block">
-define( wooper_construct_export, new/N, [..], construct/N+1, delete/1 ).
</pre>
<p>Otherwise a warning will be issued (<tt class="docutils literal"><span class="pre">delete/1</span></tt> is unused), and the overridden destructor would not be called then.</p>
</div>
<div class="section">
<h4><a class="toc-backref" href="#id79" id="asynchronous-destructor-delete-1" name="asynchronous-destructor-delete-1">3.6.2.2&nbsp;&nbsp;&nbsp;Asynchronous Destructor: <tt class="docutils literal"><span class="pre">delete/1</span></tt></a></h4>
<p>More precisely, either the class implementer does not define at all a <tt class="docutils literal"><span class="pre">delete/1</span></tt> operator, or it defines it without needing to call the ones of the mother class(es), like in:</p>
<pre class="literal-block">
delete(State) -&gt;
  io:format(&quot;An instance of class ~w is being deleted now!&quot;, [?MODULE] ).
</pre>
<p>In both cases, when the instance will be deleted (i.e. <tt class="docutils literal"><span class="pre">MyInstance</span> <span class="pre">!</span> <span class="pre">delete</span></tt> is issued), WOOPER will take care of:</p>
<blockquote>
<ul class="simple">
<li>calling any destructor defined for that class</li>
<li>then calling the ones of the direct mother classes, which will in turn call the ones of their mother classes, and so on</li>
</ul>
</blockquote>
<p>Note that the destructors for direct mother classes will be called in the reverse order of the one according to the constructors ought to have been called: if a class <tt class="docutils literal"><span class="pre">class_X</span></tt> declares <tt class="docutils literal"><span class="pre">class_A</span></tt> and <tt class="docutils literal"><span class="pre">class_B</span></tt> as mother classes (in that order), then in the <tt class="docutils literal"><span class="pre">class_X:construct</span></tt> definition the implementer is expected to call <tt class="docutils literal"><span class="pre">class_A:construct</span></tt> and then <tt class="docutils literal"><span class="pre">class_B:construct</span></tt>, whereas on deletion the WOOPER-enforced order of execution will be: <tt class="docutils literal"><span class="pre">class_X:delete</span></tt>, then <tt class="docutils literal"><span class="pre">class_B:delete</span></tt>, then <tt class="docutils literal"><span class="pre">class_A:delete</span></tt>, for the sake of symmetry.</p>
</div>
<div class="section">
<h4><a class="toc-backref" href="#id80" id="synchronous-destructor-synchronous-delete-1" name="synchronous-destructor-synchronous-delete-1">3.6.2.3&nbsp;&nbsp;&nbsp;Synchronous Destructor: <tt class="docutils literal"><span class="pre">synchronous_delete/1</span></tt></a></h4>
<p>Finally, the <tt class="docutils literal"><span class="pre">delete/1</span></tt> operator does not need to be exported, since it will be triggered only thanks to messages.</p>
</div>
</div>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id81" id="miscellaneous-technical-points" name="miscellaneous-technical-points">4&nbsp;&nbsp;&nbsp;Miscellaneous Technical Points</a></h1>
<div class="section">
<h2><a class="toc-backref" href="#id82" id="exit-messages" name="exit-messages">4.1&nbsp;&nbsp;&nbsp;EXIT Messages</a></h2>
<p>A class instance may receive EXIT messages from other processes.</p>
<p>A given class can process these EXIT notifications:</p>
<blockquote>
<ul class="simple">
<li>either by defining and exporting the <tt class="docutils literal"><span class="pre">onWooperExitReceived/3</span></tt> oneway</li>
<li>or by inheriting it</li>
</ul>
</blockquote>
<p>For example:</p>
<pre class="literal-block">
onWooperExitReceived(State,Pid,ExitType) -&gt;
				 io:format( &quot;MyClass EXIT handler ignored signal '~w'&quot;
								&quot; from ~w.~n&quot;, [ExitType,Pid] ),
				 ?wooper_return_state_only(State).
</pre>
<p>results in:</p>
<pre class="literal-block">
``MyClass EXIT handler ignored signal 'normal' from &lt;0.40.0&gt;.``
</pre>
<p>If no class-specific EXIT handler is available, the default WOOPER one will be used.</p>
<p>It will just notify the user by displaying a message like:</p>
<pre class="literal-block">
``WOOPER default EXIT handler for instance &lt;0.36.0&gt; of class class_Cat ignored signal 'normal' from &lt;0.40.0&gt;.``
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id83" id="practical-build-hints" name="practical-build-hints">4.2&nbsp;&nbsp;&nbsp;Practical Build Hints</a></h2>
<p>All WOOPER classes must include <a class="reference" href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/src/wooper.hrl?view=markup">wooper.hrl</a>: <tt class="docutils literal"><span class="pre">-include(&quot;wooper.hrl&quot;).</span></tt>.</p>
<p>To help declaring the right defines in the right order, using the WOOPER <a class="reference" href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_Template.erl.sample?view=markup">template</a> is recommended.</p>
<p>One should have <tt class="docutils literal"><span class="pre">utils.beam</span></tt>, <tt class="docutils literal"><span class="pre">hashtable.beam</span></tt> and <tt class="docutils literal"><span class="pre">wooper_class_manager.beam</span></tt> available to the interpreter before using WOOPER-based classes.</p>
<p>On UNIX-like platforms, using the Makefiles included in the WOOPER archive is recommended.</p>
<p>One just has to go at the root of the sources (from an extracted archive, you are expected to be in the <tt class="docutils literal"><span class="pre">wooper-x.y</span></tt> root directory) and simply run: <tt class="docutils literal"><span class="pre">make</span></tt> (assuming GNU make is available, so that the WOOPER <tt class="docutils literal"><span class="pre">GNUmakefile</span></tt> is used).</p>
<p>On other platforms, these modules must be compiled one way or another before using WOOPER. For example:</p>
<pre class="literal-block">
1&gt; c(hashtable).
{ok,hashtable}
</pre>
<p>We provide as well a WOOPER-aware <a class="reference" href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/common/conf/nedit.rc">neditrc</a> configuration file for syntax highlighting (on black backgrounds), inspired from Daniel Solaz's <a class="reference" href="http://www.trapexit.org/forum/viewtopic.php?p=30189">Erlang Nedit mode</a>.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id84" id="similarity-with-python" name="similarity-with-python">4.3&nbsp;&nbsp;&nbsp;Similarity With Python</a></h2>
<p>Finally, WOOPER is in some ways adding features very similar to the ones of Python (simple multiple inheritance, implied <tt class="docutils literal"><span class="pre">self/State</span></tt> parameter, attribute dictionaries, etc.; with less syntactic sugar available though) while still offering the major strengths of Erlang (concurrency, distribution, functional paradigm) and not hurting too much the overall performances (mainly thanks to the prebuilt attribute and method hashtables).</p>
<p></p>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id85" id="wooper-example" name="wooper-example">5&nbsp;&nbsp;&nbsp;WOOPER Example</a></h1>
<p>We created a small set of classes allowing to show multiple inheritance:</p>
<!-- comment Use format-specific instructions so that the PDF fits in one page and the HTML has a full-sized image. -->
<div class="figure">
<img alt="WOOPER Example" src="wooper-example.png" style="width: 474.8px; height: 256.8px;" />
<p class="caption">Example of an inheritance graph to be handled by WOOPER</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id86" id="class-implementations" name="class-implementations">5.1&nbsp;&nbsp;&nbsp;Class implementations</a></h2>
<blockquote>
<ul class="simple">
<li><a class="reference" href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_Creature.erl?view=markup">class_Creature.erl</a></li>
<li><a class="reference" href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_ViviparousBeing.erl?view=markup">class_ViviparousBeing.erl</a></li>
<li><a class="reference" href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_OvoviviparousBeing.erl?view=markup">class_OvoviviparousBeing.erl</a></li>
<li><a class="reference" href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_Mammal.erl?view=markup">class_Mammal.erl</a></li>
<li><a class="reference" href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_Reptile.erl?view=markup">class_Reptile.erl</a></li>
<li><a class="reference" href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_Cat.erl?view=markup">class_Cat.erl</a></li>
<li><a class="reference" href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_Platypus.erl?view=markup">class_Platypus.erl</a></li>
</ul>
</blockquote>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id87" id="tests" name="tests">5.2&nbsp;&nbsp;&nbsp;Tests</a></h2>
<blockquote>
<ul class="simple">
<li><a class="reference" href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_Creature_test.erl?view=markup">class_Creature_test.erl</a></li>
<li><a class="reference" href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_ViviparousBeing_test.erl?view=markup">class_ViviparousBeing_test.erl</a></li>
<li><a class="reference" href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_OvoviviparousBeing_test.erl?view=markup">class_OvoviviparousBeing_test.erl</a></li>
<li><a class="reference" href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_Mammal_test.erl?view=markup">class_Mammal_test.erl</a></li>
<li><a class="reference" href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_Reptile_test.erl?view=markup">class_Reptile_test.erl</a></li>
<li><a class="reference" href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_Cat_test.erl?view=markup">class_Cat_test.erl</a></li>
<li><a class="reference" href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/examples/class_Platypus_test.erl?view=markup">class_Platypus_test.erl</a></li>
</ul>
</blockquote>
<p>To run a test (ex: <tt class="docutils literal"><span class="pre">class_Cat_test.erl</span></tt>), when everything is compiled one just has to enter: <tt class="docutils literal"><span class="pre">make</span> <span class="pre">class_Cat_run</span></tt>.</p>
<p></p>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id88" id="troubleshooting" name="troubleshooting">6&nbsp;&nbsp;&nbsp;Troubleshooting</a></h1>
<div class="section">
<h2><a class="toc-backref" href="#id89" id="general-case" name="general-case">6.1&nbsp;&nbsp;&nbsp;General Case</a></h2>
<div class="section">
<h3><a class="toc-backref" href="#id90" id="compilation-warnings" name="compilation-warnings">6.1.1&nbsp;&nbsp;&nbsp;Compilation Warnings</a></h3>
<p>A basic rule of thumb in all languages is to enable all warnings and eradicate them before ever trying to test a program.</p>
<p>This is still more valid when using WOOPER, whose proper use should never result in any warning being issued by the compiler.</p>
<p>Notably warnings about unused variables allow to catch mistakes when state variables are being properly taken care of.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id91" id="runtime-errors" name="runtime-errors">6.1.2&nbsp;&nbsp;&nbsp;Runtime Errors</a></h3>
<p>Most errors while using WOOPER should result in relatively clear messages (ex: <tt class="docutils literal"><span class="pre">wooper_method_failed</span></tt> or <tt class="docutils literal"><span class="pre">wooper_method_faulty_return</span></tt>).</p>
<p>Another way of overcoming WOOPER issues is to activate the debug mode for all WOOPER-enabled compiled modules (ex: uncomment <tt class="docutils literal"><span class="pre">-define(wooper_debug,).</span></tt> in <tt class="docutils literal"><span class="pre">wooper.hrl</span></tt>), and recompile your classes.</p>
<p>If it is not enough to clear things up, an additional step can be to add, on a per-class basis (ex: in <tt class="docutils literal"><span class="pre">class_Cat.erl</span></tt>), before the WOOPER include, <tt class="docutils literal"><span class="pre">-define(wooper_log_wanted,).</span></tt>.</p>
<p>Then all incoming method calls will be traced, for easier debugging.</p>
<p>As there are a few common WOOPER gotchas though, the main ones are listed below.</p>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id92" id="mismatches-in-method-call" name="mismatches-in-method-call">6.2&nbsp;&nbsp;&nbsp;Mismatches In Method Call</a></h2>
<div class="section">
<h3><a class="toc-backref" href="#id93" id="oneway-versus-request-calls" name="oneway-versus-request-calls">6.2.1&nbsp;&nbsp;&nbsp;Oneway Versus Request Calls</a></h3>
<p>One of these gotchas- experienced even by the WOOPER author - is to define a two-parameter oneway, whose second parameter is a PID, and to call this method wrongly as a request, instead of as a oneway.</p>
<p>For example, let's suppose the <tt class="docutils literal"><span class="pre">class_Dog</span></tt> class defines the oneway method <tt class="docutils literal"><span class="pre">startBarkingAt/3</span></tt> as:</p>
<pre class="literal-block">
startBarkingAt(State,Duration,ListenerPID) -&gt; ...
</pre>
<p>The correct approach to call this <strong>oneway</strong> would be:</p>
<pre class="literal-block">
MyDogPid ! {startBarkingAt,[MyDuration,self()]}
</pre>
<p>An absent-minded developer could have written instead:</p>
<pre class="literal-block">
MyDogPid ! {startBarkingAt, MyDuration, self()}
</pre>
<p>This would have called a <tt class="docutils literal"><span class="pre">request</span></tt> method <tt class="docutils literal"><span class="pre">startBarkingAt/2</span></tt> (which could have been for example <tt class="docutils literal"><span class="pre">startBarkingAt(State,TerminationOffset)</span> <span class="pre">-&gt;</span> <span class="pre">...</span></tt>, the PID being interpreted by WOOPER as the request sender PID), which most probably would not exist.</p>
<p>This would result in a bit obscure error message like <tt class="docutils literal"><span class="pre">Error</span> <span class="pre">in</span> <span class="pre">process</span> <span class="pre">&lt;0.43.0&gt;</span> <span class="pre">on</span> <span class="pre">node</span> <span class="pre">'XXXX'</span> <span class="pre">with</span> <span class="pre">exit</span> <span class="pre">value:</span> <span class="pre">{badarg,[{class_Cat,wooper_main_loop,1}]}</span></tt>.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id94" id="list-parameter-incorrectly-specified-in-call" name="list-parameter-incorrectly-specified-in-call">6.2.2&nbsp;&nbsp;&nbsp;List Parameter Incorrectly Specified In Call</a></h3>
<p>As explained in the <a class="reference" href="#single-method-parameter-is-a-list">single method parameter is a list</a> section, if a method takes only one parameter and if this parameter is a list, then in a call this parameter cannot be specified as a standalone one: a parameter list with only one element, this parameter, should be used instead.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id95" id="error-with-exit-value-undef-hashtable-new" name="error-with-exit-value-undef-hashtable-new">6.2.3&nbsp;&nbsp;&nbsp;Error With Exit Value: <tt class="docutils literal"><span class="pre">{undef,[{hashtable,new,[..]}..</span></tt></a></h3>
<p>You most probably forgot to build the <tt class="docutils literal"><span class="pre">common</span></tt> directory, which, among other things, contains the <tt class="docutils literal"><span class="pre">hashtable.erl</span></tt> file.</p>
<p>Check that you have a <tt class="docutils literal"><span class="pre">hashtable.beam</span></tt> file indeed, and that it can be found from the paths specified to the interpreter.</p>
<p></p>
</div>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id96" id="current-stable-version-download" name="current-stable-version-download">7&nbsp;&nbsp;&nbsp;Current Stable Version &amp; Download</a></h1>
<div class="section">
<h2><a class="toc-backref" href="#id97" id="using-stable-release-archive" name="using-stable-release-archive">7.1&nbsp;&nbsp;&nbsp;Using Stable Release Archive</a></h2>
<p>WOOPER 0.2 is ready to be used and can be downloaded <a class="reference" href="http://sourceforge.net/project/showfiles.php?group_id=158516&amp;package_id=239574">here</a>.</p>
<p>Either a <tt class="docutils literal"><span class="pre">.zip</span></tt> or a <tt class="docutils literal"><span class="pre">.tar.bz2</span></tt> can be retrieved. Starting from the 0.1 version, WOOPER should be fully functional (pun intended!).</p>
<p>One way of building all of WOOPER (base files and examples) is, from UNIX or on Windows from a Cygwin or MSYS shell, once the archive is downloaded and extracted, to execute <tt class="docutils literal"><span class="pre">make</span> <span class="pre">all</span></tt> from the WOOPER directory.</p>
<p>For example:</p>
<pre class="literal-block">
tar xvjf wooper-x.y.tar.bz2 &amp;&amp; cd wooper-x.y &amp;&amp; make all
</pre>
<p>It will build and run all, including the various WOOPER test cases.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id98" id="using-cutting-edge-svn" name="using-cutting-edge-svn">7.2&nbsp;&nbsp;&nbsp;Using Cutting-Edge SVN</a></h2>
<p>A SVN (anonymous) check-out of WOOPER code can be obtained thanks to, for example:</p>
<pre class="literal-block">
svn co https://ceylan.svn.sourceforge.net/svnroot/ceylan/Ceylan/trunk/src/code/scripts/erlang Wooper-code-checkout
</pre>
<p>Ceylan developers should used their Sourceforge user name so that they can commit changes:</p>
<pre class="literal-block">
svn co --username Your_SF_User_Name https://ceylan.svn.sourceforge.net/svnroot/ceylan/Ceylan/trunk/src/code/scripts/erlang Wooper-code-checkout
</pre>
<p>Check-out of WOOPER documentation can be performed thanks to:</p>
<pre class="literal-block">
svn co --username YourSFUserName https://ceylan.svn.sourceforge.net/svnroot/ceylan/Ceylan/trunk/src/doc/web/main/documentation/wooper Wooper-doc-checkout
</pre>
<p>If just wanting a SVN anonymous export, use for example:</p>
<pre class="literal-block">
svn export http://ceylan.svn.sourceforge.net/svnroot/ceylan/Ceylan/trunk/src/code/scripts/erlang Wooper-code-export
</pre>
<p>and:</p>
<pre class="literal-block">
svn export http://ceylan.svn.sourceforge.net/svnroot/ceylan/Ceylan/trunk/src/doc/web/main/documentation/wooper Wooper-doc-export
</pre>
<p></p>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id99" id="version-history-changes" name="version-history-changes">8&nbsp;&nbsp;&nbsp;Version History &amp; Changes</a></h1>
<div class="contents local topic">
<p class="topic-title first"><a id="versions" name="versions">Versions</a></p>
<ul class="auto-toc simple">
<li><a class="reference" href="#version-0-4-cutting-edge-in-svn-only" id="id138" name="id138">8.1&nbsp;&nbsp;&nbsp;Version 0.4 [cutting-edge, in SVN only]</a></li>
<li><a class="reference" href="#version-0-3-current-stable" id="id139" name="id139">8.2&nbsp;&nbsp;&nbsp;Version 0.3 [current stable]</a></li>
<li><a class="reference" href="#version-0-2" id="id140" name="id140">8.3&nbsp;&nbsp;&nbsp;Version 0.2</a></li>
<li><a class="reference" href="#version-0-1" id="id141" name="id141">8.4&nbsp;&nbsp;&nbsp;Version 0.1</a></li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id138" id="version-0-4-cutting-edge-in-svn-only" name="version-0-4-cutting-edge-in-svn-only">8.1&nbsp;&nbsp;&nbsp;Version 0.4 [cutting-edge, in SVN only]</a></h2>
<p>Not released yet (work-in-progress).</p>
<p>Should be mainly a BFO (<em>Bug Fixes Only</em>, if bugs were to be found) version, as functional coverage is pretty complete already.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id139" id="version-0-3-current-stable" name="version-0-3-current-stable">8.2&nbsp;&nbsp;&nbsp;Version 0.3 [current stable]</a></h2>
<p>Released on Wednesday, March 25, 2009.</p>
<p>Main changes are:</p>
<blockquote>
<ul class="simple">
<li>destructors are automatically chained as appropriate, and they can be overridden at will</li>
<li>incoming EXIT messages are caught by a default WOOPER handler which can be overridden on a per-class basis by the user-specified <tt class="docutils literal"><span class="pre">onWooperExitReceived/3</span></tt> method</li>
<li>direct method invocation supported, thanks to the <tt class="docutils literal"><span class="pre">executeRequest</span></tt> and <tt class="docutils literal"><span class="pre">executeOneway</span></tt> constructs, and <tt class="docutils literal"><span class="pre">wooper_result</span></tt> no more appended to the result tuple</li>
<li>synchronous spawn operations added or improved: <tt class="docutils literal"><span class="pre">synchronous_new/synchronous_new_link</span></tt> and al; corresponding template updated</li>
<li>state management enriched: <tt class="docutils literal"><span class="pre">popFromAttribute</span></tt> added</li>
<li>all new variations on remote nodes improved or added</li>
<li>major update of the documentation</li>
</ul>
</blockquote>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id140" id="version-0-2" name="version-0-2">8.3&nbsp;&nbsp;&nbsp;Version 0.2</a></h2>
<p>Released on Friday, December 21, 2007. Still fully functional!</p>
<p>Main changes are:</p>
<blockquote>
<ul class="simple">
<li>the sender PID is made available to requests in the instance state variable (see <tt class="docutils literal"><span class="pre">request_sender</span></tt> member, used automatically by the <tt class="docutils literal"><span class="pre">getSender</span></tt> macro)</li>
<li>runtime errors better identified and notified</li>
<li>macros for attribute management added, existing ones more robust and faster</li>
<li>fixed a potential race condition when two callers request nearly at the same time the WOOPER class manager (previous mechanism worked, class manager was a singleton indeed, but second caller was not notified)</li>
<li>improved build (Emakefile generated), comments, error output</li>
<li>test template added</li>
<li>documentation updated</li>
</ul>
</blockquote>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id141" id="version-0-1" name="version-0-1">8.4&nbsp;&nbsp;&nbsp;Version 0.1</a></h2>
<p>Released on Sunday, July 22, 2007. Already fully functional!</p>
<p></p>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id104" id="wooper-inner-workings" name="wooper-inner-workings">9&nbsp;&nbsp;&nbsp;WOOPER Inner Workings</a></h1>
<p>Each instance runs a main loop (<tt class="docutils literal"><span class="pre">wooper_main_loop</span></tt>, defined in <a class="reference" href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/src/wooper.hrl?view=markup">wooper.hrl</a>) that keeps its internal state and through a blocking <tt class="docutils literal"><span class="pre">receive</span></tt> serves the methods as specified by incoming messages, quite similarly to a classical server that loops on an updated state, like in:</p>
<pre class="literal-block">
my_server(S) -&gt;
  receive
			  {command,{M,P}} -&gt;
					  S_new = f(S,M,P),
					  my_server( S_new )
  end.
</pre>
<p>In each instance, WOOPER manages the tail-recursive infinite surrounding loop, <tt class="docutils literal"><span class="pre">S</span></tt> corresponds to the state of the instance (<tt class="docutils literal"><span class="pre">State</span></tt>), and <tt class="docutils literal"><span class="pre">f(S,M,P)</span></tt> corresponds to the WOOPER logic that triggers the user-defined method <tt class="docutils literal"><span class="pre">M</span></tt> with the current state (<tt class="docutils literal"><span class="pre">S</span></tt>) and the specified parameters (<tt class="docutils literal"><span class="pre">P</span></tt>), and that may return a result.</p>
<p>The per-instance kept state is twofold.</p>
<div class="section">
<h2><a class="toc-backref" href="#id105" id="method-virtual-table" name="method-virtual-table">9.1&nbsp;&nbsp;&nbsp;Method Virtual Table</a></h2>
<p>This per-class hashtable is built at runtime, on the first creation of an instance of this class, and stored by the unique (singleton) WOOPER class manager that shares it to all the class instances.</p>
<p>This manager is itself spawned the first time it is needed, and stays ready for all instances of various classes being created (it uses a hashtable to associate to each class its specific virtual table).</p>
<p>This per-class method table has for keys the known method names (atoms) for this class, associated to the values being the most specialised module, in inheritance tree, that defines that method.</p>
<p>Hence each instance has a reference to a shared hashtable that allows for a direct method look-up.</p>
<p>As the table is built only once and is shared by all instances <a class="footnote-reference" href="#id13" id="id12" name="id12">[4]</a>, it adds very little overhead, space-wise and time-wise. Thanks to the hashtable, method look-up is efficient too?</p>
<table class="docutils footnote" frame="void" id="id13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id12" name="id13">[4]</a></td><td>Provided that Erlang does not copy these shared immutable structures.</td></tr>
</tbody>
</table>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id106" id="attribute-table" name="attribute-table">9.2&nbsp;&nbsp;&nbsp;Attribute Table</a></h2>
<p>This is another hashtable, this time per-instance.</p>
<p>Keys are attribute names, values are attribute values.</p>
<p>It allows a seamless yet efficient access to all data members, including inherited ones.</p>
<p>WOOPER relies only on these specific files:</p>
<blockquote>
<ul class="simple">
<li><a class="reference" href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/src/wooper.hrl?view=markup">wooper.hrl</a>: the WOOPER core, which gives to the modules using it all the OOP constructs discussed</li>
<li><a class="reference" href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/src/wooper_class_manager.hrl?view=markup">wooper_class_manager.hrl</a>: the tiny class manager header</li>
<li><a class="reference" href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper/src/wooper_class_manager.hrl?view=markup">wooper_class_manager.erl</a>: the class manager itself, the unique process that is automatically spawned to share virtual tables among instances on a node</li>
<li><a class="reference" href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/common/hashtable.erl?view=markup">hashtable.erl</a>: efficient associative table used by WOOPER for virtual tables, methods, attributes</li>
<li><a class="reference" href="http://ceylan.svn.sourceforge.net/viewvc/ceylan/Ceylan/trunk/src/code/scripts/erlang/common/utils.erl?view=markup">utils.erl</a>: a small module used by the hashtable and other modules</li>
</ul>
</blockquote>
<p>The latest two come from the <tt class="docutils literal"><span class="pre">common</span></tt> sub-module.</p>
<p></p>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id107" id="issues-planned-enhancements" name="issues-planned-enhancements">10&nbsp;&nbsp;&nbsp;Issues &amp; Planned Enhancements</a></h1>
<blockquote>
<ul class="simple">
<li>is <strong>wooper_main_loop</strong> (in <tt class="docutils literal"><span class="pre">wooper.hrl</span></tt>) really tail-recursive? I think so</li>
<li>integrate automatic <strong>persistent storage</strong> of instance states into Mnesia databases</li>
<li>would there be a <strong>more efficient</strong> implementation of hashtables? (ex: using proplists, process dictionary, generated modules, dict or ETS-based?); more generally speaking, some profiling could be done to further increase overall performances</li>
<li>even when pasting a template, having to declare all the new-related operators (ex: <tt class="docutils literal"><span class="pre">new_link/N</span></tt>) is a bit laborious; maybe an appropriate parse transform could do the trick and automate this declaration?</li>
<li>ensure that all instances of a given class <em>reference</em> the same hashtable dedicated to the method look-ups, and do not have each their own private <em>copy</em> of it (mere referencing is expected to result from single-assignment); some checking should be performed; storing a per-class direct method mapping could also be done with prebuilt modules: <tt class="docutils literal"><span class="pre">class_Cat</span></tt> would rely on an automatically generated <tt class="docutils literal"><span class="pre">class_Cat_mt</span></tt> (for &quot;method table&quot;) module, which would just be used to convert a method name to the name of the module that should be called in the context of that class, inheritance-wise</li>
<li>ensure that each of these references remains purely <em>local</em> to the node (no network access wanted for method look-up!); this should be the case thanks to the local WOOPER class manager; otherwise, other types of tables could be used (maybe ETS)</li>
</ul>
</blockquote>
<p></p>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id108" id="licence" name="licence"><span id="open-source"></span>11&nbsp;&nbsp;&nbsp;Licence</a></h1>
<p>WOOPER is licensed by its author (Olivier Boudeville) under a disjunctive tri-license giving you the choice of one of the three following sets of free software/open source licensing terms:</p>
<blockquote>
<ul class="simple">
<li><a class="reference" href="http://www.mozilla.org/MPL/MPL-1.1.html">Mozilla Public License</a> (MPL), version 1.1 or later (very close to the <a class="reference" href="http://www.erlang.org/EPLICENSE">Erlang Public License</a>, except aspects regarding Ericsson and/or the Swedish law)</li>
<li><a class="reference" href="http://www.gnu.org/licenses/gpl-3.0.html">GNU General Public License</a> (GPL), version 3.0 or later</li>
<li><a class="reference" href="http://www.gnu.org/licenses/lgpl.html">GNU Lesser General Public License</a> (LGPL), version 3.0 or later</li>
</ul>
</blockquote>
<p>This allows the use of the WOOPER code in as wide a variety of software projects as possible, while still maintaining copyleft on this code.</p>
<p>Being triple-licensed means that someone (the licensee) who modifies and/or distributes it can choose which of the available sets of licence terms he is operating under.</p>
<p>Enhancements are expected to be back-contributed, so that everyone can benefit from them.</p>
<p></p>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id109" id="sources-inspirations-alternate-solutions" name="sources-inspirations-alternate-solutions">12&nbsp;&nbsp;&nbsp;Sources, Inspirations &amp; Alternate Solutions</a></h1>
<blockquote>
<ul class="simple">
<li><strong>Concurrent Programming in Erlang</strong>, Joe Armstrong, Robert Virding, Claes Wikstrm et Mike Williams. Chapter 18, page 299: Object-oriented Programming. This book describes a simple way of implementing multiple inheritance, without virtual table, at the expense of a (probably slow) systematic method look-up (at each method call). No specific state management is supported</li>
<li>Chris Rathman's <a class="reference" href="http://www.angelfire.com/tx4/cus/shapes/erlang.html">approach</a> to life cycle management and polymorphism. Inheritance not supported</li>
<li>As Burkhard Neppert suggested, an alternative way of implementing OOP here could be to use Erlang behaviours. This is the way OTP handles generic functionalities that can be specialised (e.g. <tt class="docutils literal"><span class="pre">gen_server</span></tt>). One approach could be to map each object-oriented base class to an Erlang <strong>behaviour</strong>. See some guidelines about <a class="reference" href="http://wiki.trapexit.org/index.php/Defining_Your_Own_Behaviour">defining</a> your own behaviours and making them <a class="reference" href="http://wiki.trapexit.org/index.php/Cascading_Behaviours">cascade</a></li>
<li>As mentioned by Niclas Eklund, despite relying on quite different operating modes, WOOPER and <a class="reference" href="http://www1.erlang.org/doc/apps/orber/index.html">Orber</a>, an Erlang implementation of a <strong>CORBA ORB</strong> (<em>Object Request Broker</em>) offer similar OOP features, as CORBA IDL implies an object-oriented approach (see their <a class="reference" href="http://www.erlang.org/doc/apps/orber/ch_idl_to_erlang_mapping.html#6">OMG IDL to Erlang Mapping</a>)</li>
</ul>
</blockquote>
<p>WOOPER and Orber are rather different beasts, though: WOOPER is very lightweight (less than 2300 lines, including blank lines and numerous comments), does not involve a specific (IDL) compiler generating several stub/skeleton Erlang files, nor depends on OTP or Mnesia, whereas Orber offers a full CORBA implementation, including IDL language mapping, CosNaming, IIOP, Interface Repository, etc.</p>
<p>Since Orber respects the OMG standard, integrating a new language (C/C++, Java, Smalltalk, Ada, Lisp, Python etc.) should be rather easy. On the other hand, if a full-blown CORBA-compliant middleware is not needed, if simplicity and ease of understanding is a key point, then WOOPER could be preferred. If unsure, give a try to both!</p>
<p>See also another IDL-based approach (otherwise not connected to CORBA), the <a class="reference" href="http://www.erlang.org/doc/apps/ic/ch_erl_genserv.html#5">Generic Server Back-end</a> (wrapper around <tt class="docutils literal"><span class="pre">gen_server</span></tt>).</p>
<p>The WOOPER name is also a tribute to the underestimated <a class="reference" href="http://en.wikipedia.org/wiki/WarGames">Wargames</a> movie (remember the <a class="reference" href="http://en.wikipedia.org/wiki/WOPR">WOPR</a>, the NORAD central computer?), which the author enjoyed a lot. It is as well a second-order tribute to the <em>Double Wooper King Size</em> (<em>Whopper</em> in most if not all countries), which is/was a great hamburger indeed (in France, they are not available any more).</p>
<p></p>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id110" id="support" name="support">13&nbsp;&nbsp;&nbsp;Support</a></h1>
<p>Bugs, questions, remarks, patches, requests for enhancements, etc. are to be sent to the <a class="reference" href="mailto:ceylan-wooper&#64;lists.sourceforge.net">ceylan-wooper at lists dot sourceforge dot net</a>.</p>
<p>One must <a class="reference" href="https://lists.sourceforge.net/lists/listinfo/ceylan-wooper">register</a> first.</p>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id111" id="for-wooper-developers" name="for-wooper-developers">14&nbsp;&nbsp;&nbsp;For WOOPER Developers</a></h1>
<p>When a new WOOPER version is released, tag the corresponding file versions, like in:</p>
<pre class="literal-block">
svn copy https://ceylan.svn.sourceforge.net/svnroot/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper https://ceylan.svn.sourceforge.net/svnroot/ceylan/Ceylan/tags/wooper-release-0.1 -m &quot;First release (0.1) of WOOPER, already fully functional.&quot;
</pre>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id112" id="please-react" name="please-react">15&nbsp;&nbsp;&nbsp;Please React!</a></h1>
<p>If you have information more detailed or more recent than those presented in this document, if you noticed errors, neglects or points insufficiently discussed, <a class="reference" href="mailto:olivier (dot) boudeville at online dot fr?subject=[Ceylan]%20WOOPER">drop us a line</a>!</p>
</div>
</div>
</body>
</html>
