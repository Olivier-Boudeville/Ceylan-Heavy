<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/REC-html40/loose.dtd">
<!--    This document is a part of the Ceylan project. 
        For any comment, please mail to olivier.boudeville@online.fr
-->
<!--    
        Creation date : Saturday, July 7, 2007.
        Author : Olivier Boudeville (olivier.boudeville@online.fr)
        Update made by :  the author
        Version number : 0.1
-->

<html lang="EN">
<head>
  <title>Ceylan - WOOPER documentation</title>
  <meta http-equiv="Content-Type" content=
  "text/html; charset=iso-8859-1">
  <meta name="description" content="Ceylan">
  <meta name="keywords" content="Ceylan, generic, GPL">
  <link href="../../../images/Ceylan-icon.png" rel="Ceylan icon">
  <link rel="STYLESHEET" type="text/css" href="../../../common/css/Ceylan.css">
</head>

<body>
  <div class="banner">
    <p><em>General</em> <a href="../../../common/black.html" onclick= 
    "parent.toolbar.location='../../MainMenu.html'">home page</a>
    <a href="../../Map.html">site map</a> <a href=
    "mailto:olivier.boudeville@online.fr?subject=[Ceylan]%20WOOPER">
    mail us</a></p>
  </div><a name="_top_"></a></span> 



<h1>WOOPER : <em>Wrapper for OOP in Erlang</em></h1>

<p>
WOOPER is a lightweight layer on top of the <a href="http://erlang.org" target="_blank">Erlang</a> language offering constructs dedicated to <a href="http://en.wikipedia.org/wiki/Object-oriented_programming" target="_blank">Object-Oriented Programing</a>. It is released through the <a href="http://en.wikipedia.org/wiki/GNU_Lesser_General_Public_License" target="_blank">LGPL</a> license version 3 (programs making use of WOOPER are not considered as derivative works, hence fall outside the scope of this license and need not being free nor open-source).
</p>

<p>
To reassure the reader about the ease of development with WOOPER, here is an example of what a class may look like :
<center>
    <table summary="Code" style="border : none">
        <tr>
          <td>
            <div class="box">
<code><pre>

</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
Straightforward, isn't it ? We will discuss it in-depth though.
</p>



<p>

<a name="maintoc"></a>
<center>
        <table summary="Table of contents" style="border: none">
        <tr>
          <td>
<!--
                       <a href="#"></a><br>
-->

                   <div class="box">
                       <a href="#usage">Usage</a><br>
                       <a href="#example">Example</a><br>
                       <a href="#inner">Inner workings</a>
          </div>

          </td>
        </tr>
      </table>
</center>

</p>

<!--
<br><p><center>[<a href="#maintoc">Back to the table of contents</a>]</center></p><br><br>
-->

<a name="usage"></a>
<h2>WOOPER usage</h2>


<h3>Why adding Object-oriented elements to Erlang ?</h3>

<p>
Although applying blindly OOP with languages based on other paragdims (Erlang ones are functional and concurrent, it is not specifically targeting OOP) is a common mistake, there are some problems that may be deemed inherently "object-oriented", i.e. that cannot be effectively modelled without encapsulated abstractions sharing behaviours. 
</p>

<p>
Examples of this kind of systems are multi-agent simulations. If they often need massive concurrency, robustness, distribution, etc. (Erlang is particularly suited for that), the various actor types have also often to share numerous states and behaviours, while being able to specialize them on a per-type basis.
</p>

<p>
The <a href="#example">example</a> chosen here is a simulation of the interacting lives of numerous animals from various species. Obviously, they have to share behaviours (ex : all ovoviviparous beings may lay eggs, all creatures can live and die, all have an age, etc.), which cannot be mapped easily (read: automatically) to Erlang concepts without some generic constructs being added.
</p>

<p>
WOOPER, which stands for <em>Wrapper for OOP in Erlang</em>, is a lightweight yet effective (performance-wise, but also regarding developing efforts) means of making these constructs available, notably with regard to state management and multiple inheritance. The same simulations could be achieved without such OOP constructs, but at the expense of way too much manually-crafted specific (per-class) code. This process would be tedious, error-prone, and the result most often could be hardly maintained. 
</p>


<h3>How to use it ?</h3>


<h4>Concept mappings</h4>


<p>
<b>Encapsulation</b> is based into classes being defined as Erlang modules. A convention is to prefix the class name by <code>class_</code> to form the module name. So a class modelling a cat would be defined in a module named <code>class_Cat</code>, defined in a file named <code>class_Cat.erl</code>. At the top of this file, the corresponding module would be therefore declared with: <code>-module(class_Cat).</code>
</p>

<p>
Being in a <b>multiple inheritance</b> context, a given class can have any number ([0..n]) of direct mother classes (which themselves may have mother classes, and so on). This is declared in WOOPER thanks to the <code>superclass</code> define. For example, a class with no mother class should have, once its module is declared, <code>-define(superclasses,[]).</code>. As for our cat, this animal could be considered both as a mammal and a viviparous being (neither of them is a subset of the other, these are mostly unrelated concepts; at least for that example !). Hence its mother classes could be described as : <code>-define(superclasses,[class_Mammal, class_ViviparousBeing]).</code>
</p>

<p>
With WOOPER, which focuses on multi-agent systems, all <b>instances</b> of a class are mapped to Erlang processes. They are therefore, in UML language, <em>active objects</em> (each has its own thread of execution, they apparently "live" simultaneously).
</p>

<p>
Another part of encapsulation is state management : each instance should be stateful, and able to inherit the data members defined by its mother classes. In WOOPER, this is obtained thanks to a per-instance associative table. Methods
</p>


<p>
Instances may offer methods that can be publicly called, including remotely (RMI : <em>Remote Method Invocation</em>). Methods are mapped to specific Erlang functions, triggered by messages. For example, our cat may define following methodq :
<ul>

<!--
	<li></li>
-->
	<li><code>canEat</code>, taking one parameter describing the type of food, and returning whether the cat can eat or not</li>
	<li><code>getWhiskersColor</code>, returning the color of its whiskers</li>
	<li><code>declareBirthday</code>, incrementing the age of our cat, not taking any parameter nor returning anything. This is therefore a one-way call only interesting for its side-effect : changing the state of the cat</li>

</ul>
 We will see their definition later, but for the moment let's determine their signatures and declarations, and how we are expected to call them.
</p>

<p>
Such methods are to be declared in a <code>wooper_method_export</code> clause, with an arity being equal to the number of parameters they should be given plus one (the implicit first parameter corresponding to the state of the instance). In our example, it would result in : <code>-define(wooper_method_export,canEat/2,getWhiskersColor/1).</code>. If MyCat is an instance of <code>class_Cat</code>, these methods could be called this way :
<center>
    <table summary="Code" style="border : none">
        <tr>
          <td>
            <div class="box">
<code><pre>
MyCat ! {canEat,soup,self()},
receive

	{result,true} ->
		io:format( "This cat likes soup !!!" )

	{result,_} ->
		io:format( "This cat does not seem omnivorous." )
		
end,

MyCat ! {getWhiskersColor,[],self()},
receive
		
	{result,white} ->
		io:format( "This cat has normal whiskers." ) ;
		
	{result,blue} ->
		io:format( "Are you sure it is a cat ?" )

end,

MyCat ! declareBirthday,	
end.	
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>
</p>

<p>
Some information must be given here : methods are designated by their atom name (as declared in <code>wooper_method_export</code>), which is always the first information given. There are requests (that return a result) and one-way calls. Both can take any number of parameters, including none. They are to be specified in a (possibly empty) list; if only one parameter is needed, the list can be omitted, and the parameter can be directly specified.
</p>

<p>
Requests have to specify an additional information, the PID to which the answer should be sent, almost always the caller (hence the <code>self()</code>). Finally these three potential information (method name, parameter, sender, i.e. an atom, a list and a PID) are gathered in a tuple sent as a message : <code>{method_name,[Arg1,Arg2,..],self()}</code>
. One-ways do not have to specify a sender (if ever they send one nevertheless, a warning will be sent to them, the atom <code>FIXME</code>). Hence they may be 2-element tuples (<code>{method_name,[Arg1,Arg2,..]}</code> or, if they do not take parameters, <code>method_name</code>.
</p>

<p>
As for the result, if the method execution succeeded, <code>{result,ActualResult}</code> will be sent back, otherwise one of the following error messages will be emitted :
<ul>

<!--
	<li><b></b> : </li>
-->

	<li><b>FIXMEmethod_not_found</b> : </li>
</ul>
Marshalling of parameters and return value is made automatically by Erlang.  
</p>


<p>
Inheritance and polymorphism are managed by WOOPER : even if our cat class does not define a <code>getAge</code> method, it can be readily be used thanks to inheritance from its mother classes (here from Creature, an indirect mother class), and all Creature instances can be handled the same :

<code><pre>
% Inherited methods work exactly the same as methods defined directly 
% in the class:
MyCat ! {getAge,[],self()},
receive
		
	{result,Age} ->
		io:format( "This is a ~B year old cat.", [Age] ) ;

end,

% Polymorphism is immediate:
% (class_Platypus inheriting too from class_Creature)
MyPetList = [ MyCat, MyPlatypus ],
foreach( 
	fun(AnyCreature) ->
		AnyCreature ! {getAge,[],self()},
		receive
		
			{result,Age} ->
				io:format( "This is a ~B year old creature.", [Age] ) ;

		end,
	MyPetList).
</pre></code>

</p>



life-cycle


% Constructor will need two actual attributes here (age and gender), so
% new/2 and construct/3 will have to be exported :
-define(wooper_construct_attributes,Age,Gender).

% isHotBlooded/1 and canEat/2 are abstract hence not mentioned here :
-define(wooper_export,new/2,construct/3,getAge/1,setAge/2,declareBirthday/1,
	getGender/1,listen/3).



% Allows to define WOOPER base variables and methods for that class :
-include("wooper_class_root.hrl").



GPL mailing list : 

<p>
Needed files are :

<ul>

<!--
    <li><a href="" target="_blank"></a></li>
-->

    <li><a href="" target="_blank">wooper_class_root.hrl</a></li>
    <li><a href="" target="_blank">hashtable.erl</a></li>
    <li><a href="" target="_blank"></a></li>
    <li><a href="" target="_blank"></a></li>
</ul>
</p>


<p>
The hashtable module must be compiled beforehand : 
<center>
    <table summary="Code" style="border : none">
        <tr>
          <td>
            <div class="box">
<code><pre>
1> c(hashtable).
{ok,hashtable}
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>

</p>

<p>
WOOPER is in some ways adding features very similar to the ones of python (simple multiple inheritance, <code>self</code> parameter, attribute dictionaries, etc.; with less syntatic sugar available though) while still offering the major strengths of Erlang (concurrency, distribution, functional paradigm) and not hurting too much overall performances (mainly thanks to the prebuilt attribute and method hashtables).
</p>

<br><p><center>[<a href="#maintoc">Back to the table of contents</a>]</center></p><br><br>




<a name="example"></a>
<h2>WOOPER example</h2>
<p>
<center>
    <a href="wooper-example.png" target=_blank"><img src="wooper-example.png" alt="WOOPER example" width="95%"></img></a><br>
(click to enlarge)
</center>
</p>


<br><p><center>[<a href="#maintoc">Back to the table of contents</a>]</center></p><br><br>




<a name="inner"></a>
<h2>WOOPER inner workings</h2>
<p>
A method signature has always for first parameter the state of the instance (ex : getAge(State)).
It must always return at least the new state (even if it did not change the state it received as a parameter).
Depending on its returning a specific result, its signature will be either :

	{return,Newstate,Result} 

or 
	{return,Newstate} 

Ex : 

getAge(State) ->
	{return,State,getAttribute(State,age)}.
A result and state is unchanged.

setAge(State,NewAge) ->
	{return,setAttribute(State,age,NewAge)}.
No result and the state changed.

displayAge(State) ->
	io:format("My age is ~w~n.",[getAttribute(State,age)]),
	{return,State}.
No result and the state is unchanged (only a side-effect here).



When a method F/n is called, WOOPER tries to find F(State,arg1,..,argn-1).
It may or may not be found : name and arity must match.
If it is not found, the method_not_found atom is returned, and the object state did not change.
If it is found, the method must return to WOOPER (directly) {return,NewState,Result}. 
NewState is reused by WOOPER to update the object state, whereas Result (in the form {result,Result}) will be sent to the caller.

Oneway :

MyPoint ! {setXY,[1,2]}


Request :

MyPoint ! {get_coordinates,[],self()},
receive

	{result,[X,Y]} ->
		[...];
	
	% Can be left out (let it crash) :
	Error ->
		[...]
end,

Errors can be better discriminated if needed ;

	{method_not_found,Module,Method,Arity} ->
		[...];

	{method_failed,Module,Method,Arity,Message} ->
		[...];

	{method_faulty_return,Module,Method,Arity} ->
		[...];

	{method_returns_void} ->

	OtherError ->
		% Should never happen :
		[...]

</p>

<p>
As Burkhard Neppert suggested, an alternative way of implementing OOP here could be to use Erlang behaviours. This is the way OTP handles generic functionalities that can be specialized (e.g. <code>gen_server</code>). One approach could be to map each objet-oriented base class to an Erlang behaviour. 
</p>

<p>
See some guidelines about <a href="http://wiki.trapexit.org/index.php/Defining_Your_Own_Behaviour" target="_blank">defining</a> your own behaviours and making them <a href="http://wiki.trapexit.org/index.php/Cascading_Behaviours" target="_blank">cascade</a>.
</p>


<br><p><center>[<a href="#maintoc">Back to the table of contents</a>]</center></p><br><br>

 <br>
  <br>
  <br>
  <br>

  <h3>Please react !</h3>

  <p>If you have information more detailed or more recent than those
  presented in this document, if you noticed errors, neglects or points
  insufficiently discussed, <a href=
  "mailto:olivier.boudeville@online.fr?subject=[Ceylan]%20WOOPER">
  drop us a line</a>!</p><br>
  <br>
  <hr>

  <center>
    [<a href="#_top_">Top</a>]
    <br>
    <br>
    <em>Last update : Saturday, July 7, 2007</em>
  </center>
</body>
</html>

<html>

<h1>WOOPER : Wrapper for OOP in ERlang</h1>

<h2>Understanding this object-oriented support added on top of Erlang</h2>
<p>
Polymorphism and inheritance are very convenient ways of modeling. The set of
conventions proposed here allows to have them available with Erlang, so that
object-oriented approach at the implementation-level can be easily achieved, for the case where it makes sense.
</p>


<h2>Conventions</h2>


<h3>Classes</h3>
<p>
A class is a common scheme describing the behaviour and the internal data of its instances.
</p>

<p>
A class can inherit from another class, in this case the behaviour and the internal data of the mother class are available by default to the child class. Each class has a unique name.
</p>

<p>
Here a class is mapped to an Erlang module, whose name is made from the <code>class_</code> prefix followed by the class name, in lowercase. For example, a class named <code>Car</code> should translate into an Erlang module named <code>class_car</code>, thus in a file named <code>class_car.erl</code>
</p>

<p>
The class name can be obtained through its <code>get_class_name</code> method :

<center>
    <table summary="Code" style="border : none">
        <tr>
          <td>
            <div class="box">
<code><pre>
&gt; class_car:get_class_name().
"Car"
</pre></code>
            </div>
          </td>
        </tr>
    </table>
</center>

</p>



<h3>Instances, a.k.a. Objects</h3>
<p>
An object (which is an instance of a class, with its own execution thread, active object in UML language) is able to expose a public interface (a kind of API for a server) that can be used by clients to trigger RMI-like calls.
</p>

<p>
An object must be created through a special function defined by its class, the operator <code>new</code>, that will call a constructor. Example : <code>My_car = class_car:new("Dodge","Viper").</code>. 
</p>

<p>
Example : <code>-module(my_class)...</code> in my_class.erl defines a class <code>my_class</code>.
</p>


<p>
An interface is a set of public methods. Interfaces are inherited between classes.
</p>



<h3>Methods</h3>
<p>
There are two kinds of possible methods to an object : requests and oneways.
Requests are supposed to send back an answer to the caller (the client), whereas oneways are just handled by the server, with no answer to expect from the client side. Both can be either with or without arguments.
</p>


<h3>Requests</h3>
<p>
To send an answer to the client, the server needs to know its PID, hence requests have to specify it.
</p>

<p>
Moreover the client needs to be able to sort out multiple asynchronous answers to requests it may have sent to different (server) objects, so the answer to requests have to send back the PID of the server as well.
</p>



<h3>Oneways</h3>
<p>

</p>


<h3>Sources</h3>

<p>
<!--
    <li><a href="" target="_blank"></a></li>
-->

    <li>Chris Rathman 's <a href="http://www.angelfire.com/tx4/cus/shapes/erlang.html" target="_blank">approach</a>to polymorphism</li> 
    <li><b>Concurrent Programming in Erlang</b>, Joe Armstrong, Robert Virding, Claes Wikström et Mike Williams. Chapitre 18, p.299 : Object-oriented Programming</li>
</ul>

</p>

Constructors must be designed to be called by the ones of child classes, and they must call themselves the constructors of their mother classes, if any. Hence they always take the current state of the instance being created as a starting base, and returns it once updated, first from the mother classes, then by this class itself.

Ensure that in constructors, the successive states are always built from the last updated one : 

WRONG, age update lost :
construct(State,Age,Sex) ->
	AgeState = setAttribute(State,age,Age),
	setAttribute(State,sex,Sex),

RIGHT
construct(State,Age,Sex) ->
	AgeState = setAttribute(State,age,Age),
	setAttribute(AgeState,sex,Sex),

Calls with only one parameter do not need to put it in a list : 
Z ! {setAge,30} works as well as Z ! {setAge,[30]}.


If an error occurs with a oneway call, the sender (the client) will never be notified.


  <br>
  <br>
  <br>

  <h3>Please react !</h3>

  <p>If you have information more detailed or more recent than those
  presented in this document, if you noticed errors, neglects or points
  insufficiently discussed, <a href=
  "mailto:olivier.boudeville@online.fr?subject=[Ceylan]%20WOOPER">
  drop us a line</a>!</p><br>
  <br>
  <hr>

  <center>
    <a href="#_top_">Top</a><br>
    <br>
    <em>Last update : Wednesday, July 18, 2007</em>
  </center>
</body>
</html>
