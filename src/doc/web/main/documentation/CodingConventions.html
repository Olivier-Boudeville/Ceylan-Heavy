<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/REC-html40/loose.dtd">
<!--    This document is part of the Ceylan project.
		For any comment, please mail to olivier.boudeville@online.fr
-->

<!--
		Creation date: 2004, October 1.
		Author: Olivier Boudeville (olivier.boudeville@online.fr)
-->

<html lang="EN">

<head>
  <title>Ceylan - Coding conventions</title>
  <meta http-equiv="Content-Type" content=
  "text/html; charset=iso-8859-1">
  <meta name="description" content="Ceylan">
  <meta name="keywords" content="Ceylan, library, coding, conventions">
  <link rel="stylesheet" type="text/css" href="../../common/css/Ceylan.css">
  <link href="../../images/Ceylan-icon.png" rel="Ceylan icon">
</head>

<body>


  <div class="banner">
	<p><em>General</em> <a href="../../common/black.html" onclick="parent.toolbar.location=&#39;../MainMenu.html&#39;">home page</a>
	<a href="../Map.html">site map</a> <a href="mailto:olivier.boudeville@online.fr?subject=[Ceylan]%20Coding%20conventions">mail us</a></p>
  </div><a name="_top_"></a>



  <h1>Coding conventions recommended by the Ceylan project</h1>


  <h2>Overview</h2>

  <p>We listed here the main conventions we adopted regarding developments, in the hope of promoting:

  <ol>

	<li>coding good practices [see our <a href="CodingGoodPractises.html">dedicated section</a>]</li>

	<li>a well-documented, homogeneous and easily read code</li>

  </ol>

</p>

<p>
This document currently focuses on general conventions and on C++ specific ones. It will nonetheless include hints for other languages as well, notably the sh shell, Python and Erlang.
</p>


<p>
In <code>Makefile.am</code>, header files (<code>*.h</code>) and source files (<code>*.cc</code>) should be listed alphabetically (hint: use <code>/bin/ls -1 *.cc</code> for example), each file being on a line of its own thanks to the <code>\</code> separator, which should be one space after the variable declaration (ex: <code>LOGS_INTERFACES = \</code>), whereas all filenames, except the last, have a final <code>\</code> at column 50, with no trailing space.
</p>

<p>
All tests should be named <code>test + library name + subject</code>, for example: <code>testCeylanLogSource</code>
</p>

<p>
Regularly, <code>autoupdate</code> should be used to have state-of-the-art configure settings:
<center>
	<table summary="a box" style="border: none">
		<tr>
		  <td>
			<div class="box">
autoupdate configure-template.ac
diff configure-template.ac configure-template.ac~
			</div>
		  </td>
		</tr>
	</table>
</center>
Beware though, <code>autoupdate</code> changes must be carefully checked, the tool tends to remove useful <code>[]</code> quotes for example.
</p>

Not all Autoconf/Automake commands can accept variable substitution (i.e. if A=1 they would take litteraly argument $A as $A instead of 1).

It is the case of at least:
	- AC_INIT
	- AC_CONFIG_SRCDIR
	- AC_CONFIG_HEADERS

This lack of feature is rather annoying, since it prevents to define a value one time for all, in only one place.

For example, we would have liked to be able to write:

CEYLAN_MAJOR_VERSION=0
CEYLAN_MINOR_VERSION=3
CEYLAN_RELEASE=0

CEYLAN_VERSION=$CEYLAN_MAJOR_VERSION.$CEYLAN_MINOR_VERSION
CEYLAN_FULL_VERSION=$CEYLAN_VERSION.$CEYLAN_RELEASE

CEYLAN_MAILING_LIST_SUPPORT="ceylan-support@lists.sourceforge.net"
CEYLAN_CONFIG_HEADER="code/CeylanConfig.h"

AC_INIT([Ceylan], $CEYLAN_FULL_VERSION, $CEYLAN_MAILING_LIST_SUPPORT)
AC_CONFIG_SRCDIR($CEYLAN_CONFIG_HEADER.in)
AC_CONFIG_HEADERS($CEYLAN_CONFIG_HEADER)

etc.

Instead of which, we had to resort to the following work-around to secure the version one-time assignment:

AC_INIT([Ceylan], m4_normalize(m4_include([conf/build/version.inc])), [ceylan-support@lists.sourceforge.net])


with version.inc being:

dnl="This rather convoluted file allows to centralize version numbers while "
dnl="being able to be both sourced by shell scripts and included by m4."
dnl="It can be generated by the 'generateVersionFile.sh' script."
dnl=; MAJOR=0; MINOR=0; RELEASE=3 ; RELEASE_DATE="Saturday, January 28, 2006"; m4_hiding_string="\
0.0.3
dnl "

As this is a rather complicated scheme and it solves only the version issue, we finally preferred to come back to our first move: generating 'configure.ac' from a template ('configure-template.ac') and settings (read from 'CeylanSettings.inc'). In the template, Substitution Targets (tags beginning with 'ST_') are replaced by their values as defined in the settings file.

This cumbersome process should only apply to variables whose definitions would have to be duplicated because of configure.ac calls.



Release:
<p>
Before you release a distribution of your project, it is wise to get the latest versions of `config.guess' and `config.sub' from the GNU site(21), since they may be newer than the versions automatically added by libtoolize and automake. Note that automake --add-missing will give you its own version of these two files if `AC_PROG_LIBTOOL' is not used in the project `configure.in', but will give you the versions shipped with libtool if that macro is present!

next: when API is stable and there are users, use libtool library versioning http://sources.redhat.com/autobook/autobook/autobook_91.html#SEC91
</p>


<p>
Make sure that <code>#if</code> is used instead of <code>#ifdef</code>, since setting a symbol to a value or another (typically, <code>-DA_CEYLAN_SYMBOL=1</code>) is more robust than setting a symbol or not (typically, <code>-DA_CEYLAN_SYMBOL</code>). For example, the <code>-Wundef</code> gcc options issues a warning if an undefined identifier is evaluated in an `#if' directive.
</p>

<p>
The problem arises when using <code>AC_CHECK_HEADERS</code>: either, if the header is found, it defines <b>and</b> set to 1 a variable (ex: <code>#define HAVE_DUP2 1</code>), either, if the header is not found, it does not define anything special (ex: it does do <code>#define HAVE_DUP2 0</code> for instance).
</p>

<p>So, to rely on <code>-Wundef</code> for our own defines, we may test them with <code>#if CEYLAN_DEBUG</code> and enforce setting a value for each of our symbols (they are defined in all cases, ex: <code>#define CEYLAN_DEBUG 0</code> or <code>#define CEYLAN_DEBUG 1</code>), and test <code>AC_CHECK_HEADERS</code>-ones simply with <code>#ifdef HAVE_DUP2</code> instead of <code>#if HAVE_DUP2</code> (otherwise <code>-Wundef</code> would issue warnings or errors about it).
</p>



#define HAVE_DUP2 1

<h2>General purpose coding conventions</h2>


<h3>File layout</h3>

<p>
Source file are formatted so that they are best viewed with an 80-column wide text editor, with tabulation stops being four space wide.
</p>

  <h3>Nommage des fichiers</h3>
Préfixer par nom de projet (ex: Utils.h et Log.h)
namespace
commencer les noms de membres statiques (méthodes et données) par une majuscule.

  <p>Certains utilitaires d'archivage, tels qu'au moins
  certaines versions de WinZip, ne supportent pas que deux fichiers,
  situés à deux endroits de l'arborescence, portent le même nom
  (tous les fichiers sont stockés ensemble dans l'archive,
  indépendamment des répertoires). De ce fait, des conventions
  voudraient que, les répertoires ne formant pas toujours des espaces
  de nommage cloisonnés, les noms de fichiers soient par exemple
  préfixés par le nom du projet (ex: OSDLVideo.h). On essaie de
  respecter cette habitude, dans la mesure du possible.</p>

  <h2>Bonnes pratiques C++</h2>

  <h3>Fichiers</h3>

  <p>Correspondance entre type de fichier et extension:</p>

  <div class="c1">
	<table summary="Correspondance">
	  <tr>
		<th>Type de fichier</th>

		<th>Extension</th>
	  </tr>

	  <tr>
		<td>Fichier header (interface)</td>

		<td>.h</td>
	  </tr>

	  <tr>
		<td>Fichier source (implémentation)</td>

		<td>.cc</td>
	  </tr>
	</table>
  </div>

  <h3>Nommage</h3>

  <ul>
	<li>la langue à favoriser pour les développements est
	l'anglais, pour des raisons de concision, et d'usage
	international, des non-francophones pour être amenés à travailler
	sur notre code (correction ou enrichissement) ou à
	l'utiliser.</li>

	<li>nom des méthodes</li>

	<li>pour favoriser la modularité et diminuer les risques de
	collision de nom, les espaces de nommage (<em>namespaces</em>),
	anonymes ou non, seront utilisés (déclaration: <code>namespace
	myNamespace { ... }</code>, utilisation: <code>using namespace
	MyNamespace</code> ou <code>MyNamespace::MySymbole</code>).</li>

	<li>les noms des données-membres d'une classes seront préfixés
	par m_ (ex: m_width): préfixés afin de les distinguer des
	variables qui ne sont pas des variables de classes, et préfixés
	spécifiquement par m_ et non pas _ afin d'éviter les ambiguïtés
	quand du code C++ est compilé avec du code C, pour lequel
	_unSymbole a un sens particulier.</li>
  </ul>

<h4>Expressions</h4>
<p>
<code>iff</code> means <em>if and only if</em>. Used when two logic expressions are equivalent.
</p>

<h4>General C++</h4>
<p>
<ul>
	<li>No method should be named <b>register</b>, since it is a reserved keyword.</li>
	<li>All classes having at least one data member pointing to dynamic parts should <b>redefine irrelevant default copy C++ behaviours</b>, namely:
	<ol>
		<li>the copy constructor: <code>MyClass( const Myclass & source ) throw()</code></li>
		<li>the assignment operator: <code>MyClass & operator = ( const MyClass & source ) throw()</code>)</li>
	</ol>
	Note that, if the object should not be copied, one just has to declare them both as private, and does not even need to define them.
</ul>

<p>
Of course, a preferably <code>virtual</code> destructor should be defined on these cases, and at least a classic (non-copy) constructor. Never throw an exception from a destructor, doing so is calling for a disaster.
</p>

<p>For all classic constructors that <b>can</b> be called with only one argument (be there only one argument, or multiple arguments, with at least all but one having a default value), the <code>explicit</code> keyword should be used. For example, a declaration such as <code>explicit Object( bool trackInstance = true, bool dropIdentifierOnExit = true ) throw( Log::LogException )</code> should have the <code>explicit keyword</code>, since a clumsy attempt to call a function <code>f( Object a )</code> with <code>f( this ) ;</code> (which is an error indeed since it should have been <code>* this</code>, <code>this</code> being a pointer) apparently is interpreted by the compiler as: <code>f( Object( static_cast&lt;bool&gt;( this )))</code>: the pointer <code>this</code>, a numerical type, is converted to a boolean so that the copy constructor can be called as if its two arguments were true (<code>trackInstance</code> because of pointer, <code>dropIdentifierOnExit</code> because of default value).
</p>



<ul>
	<li><b>const qualifiers</b> should be used everywhere where possible.</li>
	<li>In fonction signatures, the <b>throw</b> statement should always be present and exactly filled, whether the function or method might raise and/or propagate an exception or not (in this cas, <code>throw()</code> would be used).</li>
	<li>Wide use of <b>references</b> should be made.</li>
	<li><b>Unit tests</b> should be written systematically.</li>
	<li>Never use in header files (*.h) <b>using declarations</b>, such as <code>using std::string</code> or, even worse, <code>using namespace &lt;a namespace&gt;</code>, since every code which would include this header would have global names declared, possibily hiding a lack of internal declaration. Consider, as much as possible, using explicit prefixs each time a type name defined in a namespace is used. Therefore, prefer in header files <code>std::string myString</code> to <code>using std::string; [...] string myString</code>.</li>
	<li>if, in an header file, a type name is used only through a pointer or a reference (such as, for the type <code>myType</code>, <code>aFunction( myType & arg)</code> and <code>myType * aVariable</code>), the compiler does only need a <b>declaration</b> for it (such as <code>class myType ;</code>). It is not necessary for it to have this type's <b>definition</b>. Therefore, only declaring this type in the header file (without <code>#include ...</code>) would accelerate compilation, since less files should have to be read and parsed. For big projects, the gain is obvious.</li>
	<li>avoid, in C++, using the <code>struct</code> data type, and prefer using <code>class</code> declarations: a <code>struct</code> is indeed a particular case of a <code>class</code>, thus a full use of <code>class</code> data type with corresponding <code>public</code>, <code>private</code> and <code>protected</code> statements should be more uniform, and clearer for the reader.</li>
	<li>when checking whether a pointer is null or not, one should preferably compare it to <code>0</code> (zero) than to <code>NULL</code> or <code>null</code> or anything else.</li>
	<li>Similarly, <code>true</code> and <code>false</code> boolean values should be used directly, not as #defined' <code>TRUE</code> or <code>FALSE</code></li>
	<li>In an implementation file (*.C), the necessary header files should be listed at the beginning, <b>from the more specific to the least</b>. For example, file <code>X.c</code> should begin with <code>#include "X.h"</code>, then <code>#include "Y.h"</code>, then <code>#include &lt;climits&gt;</code>, for example. This allows to check immediatly that the corresponding header file (here, <code>X.h</code>), is defined with all its dependencies, and therefore does not rely on any external includes.</li>
	<li>One and only one log system should be used, the <code>Ceylan::Log</code> one, with its log plugs.</li>
	<li>The first letter of a class static member (data or method) should be uppercased: <code>MyObject::MyStaticMethod</code>, not <code>MyObject::myStaticMethod</code></li>
	<li>Avoid writing tests implying implicit converting a non-bool type to bool (ex: <code>void * myPointer; if ( myPointer ) ... </code> less readable than <code>if ( myPointer == 0 ) ...</code>
</li>
</ul>

 <h3>Method order</h3>

<p>
The three main sections should be not split, and should be ordered this way:
<ol>
	<li>public</li>
	<li>protected</li>
	<li>private</li>
</ol>
</p>

<p>
When enumerating the methods of a class, be it for declaration (*.h) or definition (*.cc), the same order should apply, in each of the three previously discussed main sections:
<ol>
	<li>constructors</li>
	<li>virtual destructor</li>
	<li>non inherited non-static methods</li>
	<li>inherited methods</li>
	<li>static methods</li>
</ol>
</p>

<p>
For attributes with get/set accessors (ex: <code>getPeriod</code> and <code>setPeriod</code>), the get method should appear before the set one. If a has method is available (ex: <code>hasPeriod</code>), it should figure previously (has/get/set order).
</p>



<h3>Please react!</h3>

<p>If you have information more detailed or more recent than those presented in
this document, if you noticed errors, neglects or points insufficiently
discussed, or if you would like to contribute and help us, even a little
bit, <a href="mailto:olivier.boudeville@online.fr?subject=[Ceylan]%20Coding%20conventions">drop us a line</a>!</p>

<br>
<br>

<hr>

<center>
  [<a href="#_top_">Top</a>]
  <br>
  <br>
  <em>Last update: Monday, January 3, 2011
</em>
</center>

</body>
</html>
